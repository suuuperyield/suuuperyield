# Overview
Source: https://docs.gluex.xyz/api-reference/about/overview

Learn about the fundamentals of GlueX APIs and its capabilities

The GlueX API provides developers and partners to securely access the comprehensive set of tools to interact with DeFi and execute complex transactions across multiple EVM networks

<CardGroup cols={2}>
  <Card title="Router API" href="/api-reference/router-api/post-quote">
    Perform efficient and secure interactions like swaps, bridging, lending,
    staking, yield farming, zaps and swidges
  </Card>

  <Card title="Exchange Rate API" href="/api-reference/exchange-rate-api/post-price">
    Fetch real time onchain exchange rates for any token pair
  </Card>

  <Card title="Yield API" href="/api-reference/yield-api/post-diluted-apy">
    Analyzes and calculates APY and TVL across different DeFi protocols and
    liquidity pools
  </Card>
</CardGroup>


# Authentication, Limits and Errors
Source: https://docs.gluex.xyz/api-reference/exchange-rate-api/authentication-limits-and-errors





# Token Price
Source: https://docs.gluex.xyz/api-reference/exchange-rate-api/post-price

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/main/exchange-rates-api/openapi.json post /



# Authentication, Limits and Errors
Source: https://docs.gluex.xyz/api-reference/router-api/authentication-limits-and-errors



The GlueX Router API provides secure, scalable access to decentralized exchange routing and trading functionality. This comprehensive guide covers authentication requirements, rate limiting policies, and error handling mechanisms to ensure successful integration with your applications

***

## API Authentication

All GlueX Router API requests require proper authentication using an API key and integrator ID. This dual-authentication approach ensures secure access, enables comprehensive usage tracking, and applies appropriate rate limits based on your access tier

### Getting your API credentials

* Navigate to the [GlueX Portal](https://portal.gluex.xyz/) and complete the registration process by creating your account
* Navigate to the "API Key" section and click "Generate Key" to generate a new API key
* In the same dashboard, locate your unique integrator ID

<Note>
  For a detailed walkthrough of the complete registration process, refer to the
  [Get a GlueX API key –
  Portal](/documentation/integrating-gluex/getting-an-api-key) guide
</Note>

### Using the Credentials

**Authentication Headers**

Every API request must include your API key in the request headers:

```http
x-api-key: <your-api-key>
```

**Request Body**

Include your integrator ID as the `uniquePID` parameter in the body of each API request:

```json
"uniquePID": "<your-integrator-id>"
```

**Example Request**

```http
POST /v1/price
Host: https://router.gluex.xyz
x-api-key: your-api-key
Content-Type: application/json
```

```json
{
  "chainID": "ethereum",
  "inputToken": "0x...",
  "outputToken": "0x...",
  "inputAmount": "100000000",
  "userAddress": "0x...",
  "outputReceiver": "0x...",
  "uniquePID": "your-integrator-id"
}
```

***

## Rate Limits and Access Tiers

GlueX provides tiered API access levels to accommodate diverse integration requirements, from initial prototyping and testing to high frequency, large scale production deployments. These tiers ensure fair resource allocation and optimal service performance for all partners

### Access Tiers Overview

To ensure the stability, reliability and equitable access of the Router API for all users, we implement a system of rate limits organized into distinct access tiers. These limits protect our infrastructure from abuse, manage system load efficiently and guarantee a high quality experience even during peak demand. Each access tier offers a specific API request rate, burst capacity and a corresponding level of support, tailored to different development and production needs

| Tier           | Requests Per Second (RPS) | Burst Capacity | Use Case                                                                                                                                                |
| :------------- | :------------------------ | :------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Basic**      | 3                         | 3              | Ideal for initial development, proof of concept projects, testing and small scale application with infrequent API calls                                 |
| **Growth**     | 10                        | 30             | Suitable for mid sized production application, services and applications with moderate user traffic                                                     |
| **Premium**    | 20                        | 50             | Designed for large scale production applications, real time trading interfaces and platforms requiring consistent high throughput                       |
| **Enterprise** | Custom                    | Custom         | Tailored solutions for high volume exchanges, large scale aggregators, institutional trading desks and partners with unique infrastructure requirements |

### Understanding RPS and Burst Capacity

* **Requests Per Second (RPS):** This is the **sustained rate** at which your application can make API calls over a longer period. For example, a tier with 3 RPS can make, on average, 3 requests every second
* **Burst Capacity:** This represents the **maximum number of requests** your application can send in a very short spike *above* its sustained RPS limit before hitting a rate limit error. It acts as a buffer to absorb sudden, short term surges in traffic. Once the burst capacity is depleted, requests will be throttled back to the sustained RPS rate until the bucket refills

### Upgrading your Tier

As your application scales and your API usage grows, GlueX offers seamless tier upgrades to meet your evolving demands. Higher tiers unlock significant advantages, including increased API throughput, enhanced reliability guarantees and dedicated support

<Note>
  Partners interested in upgrading their access tier are encouraged to reach out
  directly to the **GlueX team** via our [official Telegram
  channel](https://t.me/+_VmO_gIrNjxiZWE0). During this process, we will discuss
  your specific needs, projected API usage and provide tailored solutions
</Note>

⚠️ **Important Note on Endpoint Usage**

To maintain platform stability and ensure optimal performance for all users, GlueX enforces **stricter rate limits on high computation endpoints**, specifically `/v1/quote`. The `/v1/quote` endpoint performs intensive onchain simulations, which are
resource heavy

Conversely, the `/v1/price` endpoint is designed to be lightweight and highly performant for frequent polling. It provides rapid price estimates without deep onchain simulation

**Best Practice:**

* **`/v1/price`** should be the **primary endpoint used in your application**
  for displaying real time indicative prices and general market information
* **`/v1/quote`** should be called **only when a user is ready to execute a
  swap** and requires precise, executable transaction data.

Adhering to this practice will help you stay within your rate limits and ensure a smooth user experience

### Benefits of Higher Tiers

* **Increased Rate Limits:** Access significantly higher RPS and burst capacities to support larger user bases and more demanding applications
* **Service Level Agreements (SLAs):** Enterprise and Premium tiers often come with formal SLAs, guaranteeing specific uptime, performance metrics and response times for critical issues
* **Priority Support:** Receive expedited assistance from our technical team, ensuring your queries and issues are addressed promptly
* **Custom Integration Guidance:** Benefit from dedicated technical consultations and integration support to optimize your application's performance and integrate the features effectively
* **Custom Pricing and Billing:** For Enterprise partners, flexible pricing models can be arranged to align with your business operations

We are committed to providing a reliable and scalable API experience. If you anticipate exceeding your current tier's limits or have any questions regarding your access tier, please [contact us](https://t.me/+_VmO_gIrNjxiZWE0) for further assistance

### Whitelist Domains

GlueX provides an optional security feature that allows you to restrict API key usage to specific domains. This is particularly valuable for frontend integrations and helps prevent unauthorized usage of your credentials

**Configure**

* Navigate to the **"Keys"** page in the GlueX Portal
* Choose the API key you want to configure
* Add the domains you want to whitelist (eg: `gluex.xyz`)
* Apply the whitelist settings

Requests originating from unlisted domains will be rejected, helping you prevent unauthorized use of your key, so ensure all legitimate domains are included in your whitelist

For assistance or issues related to authentication, contact the GlueX team via the [Telegram support channel](https://t.me/+_VmO_gIrNjxiZWE0)

***

## Error Codes

The Router API performs various validations and simulations to ensure that transactions are safe and executable before returning calldata. If a request fails validation or simulation, the API responds with a standardized error format

### Error Format

All API errors follow a consistent JSON structure for predictable error handling:

```json
{
  "statusCode": <HTTP_STATUS_CODE>,
  "error": "<DESCRIPTIVE_ERROR_MESSAGE>"
}
```

### Error Reference

#### Authorization Errors

**Missing API Key**

```json
{
  "statusCode": 401,
  "error": "Forbidden"
}
```

* **Cause:** API key not provided in request headers
* **Resolution:** Ensure `x-api-key` header is included with valid API key
* **Common Scenarios:** Missing header, empty header value

#### Domain Not Whitelisted

```json
{
  "statusCode": 403,
  "error": "Request origin not in whitelist"
}
```

* **Cause:** Request originates from a domain not in your whitelist
* **Resolution:** Add the requesting domain to your whitelist in the portal
* **Common Scenarios:** New domain deployment, subdomain access, local development

#### Rate Limiting Errors

```json
{
  "statusCode": 429,
  "error": "Rate limit exceeded. Please try again later"
}
```

* **Cause:** Request rate exceeds your tier's RPS or burst capacity limits
* **Resolution:** Implement proper rate limiting in your application or upgrade your tier
* **Prevention Strategies:**
  * Implement exponential backoff retry logic
  * Monitor your request patterns
  * Consider tier upgrade for higher limits
  * Use `/v1/price` for frequent polling instead of `/v1/quote`

#### Simulation Failure

If the transaction fails during pre-trade simulation (to prevent onchain reverts), the API will return:

```json
{
  "statusCode": 400,
  "error": "Unable to fetch a solution for the user request"
}
```

* **Cause:** The router was unable to find a valid routing path or execution strategy that would succeed based on the current market conditions, balances or configuration
* **Common Reasons:**
  * Insufficient liquidity for the requested trade
  * Token pair not supported on specified network
  * Amount exceeds available liquidity
  * Network congestion or temporary routing issues
* **Resolution Strategies:**
  * Reduce trade amount
  * Try different token pairs
  * Check network status
  * Retry after a brief delay

#### Validation Error

If the request contains any invalid parameter that is unrecognized or unsupported, the API will return:

```json
{
  "statusCode": 400,
  "error": "Invalid <parameter_name> provided"
}
```

* **Cause:** Request contains unrecognized, unsupported, or malformed parameters
* **Resolution:** Validate all parameters against API specification
* **Common Issues:**
  * Invalid token addresses
  * Unsupported chain IDs
  * Malformed amounts or addresses
  * Missing required parameters


# Liquidity Modules
Source: https://docs.gluex.xyz/api-reference/router-api/get-liquidity

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/main/router-api/openapi.json get /liquidity
List of all the liquidity modules by chain supported by GlueX



# Price (without calldata)
Source: https://docs.gluex.xyz/api-reference/router-api/post-price

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/main/router-api/openapi.json post /v1/price



# Quote (with calldata)
Source: https://docs.gluex.xyz/api-reference/router-api/post-quote

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/main/router-api/openapi.json post /v1/quote



# GraphQL Playground
Source: https://docs.gluex.xyz/api-reference/tokens-api/graphql



GlueX token API exposes a **single**, public GraphQL endpoint that lets you retrieve token metadata across all [supported chains](/documentation/references/supported-networks) with:

* **Fuzzy search** on symbol, name and address
* **Category filters** (eg: stablecoins, LP tokens)
* **Offset based pagination** suitable for stateless clients

Each token record includes it's contract address, symbol, decimals, economic type, a priority score for sorting and brand assets

<Note title="Try it now">
  Spin up the schema, auto complete queries and inspect live response via the \
  [interactive GraphQL Playground](https://tokens.gluex.xyz/graphql)
</Note>

***

## Endpoint

**Method**: `POST`

**Endpoint**: `https://tokens.gluex.xyz/graphql`

**Request body**

```jsonc
{
  "query": "GraphQL document as a string",
  "variables": {
    /* optional */
  },
  "operationName": "OptionalOperationName"
}
```

**Response**

| field          | purpose                                                                   |
| -------------- | ------------------------------------------------------------------------- |
| `tokenAddress` | Canonical EIPF55 checksum address                                         |
| `symbol`       | Ticker (≤ 11 chars)                                                       |
| `name`         | Name of the token                                                         |
| `decimals`     | ERC20 decimal (6, 8, 18 …)                                                |
| `type`         | Type of the token (`tradable`, `lp`, `stake`, `lend`, `invest`, `stable`) |
| `priority`     | Relevance score - assigned based on liqudity depth and trade volume       |
| `branding.*`   | Brand assets                                                              |

<Info>
  Launch the fully typed schema explorer, run ad hoc queries and inspect live
  JSON in the **[interactive GraphQL
  Playground](https://tokens.gluex.xyz/graphql)** — no auth token required
</Info>

## Quick Start

<CodeGroup>
  ```bash bash
  curl -X POST https://tokens.gluex.xyz/graphql \
    -H "content-type: application/json" \
    -d '{
          "query": "query ($chain:String!,$limit:Int!){tokens(chain:$chain,limit:$limit){items{symbol name}}}",
          "variables": { "chain": "ethereum", "limit": 5 }
        }'
  ```

  ```javascript javascript (fetch)
  // Browser / Node 18+ native fetch
  const body = JSON.stringify({
    query: `query Tokens($chain:String!,$limit:Int!){
              tokens(chain:$chain,limit:$limit){items{symbol name}}}`,
    variables: { chain: "ethereum", limit: 5 },
  });

  const res = await fetch("https://tokens.gluex.xyz/graphql", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body,
  });
  console.log(await res.json());
  ```

  ```javascript javascript (axios)
  import axios from "axios";

  const { data } = await axios.post(
    "https://tokens.gluex.xyz/graphql",
    {
      query: `query ($chain:String!,$limit:Int!){
                tokens(chain:$chain,limit:$limit){items{symbol name}}}`,
      variables: { chain: "ethereum", limit: 5 },
    },
    { headers: { "content-type": "application/json" } }
  );

  console.log(data);
  ```

  ```javascript javascript (graphql client)
  import { request, gql } from "graphql-request";

  const endpoint = "https://tokens.gluex.xyz/graphql";

  const query = gql`
    query Tokens($chain: String!, $limit: Int!) {
      tokens(chain: $chain, limit: $limit) {
        items {
          symbol
          name
        }
      }
    }
  `;

  const data = await request(endpoint, query, { chain: "ethereum", limit: 5 });
  console.log(data);
  ```

  ```typescript typescript (urql)
  import { createClient, gql } from "@urql/core";

  const client = createClient({ url: "https://tokens.gluex.xyz/graphql" });

  const Tokens = gql`
    query ($chain: String!, $limit: Int!) {
      tokens(chain: $chain, limit: $limit) {
        items {
          symbol
          name
        }
      }
    }
  `;

  const result = await client
    .query(Tokens, { chain: "ethereum", limit: 5 })
    .toPromise();
  console.log(result.data);
  ```

  ```python python
  import requests, json

  query = '''
  query Tokens($chain:String!,$limit:Int!){
    tokens(chain:$chain, limit:$limit){ items { symbol name } }
  }'''

  variables = { "chain": "ethereum", "limit": 5 }

  resp = requests.post(
      "https://tokens.gluex.xyz/graphql",
      json={ "query": query, "variables": variables },
      headers={ "content-type": "application/json" }
  )
  print(json.dumps(resp.json(), indent=2))
  ```

  ```python python (graphql)
  from gql import gql, Client
  from gql.transport.aiohttp import AIOHTTPTransport
  import asyncio, json

  async def main():
      transport = AIOHTTPTransport(url="https://tokens.gluex.xyz/graphql")
      async with Client(transport=transport) as session:
          query = gql("""
            query ($chain:String!, $limit:Int!){
              tokens(chain:$chain, limit:$limit){ items { symbol name } }
            }""")
          result = await session.execute(query, variable_values={"chain":"ethereum","limit":5})
          print(json.dumps(result, indent=2))

  asyncio.run(main())
  ```
</CodeGroup>

***

## Core Queries

### All Tokens

```graphql
query Tokens($chain: String!, $limit: Int = 20, $offset: Int = 0) {
  tokens(chain: $chain, limit: $limit, offset: $offset) {
    items {
      tokenAddress
      symbol
      name
      decimals
      type
      priority
      branding {
        logoUri
      }
    }
    total
    hasMore
  }
}
```

| Variable | Required | Default | Description                                                           | Possible Values / Type                                 |
| -------- | :------: | ------- | --------------------------------------------------------------------- | ------------------------------------------------------ |
| chain    |     ✅    | —       | Identifier for the chain (eg: "ethereum", "hyperevm", "polygon", ...) | [string](/documentation/references/supported-networks) |
| limit    |     ❌    | 20      | Maximum number of results to return per page (recommended max: 50)    | integer                                                |
| offset   |     ❌    | 0       | Number of items to skip for pagination                                | integer                                                |

### Tokens by Type

```graphql
query TokensByType(
  $chain: String!
  $tokenType: String! # tradable | lp | stake | lend | invest | stable
  $limit: Int = 20
  $offset: Int = 0
) {
  tokensByType(
    chain: $chain
    tokenType: $tokenType
    limit: $limit
    offset: $offset
  ) {
    items {
      tokenAddress
      symbol
      name
    }
    total
    hasMore
  }
}
```

| Variable  | Required | Default | Description                                                           | Possible Values / Type                                 |
| --------- | :------: | ------- | --------------------------------------------------------------------- | ------------------------------------------------------ |
| chain     |     ✅    | —       | Identifier for the chain (eg: "ethereum", "hyperevm", "polygon", ...) | [string](/documentation/references/supported-networks) |
| tokenType |     ✅    | —       | Enum that describes type of token                                     | tradable \| lp \| stake \| lend \| invest \| stable    |
| limit     |     ❌    | 20      | Maximum number of results to return per page (recommended max: 50)    | integer                                                |
| offset    |     ❌    | 0       | Number of items to skip for pagination                                | integer                                                |

### Search Tokens

```graphql
query SearchTokens(
  $chain: String!
  $pattern: String! # case insensitive substring
  $limit: Int = 20
  $offset: Int = 0
) {
  searchTokens(
    chain: $chain
    pattern: $pattern
    limit: $limit
    offset: $offset
  ) {
    items {
      tokenAddress
      symbol
      name
    }
    total
    hasMore
  }
}
```

| Variable | Required | Default | Description                                                               | Type / Possible Values                                 |
| -------- | :------: | ------- | ------------------------------------------------------------------------- | ------------------------------------------------------ |
| chain    |     ✅    | —       | Identifier for the chain (eg: "ethereum", "hyperevm", "polygon", ...)     | [string](/documentation/references/supported-networks) |
| pattern  |     ✅    | —       | Case insensitive substring to match against token address, name or symbol | string                                                 |
| limit    |     ❌    | 20      | Maximum number of results to return per page (recommended max: 50)        | integer                                                |
| offset   |     ❌    | 0       | Number of items to skip for pagination                                    | integer                                                |


# Tokens
Source: https://docs.gluex.xyz/api-reference/tokens-api/reference

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/main/tokens-api/openapi.json post /graphql



# Authentication, Limits and Errors
Source: https://docs.gluex.xyz/api-reference/yield-api/authentication-limits-and-errors

Documentation for the Yield API's open authentication model, system resource limits, comprehensive error handling with detailed error types and steps, and monitoring capabilities

## API Authentication

The APY Calculator API currently operates as an **open API** without authentication requirements. This design choice prioritizes accessibility and ease of integration for developers while maintaining service reliability through other protective mechanisms

### CORS Policy

The API implements comprehensive Cross-Origin Resource Sharing (CORS) settings to maximize compatibility across different client environments:

```python
allow_origins=["*"]           # Accepts requests from any domain
allow_credentials=True        # Supports cookies and authentication headers
allow_methods=["GET", "POST"] # Supports primary HTTP methods
allow_headers=["*"]           # Accepts any request headers
```

This configuration allows requests from any origin, making it suitable for frontend integrations and testing

**Security Considerations:**

* While permissive, the API relies on input validation and rate limiting for protection
* No sensitive authentication data is exposed due to the open access model
* All requests are logged with unique identifiers for monitoring

### Request Identification

While authentication is not required, each request receives a unique identifier for tracking and debugging purposes:

```http
X-Request-ID: uuid4-generated-string
```

This header is automatically added to all responses and can be used for support inquiries

***

## Rate Limits and Usage Constraints

The API implements intelligent constraints designed to balance performance, reliability, and fair resource allocation across all users

### Input Amount Validation

**Diluted APY Calculations:**

* **Constraint**: Input amounts must be non-negative integers (≥ 0)
* **Rationale**: Negative amounts would produce meaningless yield calculations
* **Validation**: Performed at the endpoint level before processing
* **Error Response**: Returns `422` status with `validation_error` type

**Example Valid Inputs:**

```json
{
  "input_amount": 1000, // ✅ Valid
  "input_amount": 0, // ✅ Valid (edge case)
  "input_amount": 1000000000 // ✅ Valid (large amounts supported)
}
```

**Invalid Examples:**

```json
{
  "input_amount": -100, // ❌ Negative value
  "input_amount": 1000.5, // ❌ Decimal value
  "input_amount": "1000" // ❌ String format
}
```

### Batch Processing Limits

**Maximum Multicall Size**: 30 calls per batch request

**Technical Reasoning:**

* **Timeout Prevention**: Larger batches risk exceeding response time limits
* **Memory Management**: Prevents excessive memory allocation per request
* **Fair Resource Distribution**: Ensures no single request monopolizes system resources

**Optimal Batch Strategies:**

* Group related calculations (same protocol/chain) for better caching efficiency
* Split large datasets into multiple sequential batch requests
* Implement client side batching logic for datasets exceeding 30 items

### Blockchain Support

The API provides comprehensive coverage across major EVM-compatible networks, with standardized naming conventions and aliases for developer convenience

* Ethereum (`ethereum`)
* Base (`base`)
* Arbitrum (`arbitrum`)
* BNB Chain (`bnb`, `binance smart chain`, `bsc`)
* Avalanche (`avalanche`)
* Gnosis (`gnosis`)
* Polygon (`polygon`)
* Optimism (`optimism`)
* Mantle (`mantle`)
* Linea (`linea`)
* Scroll (`scroll`)
* Taiko (`taiko`)
* Blast (`blast`)
* Sonic (`sonic`)
* Berachain (`berachain`)
* Unichain (`unichain`)
* HyperEVM (`hyperevm`)

### Timeout Configurations

The API implements environment-aware timeout settings optimized for different deployment contexts

| Operation Type   | Production Timeout | Local Timeout |
| ---------------- | ------------------ | ------------- |
| Liquidity States | 1s                 | 20s           |
| Dependent States | 1s                 | 20s           |

**Timeout Strategy:**

* **Production**: Aggressive timeouts ensure responsive user experience
* **Development**: Extended timeouts accommodate debugging and testing
* **Automatic Failover**: Requests failing due to timeouts trigger retry mechanisms where applicable

### Cache Configuration

The API employs multi-tiered caching for optimal performance and resource utilization

* **Cache Size**: 10,000 entries maximum
* **Cache TTL**: 300 seconds (5 minutes)
* **APY Cache**: 3,600 seconds (1 hour)

### System Resource Limits

The API implements dynamic resource monitoring with automatic request rejection when system constraints are exceeded

* **CPU Usage**: Above 95%
* **Memory Usage**: Above 95%
* **Error Rate**: Above 75% (when total requests > 10)

***

## Error Handling

The API provides comprehensive error handling with structured responses designed for both human debugging and programmatic error recovery

### Error Format

All API errors follow a consistent, machine-readable JSON structure that provides multiple levels of diagnostic information:

```json
{
  "success": false,
  "error": "Error message description",
  "error_type": "error_category",
  "step": "operation_step",
  "request_id": "uuid4-request-identifier"
}
```

**Field Descriptions:**

* **success**: Always `false` for error responses (enables quick programmatic checks)
* **error**: Human readable message suitable for logging and debugging
* **error\_type**: Standardized category for programmatic error handling
* **step**: Specific operation stage where failure occurred
* **request\_id**: Unique identifier for support and debugging correlation

### Error Types

#### Validation Errors

**HTTP Status Code: 422 Unprocessable Entity**
**Error Type: `validation_error`**

These errors occur during input parameter validation before any processing begins. They indicate client-side issues that require request modification

```json
{
  "success": false,
  "error": "pool_address must be a valid Ethereum address (0x...)",
  "error_type": "validation_error",
  "step": "input_validation"
}
```

**Common validation errors**

* Invalid Ethereum addresses (must be 42 characters with 0x prefix)
* Unsupported blockchain networks
* Missing required parameters (`pool_address` or `lp_token_address`)
* Invalid input amounts (negative values)
* Input token same as LP token

#### Calculation Errors

**HTTP Status Code: 404 Not Found**
**Error Type: `calculation_failed`**

These errors occur when the API successfully validates inputs but cannot complete the requested calculation due to missing data or computational issues

```json
{
  "success": false,
  "error": "Pool data not found for pool_address=0x... in chain ethereum",
  "error_type": "calculation_failed",
  "step": "pool_data_retrieval"
}
```

Common calculation errors:

* Pool not found in database
* Incomplete pool states
* Missing protocol modules
* Network timeout during state calls

#### Internal Server Errors

**HTTP Status Code: 500 Internal Server Error**
**Error Type: `internal_error`**

System level errors:

```json
{
  "success": false,
  "error": "Database connectivity failed",
  "error_type": "internal_error",
  "request_id": "abc123-def456-ghi789"
}
```

#### Service Unavailable

**HTTP Status Code: 503 Service Unavailable**
**Error Type: `startup_error` or `resource_exhaustion`**

Service initialization failures:

```json
{
  "success": false,
  "error": "Service initialization failed",
  "error_type": "startup_error"
}
```

#### Database Errors

Database connectivity issues are handled gracefully:

```json
{
  "success": false,
  "error": "Database error during pool_address lookup: Connection timeout",
  "error_type": "calculation_failed",
  "step": "pool_data_retrieval"
}
```

#### Network and Timeout Errors

Blockchain network calls may timeout:

```json
{
  "success": false,
  "error": "Timeout during state calls",
  "error_type": "calculation_failed",
  "step": "state_calls_timeout"
}
```

### Error Step Mapping

#### Common Steps

* `input_validation`: Parameter validation failed
* `pool_data_retrieval`: Cannot fetch pool data from database
* `protocol_id_validation`: Missing or invalid protocol identifier
* `module_import_failed`: Cannot load required blockchain modules
* `initialization_failed`: Pool initialization error

#### APY Calculation Steps

* `input_token_validation`: Invalid input token address
* `lp_token_validation`: Input token conflicts with LP token
* `apy_calculation_error`: Mathematical calculation failed
* `states_incomplete`: Required blockchain states not available

#### TVL Calculation Steps

* `tvl_calculation_error`: TVL computation failed
* `pool_creation_failed`: Cannot instantiate pool object

***

## Health Monitoring

The API provides comprehensive health monitoring capabilities designed for both operational oversight and integration into larger monitoring ecosystems

### Health Check Endpoint

**Endpoint**: `GET /health-check`
**Purpose**: Comprehensive system validation suitable for load balancer health checks and monitoring systems

* Router initialization status
* Database connectivity
* Error rate analysis (must be \< 75%)
* System resource usage (CPU and memory \< 95%)

### Metrics Monitoring

**Endpoint**: `GET /metrics`
**Purpose**: Detailed performance and operational metrics for observability and optimization

**Response Format:**

```json
{
  "success": true,
  "request_metrics": {
    "total_requests": 1000,
    "cache_hit_rate_percent": 85.5,
    "error_rate_percent": 2.1,
    "avg_response_time_seconds": 0.245
  },
  "system_metrics": {
    "cpu_usage_percent": 45.2,
    "memory_usage_percent": 68.1,
    "pending_tasks": 3,
    "cache_size": 150,
    "uptime_seconds": 86400
  }
}
```

***

## Best Practices

### Error Handling in Client Applications

1. **Always check the `success` field** before processing response data
2. **Use `error_type` for programmatic error handling** rather than parsing error messages
3. **Include `request_id` in support requests** for faster debugging
4. **Implement retry logic** for timeout and network errors
5. **Cache successful responses** to reduce API load

### Request Optimization

1. **Use caching**: Identical requests within 5 minutes return cached results
2. **Validate addresses client-side**: Ensure Ethereum addresses are properly formatted
3. **Handle both lookup methods**: Support both `pool_address` and `lp_token_address` parameters
4. **Specify input tokens**: Avoid auto-selection overhead when possible

### Error Recovery

For transient errors (timeouts, network issues):

* Use different endpoints if available (`pool_address` vs `lp_token_address`)

For permanent errors (validation, not found):

* Validate input data
* Check supported chains and protocols via `/active-protocols`


# Active Protocols
Source: https://docs.gluex.xyz/api-reference/yield-api/get-protocols

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/refs/heads/main/yield-router-api/openapi.json get /active-protocols
Fetches a list of supported blockchain networks and their associated active lending protocols.



# Diluted APY
Source: https://docs.gluex.xyz/api-reference/yield-api/post-diluted-apy

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/refs/heads/main/yield-router-api/openapi.json post /diluted-apy
Calculate the diluted Annual Percentage Yield (APY) for a lending pool considering the impact of a specific amount.



# Historical APY
Source: https://docs.gluex.xyz/api-reference/yield-api/post-historical-apy

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/refs/heads/main/yield-router-api/openapi.json post /historical-apy
Calculate the historical Annual Percentage Yield (APY) for a lending pool without considering liquidity impact.



# Total Value Locked
Source: https://docs.gluex.xyz/api-reference/yield-api/post-tvl

https://raw.githubusercontent.com/gluexprotocol/gluex-openapis/refs/heads/main/yield-router-api/openapi.json post /tvl
Calculate the Total Value Locked (TVL) in USD for a lending pool.



# API Endpoints
Source: https://docs.gluex.xyz/build-with-gluex/exchange-rate/api-endpoints

This section outlines the primary endpoints provided by the GlueX Exchange Rates API for fetching real-time on-chain token prices and metadata across multiple blockchains.

The GlueX Exchange Rates API offers a streamlined interface to access accurate, rea -time market data directly from decentralized sources. This section details the core endpoints you'll utilize to query token prices, retrieve lists of supported blockchains and fetch comprehensive token metadata

> The `POST /` endpoint is your primary tool for fetching **real time exchange rates** for specific token pairs, supporting batch requests for efficiency

## POST `/`

Returns real time **exchange rates** for one or more token pairs across specified blockchains. This is the primary endpoint for fetching price data

**Description**

* Provides the current exchange rate (`price`) for requested token pairs
* Supports batch requests, allowing you to query up to 25 pairs in a single API call for optimized performance
* Requires `domestic_blockchain`, `domestic_token`, `foreign_blockchain` and `foreign_token` for each pair

**Example Request**

```http
POST /
x-api-key: your-optional-api-key
Content-Type: application/json
```

**Request Body (Example)**

```json
[
  {
    "domestic_blockchain": "ethereum",
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7"
  },
  {
    "domestic_blockchain": "polygon",
    "domestic_token": "0x2791bca1f2de4661ed88a30c99a7a9229f6476ed",
    "foreign_blockchain": "polygon",
    "foreign_token": "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619"
  }
]
```

**Response**

```json
[
  {
    "domestic_blockchain": "ethereum",
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "price": 0.99987654
  },
  {
    "domestic_blockchain": "polygon",
    "domestic_token": "0x2791bca1f2de4661ed88a30c99a7a9229f6476ed",
    "foreign_blockchain": "polygon",
    "foreign_token": "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
    "price": 0.00032109
  }
]
```

**Error Responses**

* 400 Bad Request: Invalid request payload (eg: missing required fields, malformed JSON)
* 500 Server Error: An unexpected error occurred on the server


# Rate Limits and Access Tiers
Source: https://docs.gluex.xyz/build-with-gluex/exchange-rate/api-tiers-limits



GlueX provides tiered API access levels to accommodate diverse integration requirements, from initial prototyping and testing to high frequency, large scale production deployments. These tiers ensure fair resource allocation and optimal service performance for all partners

## Rate Limits and Access Tiers

To ensure the stability, reliability and equitable access of the APIs for all users, we implement a system of rate limits organized into distinct access tiers. These limits protect our infrastructure from abuse, manage system load efficiently and guarantee a high quality experience even during peak demand. Each access tier offers a specific API request rate, burst capacity and a corresponding level of support, tailored to different development and production needs

### Access Tiers Overview

...

### Understanding RPS and Burst Capacity

* **Requests Per Second (RPS):** This is the **sustained rate** at which your application can make API calls over a longer period. For example, a tier with 3 RPS can make, on average, 3 requests every second
* **Burst Capacity:** This represents the **maximum number of requests** your application can send in a very short spike *above* its sustained RPS limit before hitting a rate limit error. It acts as a buffer to absorb sudden, short term surges in traffic. Once the burst capacity is depleted, requests will be throttled back to the sustained RPS rate until the bucket refills

## How to Upgrade Your Tier

As your application scales and your API usage grows, GlueX offers seamless tier upgrades to meet your evolving demands. Higher tiers unlock significant advantages, including increased API throughput, enhanced reliability guarantees and dedicated support

Partners interested in upgrading their access tier are encouraged to reach out directly to the **GlueX team** via our [official Telegram channel](https://t.me/+_VmO_gIrNjxiZWE0). During this process, we will discuss your specific needs, projected API usage and provide tailored solutions

### Benefits of Higher Tiers

* **Increased Rate Limits:** Access significantly higher RPS and burst capacities to support larger user bases and more demanding applications
* **Service Level Agreements (SLAs):** Enterprise and Premium tiers often come with formal SLAs, guaranteeing specific uptime, performance metrics and response times for critical issues
* **Priority Support:** Receive expedited assistance from our technical team, ensuring your queries and issues are addressed promptly
* **Custom Integration Guidance:** Benefit from dedicated technical consultations and integration support to optimize your application's performance and integrate the features effectively
* **Custom Pricing and Billing:** For Enterprise partners, flexible pricing models can be arranged to align with your business operations

***

We are committed to providing a reliable and scalable API experience. If you anticipate exceeding your current tier's limits or have any questions regarding your access tier, please contact us for further assistance


# Overview
Source: https://docs.gluex.xyz/build-with-gluex/exchange-rate/overview

GlueX Exchange Rates API - Real time, onchain exchange rates across multiple blockchains

The GlueX Exchange Rates API provides developers with a robust, scalable, and real time solution to fetch onchain exchange rates for any token pair across multiple supported blockchains. Perfect for integrating live pricing data into DeFi applications, crypto wallets, trading platforms and analytical dashboards

## Base URL

All API endpoint requests are made relative to the following base URL:

```http
http://exchange-rates.gluex.xyz
```

## Key Features

* **Realtime & Accurate Rates**: Realtime data feeds to obtain highly accurate, up to the second exchange rates directly from decentralized liquidity sources, ensuring your application always has the most current information
* **Multichain Support**: Access extensive rate data across a growing ecosystem of EVM compatible blockchains, including major networks like Ethereum, BNB Chain, Polygon, Arbitrum, Optimism, and many others, all through a single, unified API
* **Batch Requests**: Optimize your data fetching and minimize network overhead by retrieving exchange rates for up to 25 distinct token pairs in a single, efficient API call
* **Instant Access**: Start building immediately with public, unauthenticated endpoints for quick testing and low volume usage. For higher throughput, dedicated rate limits and enhanced reliability, easily provision and use an API key
* **Fast & Reliable**: Experience exceptional responsiveness with an average request round trip of under 500ms, ensuring your application remains highly responsive and delivers immediate data to users
* **Specialized Support**: Designed to intelligently handle a wide array of token types, including rebase tokens, yield bearing assets, LP tokens and other complex edge cases, providing reliable rates for even the most nuanced DeFi assets

<CardGroup cols={2}>
  <Card title="Try Out Now" icon="play" href="/api-reference/exchange-rate-api/post-price">
    Experience DeFi at it's finest. Test the Exchange Rate API instantly
    directly in your browser
  </Card>

  <Card title="Explore Guides" icon="rocket" href="/guides">
    Dive into step by step guides and best practices for integrating the
    Exchange Rate API
  </Card>
</CardGroup>

***

## Tutorials

* [How to Request Exchange Rates](/guides/exchange-rate/how-to-request-exchange-rates)
* [How to Request All Supported Chains](/guides/exchange-rate/how-to-request-all-supported-chains)


# Request and Response Format
Source: https://docs.gluex.xyz/build-with-gluex/exchange-rate/request-response-format

This document outlines the structure of requests and responses for Exchange Rate (common fields and endpoint specific fields)

This document provides a comprehensive guide to the structures used when interacting with the Exchange Rate API. Understanding these formats is crucial for correctly constructing your requests and parsing the API responses

## Request Parameters

The following parameters may be included in the request payload for `/` endpoint

| Name                  | Type   | Required | Description                                        |
| --------------------- | ------ | -------- | -------------------------------------------------- |
| `domestic_blockchain` | string | ✅        | Identifier for the domestic chain (eg: `ethereum`) |
| `domestic_token`      | string | ✅        | Address of the domestic token                      |
| `foreign_blockchain`  | string | ✅        | Identifier for the foreign chain                   |
| `foreign_token`       | string | ✅        | Address of the foreign token                       |

**Example Request Body**

```json
[
  {
    "domestic_blockchain": "ethereum",
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7"
  },
  {
    "domestic_blockchain": "polygon",
    "domestic_token": "0x2791bca1f2de4661ed88a30c99a7a9226cbefc3f",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
  }
]
```

## Common Response Fields

The following fields are returned in both `/v1/price` and `/v1/quote` responses.

| Field                 | Type   | Description                                                                                                                            |
| --------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| `domestic_blockchain` | string | Identifier for the domestic chain (eg: `ethereum`)                                                                                     |
| `domestic_token`      | string | Address of the domestic token                                                                                                          |
| `foreign_blockchain`  | string | Identifier for the foreign chain                                                                                                       |
| `foreign_token`       | string | Address of the foreign token                                                                                                           |
| `price`               | number | The exchange rate between the two tokens. This represents how much of the `foreign_token` you get for one unit of the `domestic_token` |

**Example Response**

```json
[
  {
    "domestic_blockchain": "ethereum",
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "price": 1.00025
  },
  {
    "domestic_blockchain": "polygon",
    "domestic_token": "0x2791bca1f2de4661ed88a30c99a7a9226cbefc3f",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "price": 0.00032
  }
]
```


# Overview
Source: https://docs.gluex.xyz/build-with-gluex/overview



GlueX provides easy widget integrations and a fully customizable API and SDK integrations to power DeFi activity across 17 EVM chains. Our suite of APIs has securely routed over 106 million order flows and more than [10 billion dollars](https://dune.com/gluex_protocol/metrics) in volume

## Build With GlueX

[Apply for an Integrator ID](https://portal.gluex.xyz) and then explore how to build below

<Columns cols={2}>
  <Card img="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=262df6688e0d5171366708fee31444e9" title="Widget" href="/build-with-gluex/widget/overview" width="1200" height="675" data-path="images/hero/widget-dark.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8c2ac9a5c2b6d9dc3a2ff62462656f42 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2ea3f1eaee6c80e30293c8146f69c0fa 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0f7ce78bc1885ccdc1bc1edfa917bdf5 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d6c33dc9c55268a0bdadd6d41857ae46 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=7f75e2709a73f26fec96a05342fd5521 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=171adeae11ea4067ef2f2a8d3b288712 2500w" data-optimize="true" data-opv="2">
    UI components for effortless DeFi integration
  </Card>

  <Card img="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bace964d01ee2edbec5a2450acb4c78f" title="API and SDK" href="/api-reference/about/overview" width="1200" height="675" data-path="images/hero/api-and-sdk-dark.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=14fe213bb1eb6584b08c87fbcb4d40d9 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bb636b861d704802941e4a360a92128d 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=792024e95965409605ab71f0e43e0b71 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d92a0b8a02d82ec468e06679b1be5b9a 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=10d6f40ba631dfc18aedad7ffaf79a0d 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d6ce324e605c86174144c564fd6ad27e 2500w" data-optimize="true" data-opv="2">
    API suite for efficient and secure onchain interaction
  </Card>
</Columns>


# Buy Order
Source: https://docs.gluex.xyz/build-with-gluex/router/advanced-features/buy-order



While traditional swaps (often referred to as `SELL` orders) involve specifying the `inputAmount` and receiving a calculated `outputAmount`, the **Buy Order** functionality allows users to define their desired `outputAmount` of tokens, with the router calculating the required `inputAmount` to achieve that target. This provides greater flexibility for users focused on acquiring a specific amount of an asset

### How It Works

When orderType is set to `BUY`, the GlueX Router fundamentally reverses its calculation logic:

* **Input calculation**: Instead of starting with a fixed input, the router determines the minimum `inputAmount` (and thus `inputToken`) necessary to acquire the `outputAmount` specified by the user, taking into account current market rates, fees and slippage
* **Market buy optimization**: The routing engine optimizes the path to achieve the target outputAmount using the most cost effective `inputAmount` possible

This contrasts directly with the default `SELL` order behavior, where `inputAmount` is predefined, and the `outputAmount` is the calculated variable

### Configuration

To initiate a Buy Order, you must include the `orderType` and `outputAmount` parameters in your `/v1/price` or `/v1/quote` request payload:

```json
{
  // ... other parameters
  "orderType": "BUY",
  "outputAmount": "<desired_output_value>"
}
```

| `orderType` | Required Field | Description                       |
| ----------- | -------------- | --------------------------------- |
| `BUY`       | `outputAmount` | Amount of output token to receive |
| `SELL`      | `inputAmount`  | Amount of input token to swap     |

<Note>
  If `orderType` is **not specified**, it defaults to `SELL`. In this case,
  `inputAmount` parameter becomes mandatory and `outputAmount` will be computed
  by the API
</Note>

### Benefits

* **Flexibility**: Caters directly to users who know exactly how much of a target token they wish to acquire
* **Simplified user flow**: For specific use cases (eg: buying a fixed amount of governance tokens), this simplifies the user experience by reducing mental calculation
* **Optimized input calculation**: The router automatically finds the most efficient way to achieve the desired `outputAmount`


# Liquidity Module Filtering
Source: https://docs.gluex.xyz/build-with-gluex/router/advanced-features/liquidity-module-filtering



The **modulesFilter** is an advanced configuration option that allows developers to precisely control which underlying DEX protocols, lending platforms or other liquidity sources (referred to as [modules](/documentation/references/modules)) should considered when constructing a routing path

### How It Works

By including an array of specific module identifiers in your request, you instruct the routing engine to limit the search space and consider liquidity from these whitelisted sources. Any liquidity available from modules not present in your `modulesFilter` array will be ignored during route construction

<Note>
  Each integrated protocol or liquidity source within GlueX has a unique
  identifier (eg: "uniswap\_v3", "aave\_v3", "curve\_stable\_plain", etc). You can
  find a comprehensive list of supported modules and their identifiers on the
  [liquidity modules](/documentation/references/modules) page or
  [here](https://router.gluex.xyz/liquidity)
</Note>

### Configuration

To filter liquidity modules, include an array of desired module identifiers in your `/v1/price` or `/v1/quote` request payload

```json
{
  // ... other parameters
  "modulesFilter": ["module_1", "module_2"]
}
```

In this example, the router would only consider paths involving `module_1` and `module_2` liquidity, even if other more optimal routes existed on different protocols

### Use Case

This feature is particularly valuable for projects that require fine grained control over their DeFi integrations:

* **Protocol restriction**: Directly restrict routing to only a predefined set of preferred protocols (eg: for compliance reasons, specific security postures or brand alignment)
* **Avoiding specific sources**
* **Avoid using specific liquidity pools or protocols**
* **Compliance and Regulatory constraints**: Meet internal or external compliance policies that mandate interactions only with approved liquidity sources
* **Custom strategies**: Implement advanced strategies where specific liquidity pools are favored or avoided based on institutional preferences or unique market analyses

### Benefits

* **Provides greater control**: Offers unparalleled control over the routing behavior, allowing you to tailor the integration precisely to your application's needs
* **Supports whitelisted integrations**: Facilitates integration with whitelisted or pre approved liquidity sources, which is critical for institutional or regulated environments
* **Enables custom strategies**: Unlocks the ability to implement unique trade strategies that might prioritize certain protocols over others, even if they aren't always the absolute cheapest
* **Enhanced auditability**: By narrowing down the potential sources, it can simplify the auditing process of your application's DeFi interactions


# Partial Fill Order
Source: https://docs.gluex.xyz/build-with-gluex/router/advanced-features/partial-fill-order



In scenarios characterized by low liquidity, fragmented markets or extremely unfavorable market conditions, attempting to execute a full swap with a large `inputAmount` can result in significant and often unacceptable slippage. The **Partial Fill Orders** feature addresses this by dynamically determining and executing only the optimal portion of a trade

### How It Works

Instead of forcing a full trade that might yield a poor outcome (or cause excessive slippage), the Router intelligently calculates the largest tradable portion that still meets efficient pricing

* **Optimal portion calculation**: If the full inputAmount (for a `SELL` order) would cause the trade to exceed an acceptable slippage tolerance or result in an unprofitably high price impact, the router calculates the largest possible portion of the trade that can still be executed efficiently
* The API response will then provide:
  * **Suggested input amount**: the optimized, smaller amount of `inputToken` that can be efficiently traded
  * **Expected output amount**: the amount of `outputToken` achievable with the suggested input

### Example

Imagine a user attempts to swap 1,000 USDC for a less liquid token. In a market with shallow or low liquidity for that specific pair, executing the full 1,000 USDC might cause 5% slippage, resulting in a poor exchange rate. With `isPartialFill: true`, the router might determine that only 730 USDC can be traded efficiently (eg: with 0.5% slippage). In this case, the quote response would suggest using 730 USDC as the `effectiveInputAmount` and provide the corresponding `effectiveOutputAmount`, allowing the user to execute the most efficient part of their desired trade

### Configuration

Partial Fill Orders are **disabled by default** to give integrators full control. You can enable it explicitly in your `/v1/price` or `/v1/quote` API request by setting the `isPartialFill` parameter to `true`:

```json
{
  // ... other parameters
  "isPartialFill": true
}
```

### Benefits

* **Reduces exposure to slippage**: Minimizes potential losses by avoiding transactions that would incur high slippage for the full amount
* **Adapts to realtime market conditions**: Automatically adjusts trade size based on current liquidity and volatility, providing a more robust trading experience
* **Maximizes trade efficiency without user intervention**: Ensures that trades are executed at the best possible price points available, even in challenging market environments, often without direct user intervention beyond the initial configuration
* **Improved user experience**: Prevents failed transactions or surprisingly poor execution for users who might not be aware of underlying liquidity issue


# Surge Protection
Source: https://docs.gluex.xyz/build-with-gluex/router/advanced-features/surge-protection



**Surge Protection** is a built in pre trade safety mechanism designed to safeguard users from significant value loss during periods of shallow liquidity, extreme market volatility or abrupt price movements

### How It Works

Before executing a swap, the Router performs a rapid, hypothetical **reverse trade simulation**. This simulation instantaneously attempts to "sell back" the expected output token for the original input token, all within the context of the same block and without external market interference

* **Simulation logic:** The router uses the current onchain state to estimate how much of the original `inputToken` a user would recover if they immediately tried to reverse the trade
* **Threshold trigger:** If this estimated recovery amount falls below a predefined threshold (currently **90%** of the original `inputAmount`), the trade is deemed high risk and is automatically blocked by the router. This prevents the transaction from being broadcast onchain, saving the user from a potentially significant loss

### Evaluation Criteria

The Surge Protection mechanism evaluates a combination of factors to determine if a trade poses an unacceptable risk:

* **Liquidity depth:** Assesses the available liquidity on the chosen routing path. Extremely shallow liquidity can make trades highly susceptible to price swings
* **Price impact:** Analyzes the estimated price impact of the proposed trade on the affected liquidity pools
* **Volatility within the block:** Detects sudden and significant price changes occurring within the current blockchain block, often indicative of front-running attempts or market manipulation

### Default Threshold

If the estimated reverse loss exceeds **10%** (meaning the recovered amount would be less than 90% of the original input), the trade is halted, and the API returns a `revert: true` flag and the specific error causing the Surge Protection activation

### User Benefits

Implementing Surge Protection directly translates to a safer and more trustworthy experience for the end users:

* **Prevents sudden losses:** Acts as a shield against common DeFi pitfalls like front running (where malicious bots execute trades before and after a user's transaction to profit from price changes) or being the "exit liquidity" in illiquid pools
* **Avoids adverse market conditions:** Protects users from executing trades when liquidity is insufficient or prices are highly volatile, which could lead to substantial value erosion
* **Enhances trust and safety:** By proactively preventing potentially bad trades, Surge Protection significantly enhances user confidence in your application and on us!

### Configuration

Surge Protection is **disabled by default** to give integrators full control. You can enable it explicitly in your `/v1/quote` API request by setting the `surgeProtection` parameter to `true`:

```json
{
  // ... other parameters
  "surgeProtection": true
}
```

<Note>
  When enabled, any trade exceeding the 10% reverse loss threshold will cause
  the `/v1/quote` endpoint to return `revert: true` and will not provide
  executable calldata. Your application should gracefully handle this condition
  and inform the user
</Note>


# API Endpoints
Source: https://docs.gluex.xyz/build-with-gluex/router/api-endpoints

This section outlines the primary endpoints (fetch pricing estimates and generate transaction calldata) provided by the Router API

The GlueX Router API provides a powerful and flexible interface for interacting with decentralized finance protocols. This section outlines the core endpoints you'll use to fetch real time pricing estimates and generate the necessary transaction calldata for seamless onchain execution

> **Note:**
> It is highly recommended to call the `price` endpoint before invoking the `quote` endpoint. This pattern is especially critical when building applications. The `price` endpoint can be polled periodically (eg: every few seconds) to provide users with realtime pricing information. Once the user approves the router contract and confirms the intention to swap, the `quote` endpoint should be called to retrieve the final calldata for onchain execution
>
> This architecture reduces unnecessary load on the quote infrastructure and ensures accurate, timely user interactions. Furthermore, GlueX plans to introduce market maker integrations on the `quote` endpoint, which will enhance price discovery and further optimize rate limits for this endpoint

## POST `/v1/price`

Returns a **price estimate** for a token swap. This endpoint is intended for off chain estimation and does not include calldata or simulation metadata

**Description**

* Provides estimated input/output amounts
* Supports partial fill logic

**Example Request**

```http
POST /v1/price
x-api-key: your-api-key
Content-Type: application/json
```

**Request Body (Example)**

```json
{
  "chainID": "ethereum",
  "inputToken": "0x...",
  "outputToken": "0x...",
  "inputAmount": "100000000",
  "userAddress": "0x...",
  "outputReceiver": "0x...",
  "uniquePID": "partner-xyz"
}
```

<Note>
  For detailed information on the **request and response formats**, refer the
  section [here](/build-with-gluex/router/request-response-format)
</Note>

***

## POST /v1/quote

Returns a **price quote** along with **transaction calldata** for executing the trade onchain

**Description**

* Includes all `price` endpoint fields
* Adds transaction-specific fields such as `calldata` and `revert`
* Simulation is enabled by default (`computeEstimate: true`)

**Example Request**

```http
POST /v1/quote
x-api-key: your-api-key
Content-Type: application/json
```

**Request Body (Example)**

```json
{
  "chainID": "ethereum",
  "inputToken": "0x...",
  "outputToken": "0x...",
  "inputAmount": "100000000",
  "userAddress": "0x...",
  "outputReceiver": "0x...",
  "uniquePID": "partner-xyz",
  "computeEstimate": true
}
```

**Additional Response Fields for `quote`**

* `calldata`: ABI encoded transaction data
* `revert`: Boolean indicating if the trade would revert
* `computationUnits`: Estimated gas
* `lowBalance`: Indicates insufficient balance
* `blockNumber`: Block number for simulation context
* `simulation`: Raw trace/debug metadata

<Note>
  For detailed information on the **request and response formats**, refer the
  section [here](/build-with-gluex/router/request-response-format)
</Note>

***

These endpoints form the foundation of GlueX Router’s programmable interface, providing flexible and secure trade execution capabilities across supported [networks](/documentation/references/supported-networks)


# Fee Structure
Source: https://docs.gluex.xyz/build-with-gluex/router/fee-structure

Transparent and fair Router API fees at GlueX

At GlueX, **transparency and fairness** are core to our philosophy. Our Router API is designed not only for optimal trade execution, but also with a fee model that aligns the incentives of users, integrators, and the protocol itself

We apply a **0.03%–0.05% settlement fee** to all trades, which is shared between GlueX and the integrator. In addition, we implement a flexible **positive slippage sharing**, **partner fee configuration**, and an **surplus sharing mechanism** to ensure equitable outcomes for all parties

***

## Settlement Fees

GlueX applies a **0.03%–0.05% settlement fee** on every trade executed through the Router API. This fee is shared **50/50** between GlueX and the integrator

### Highlights

* **Low settlement fees**: Between 0.03% and 0.05% per trade
* **Minimum floor**: 0.2c per trade, split equally between GlueX (0.1c) and integrator (0.1c)
* **Revenue sharing**: Settlement fees are split equally between GlueX and the integrator
* **No hidden costs**: What you quote is what the user gets — with all fees accounted for transparently in the returned values

***

## Partner Fee Model

To help integrators monetize their services, GlueX supports a configurable **partner fee mechanism** that allows a portion of the output amount to be automatically redirected to a designated wallet

### Configuration

```json
{
  // ... other parameters
  "partnerFee": "<bps_of_output_amount>",
  "partnerAddress": "<0x_partner_wallet_address>"
}
```

* `partnerFee`: Basis points (bps) applied to the output amount, deducted before final output.
* `partnerAddress`: Wallet address where partner fees are sent.

### How It Works

Partner fees are factored into both `minOutputAmount` and `effectiveOutputAmount`. Once the trade is executed on-chain, the fee amount is automatically transferred to your `partnerAddress`.

***

## Surplus Rebates

“**Surplus**” refers to the added value when GlueX’s routing achieves **better-than-benchmark** execution (e.g., compared to next best aggregator's market rate). This can result from:

* **Optimized routing paths** across liquidity sources
* **Gas savings** via efficient transaction design
* **Proprietary internal methods**
* **Exclusive liquidity partnerships**

### Surplus Distribution

| Recipient  | Share of Surplus |
| ---------- | ---------------- |
| User       | ≥ 33%            |
| Integrator | ≤ 33%            |
| GlueX      | ≤ 33%            |

### Activation

To receive your share of surplus rewards:

```json
{
  // ... other parameters
  "activateSurplusFee": true,
  "partnerAddress": "<0x_partner_wallet_address>"
}
```

> When `activateSurplusFee` is enabled, specialized contracts handle the fair distribution of captured surplus, ensuring your `partnerAddress` receives its portion automatically.

## Positive Slippage Rebates

When trades execute better than quoted (i.e., **positive slippage exists**), GlueX ensures that this extra value is **fairly distributed** between the user, the integrator, and the protocol - in the same ratio as the surplus.

### Distribution

* **User**: Gets the primary share of the extra output.
* **Integrator**: Rewarded for brinding orderflow and optimizing experience.
* **GlueX**: Retains a portion to support protocol growth and sustainability.

This transparent, win-win-win mechanism fosters long-term trust and collaboration across all stakeholders.

***

At GlueX, our commitment is to building a **transparent, fair, and sustainable** ecosystem for all participants. For help with fee setup, surplus activation, or to explore custom fee structures and partnership opportunities , reach out via our [official Telegram](https://t.me/+_VmO_gIrNjxiZWE0).


# Overview
Source: https://docs.gluex.xyz/build-with-gluex/router/overview



The **Router API** is a versatile, high performance tool designed to enable efficient and secure onchain interactions across multiple blockchain networks. It provides developers with a robust solution to seamlessly integrate decentralized finance (DeFi) operations, including token swaps, lending, staking, yield farming and more, into the applications

## Base URL

All API endpoint requests are made relative to the following base URL:

```http
https://router.gluex.xyz
```

<Note>
  Always ensure you are using the correct version (`/v1`) in your API calls for
  the latest features and stability
</Note>

## Key Features

The GlueX Router API offers several advanced features designed to improve transaction efficiency, reduce risk and provide transparency to end users and integrators:

* **Multi Chain Support**: Seamlessly orchestrate complex DeFi operations across all [supported blockchain networks](/documentation/references/supported-networks) intelligently identifing optimal paths
* **Comprehensive DeFi Protocol Integration**: Access unparalleled liquidity and functionality through deep integrations with a vast array of DeFi protocols ensuring maximum liquidity and opportunity, including:
  * Decentralized Exchanges (eg: )
  * Lending Platforms (eg: Aave, Compound)
  * Yield Farming Protocols & Vaults (eg: )
  * Staking (eg: )
  * Bridging (eg: )
* **Optimized Transaction Execution**: Our advanced routing engine meticulously crafts transaction paths to minimize costly reversions and actively protect against Maximal Extractable Value (MEV) attacks like front running and sandwich attacks ensuring users get the best possible execution
* **Rapid Response Times**: Experience blazing fast performance with an average request round trip time of the quote is approximately 500 milliseconds, enabling highly responsive applications
* **Positive Slippage Rewards**: Any positive slippage (ie, receiving more output than initially quoted) is intelligently and transparently distributed among the end users, integrating partner and us!
* **Dynamic, Zero Routing Fees**: GlueX charges absolutely zero direct routing fees to the end user. Our revenue model is based on a small, transparent share of the positive slippage when it occurs, ensuring there are no hidden costs or charges. This aligns our incentives with providing the most optimal routes

<CardGroup cols={2}>
  <Card title="Try Out Now" icon="play" href="/api-reference/router-api/post-price">
    Experience DeFi at it's finest. Test the Router API instantly directly in
    your browser
  </Card>

  <Card title="Explore Guides" icon="rocket" href="/guides">
    Dive into step by step guides and best practices for integrating the Router
    API
  </Card>
</CardGroup>

## Additional Documentation

To help you get the most out of the GlueX Router API, refer to the following dedicated sections for detailed information and advanced guidance:

* [How to use API endpoints?](api-endpoints)
* [What are the **Request and Response Formats**?](request-response-format)
* [What advanced features do we provide?](advanced-features)
* [Do you want to charge any Fee?](fee-structure)
* [How many times can you call our API?](api-tiers-limits)
* [All set for getting started!](getting-started)


# Request and Response Format
Source: https://docs.gluex.xyz/build-with-gluex/router/request-response-format

This document outlines the structure of requests and responses for Router (common fields and endpoint specific fields)

This document provides a comprehensive guide to the structures used when interacting with the Router API. Understanding these formats is crucial for correctly constructing your requests and parsing the API responses

## Request Parameters

The following parameters may be included in the request payload for `/v1/price` and `/v1/quote` endpoints

| Name              | Type           | Required    | Default Value | Description                                          |
| ----------------- | -------------- | ----------- | ------------- | ---------------------------------------------------- |
| `chainID`         | string         | Conditional |               | Identifier for the target chain (eg: `ethereum`)     |
| `networkID`       | string/integer | Conditional |               | Numerical chain ID (eg: `1` for Ethereum)            |
| `inputToken`      | string         | ✅           |               | ERC20 token address to be sold                       |
| `outputToken`     | string         | ✅           |               | ERC20 token address to be bought                     |
| `inputAmount`     | string/integer | Conditional |               | Amount of input token (used for SELL orders)         |
| `outputAmount`    | string/integer | Conditional |               | Desired amount of output token (used for BUY orders) |
| `orderType`       | string         | Conditional |               | Type of order: `BUY` or `SELL`                       |
| `userAddress`     | string         | ✅           |               | Initiator's wallet address                           |
| `outputReceiver`  | string         | ✅           |               | Address to receive the output token                  |
| `uniquePID`       | string         | ✅           |               | Partner ID for analytics and attribution             |
| `computeEstimate` | boolean        | Optional    | true          | Enable simulation                                    |
| `computeStable`   | boolean        | Optional    | false         | Include USD value metadata in response               |
| `surgeProtection` | boolean        | Optional    | false         | Enable or disable Surge Protection                   |
| `isPartialFill`   | boolean        | Optional    | false         | Allow partial fill swaps                             |
| `isPermit2`       | boolean        | Optional    | false         | Use Permit2 for allowance approvals                  |
| `fastMode`        | boolean        | Optional    | false         | Enable fast response time for the requests           |
| `slippage`        | string/integer | Optional    |               | Maximum slippage allowed (in basis points)           |
| `partnerFee`      | string/integer | Optional    | 0             | Fee in bps applied to output                         |
| `partnerAddress`  | string         | Conditional |               | EOA to receive partner fee and surplus               |
| `modulesFilter`   | array          | Optional    | \[]           | Restrict routing to specified liquidity modules      |
| `modulesDisabled` | array          | Optional    | \[]           | Restrict routing via specified liquidity modules     |

## Common Response Fields

The following fields are returned in both `/v1/price` and `/v1/quote` responses.

| Field                   | Type    | Description                                          |
| ----------------------- | ------- | ---------------------------------------------------- |
| `inputToken`            | string  | ERC20 address of input token                         |
| `outputToken`           | string  | ERC20 address of output token                        |
| `feeToken`              | string  | Token used to pay any applicable fees                |
| `inputSender`           | string  | Address initiating the trade                         |
| `outputReceiver`        | string  | Address receiving the output                         |
| `inputAmount`           | string  | Original input amount                                |
| `outputAmount`          | string  | Expected output amount                               |
| `partnerFee`            | string  | Amount of fee allocated to partner                   |
| `routingFee`            | string  | GlueX's routing fee (typically zero)                 |
| `effectiveInputAmount`  | string  | Actual used input in the swap (for partial fills)    |
| `effectiveOutputAmount` | string  | Actual received output after fees and routing        |
| `minOutputAmount`       | string  | Slippage-protected minimum output                    |
| `liquidityModules`      | array   | Liquidity sources/modules used                       |
| `isNativeTokenInput`    | boolean | Indicates if native token (eg: ETH) was used         |
| `value`                 | string  | Value (in wei) sent with transaction (if applicable) |

## Endpoint Specific Response Fields

### Fields for `/v1/price`

| Field        | Type    | Description                                   |
| ------------ | ------- | --------------------------------------------- |
| `surgeValue` | integer | Projected reverse loss estimate in percentage |

### Fields for `/v1/quote`

| Field              | Type    | Description                                    |
| ------------------ | ------- | ---------------------------------------------- |
| `calldata`         | string  | ABI encoded transaction data                   |
| `revert`           | boolean | Indicates if trade would revert onchain        |
| `computationUnits` | integer | Estimated gas cost                             |
| `lowBalance`       | boolean | True if user balance is insufficient           |
| `blockNumber`      | integer | Block number used during simulation            |
| `simulation`       | object  | Detailed trace/debug object for advanced usage |


# Configuring the Widget
Source: https://docs.gluex.xyz/build-with-gluex/widget/configuration



The widget supports a range of configuration options, allowing you to:

* Preselect default chain
* Preselect the source and destination token
* Preselect the appearance
* Prefill the amount of the source token
* Prefill the amount of the destination token
* Prefill the slippage configuration
* Allow or deny surplus feature
* Allow or deny specific liquidity sources
* Allow or deny specific chains
* Allow or deny specific tokens
* Specify the receiving address
* Specify the type of order - `BUY` or `SELL`
* Specify the partner fee

These extensive configuration options collectively enable precise control over the widget's behavior and improve the user experience by adjusting it to specific needs and preferences, creating a highly optimized, branded and intuitive experience. This flexibility makes the widget a powerful and adaptable component that can seamlessly integrate into any decentralized application architecture while maintaining consistency with your brand and user experience requirements.

## SDK configuration

The GlueX widget is built on top of our robust SDK, utilizing its core functionality to provide seamless integration and optimal performance. The `sdk` option allows you to configure various aspects of the underlying SDK directly within the widget configuration, ensuring that all SDK-level settings align with your application requirements.

```typescript
const config = {
  sdk: {
    // .. sdk configuration
  },
};
```

The SDK configuration interface provides comprehensive control over core functionality:

```typescript
interface SDKConfig {
  userId: string; // the user ID of the user attached with each request for tracking
  referrer: string; // the referrer address of the user

  rpcUrls: RPCUrls;
  chains: Chain[];
  debug: boolean;

  fees: {
    partner?: number;
    payoutAddress?: string;
    surplusFee?: boolean;
  };
}
```

### User

The `userId` field allows you to attach a unique user identifier to each request, enabling comprehensive tracking and analytics capabilities. This identifier helps you monitor user behavior, analyze transaction patterns, and provide personalized experiences. The user ID should be a consistent, unique string that identifies individual users across sessions

```typescript
const config = {
  sdk: {
    userId: "user-12345",
  },
};
```

**Best Practices**

*

- Use consistent identifiers that persist across user sessions
- Ensure user IDs are unique and don't contain sensitive information
- Consider using UUIDs or hashed values for enhanced privacy
- Implement proper user consent mechanisms for tracking where required by regulations

### Referrer

The referrer field specifies the referrer address of the user for tracking and attribution purposes. This is particularly important for affiliate programs, partner integrations and revenue sharing models. The referrer address should be a valid address

```typescript
const config = {
  sdk: {
    referrer: "0x12345...678",
  },
};
```

<Info>
  Referral fee system is coming soon with advanced attribution and reward
  mechanisms
</Info>

**Referrer Implementation Guidelines:**

* Ensure the referrer address is properly formatted and validated
* Use consistent referrer addresses for accurate attribution tracking
* Consider implementing dynamic referrer assignment based on user acquisition channels
* Document referrer relationships for transparent revenue sharing

### RPC endpoints

Configure custom RPC endpoints for different blockchain networks to ensure reliable connectivity, optimal performance and reduced dependency on public infrastructure. Custom RPC configurations help maintain consistent service quality and avoid rate limiting issues that commonly affect public endpoints

```typescript
type RPCUrls = Partial<Record<Chain["identifier"], string[]>>;

const config = {
  sdk: {
    rpcUrls: {
      ethereum: ["https://mainnet.infura.io/v3/<YOUR-PROJECT-ID>"],
      polygon: ["https://polygon-mainnet.infura.io/v3/<YOUR-PROJECT-ID>"],
    },
  },
};
```

<Note>
  For production deployments, always use your own authenticated RPC provider
  (such as Alchemy, Infura, QuickNode, or Ankr). If custom RPC endpoints are not
  specified, the widget defaults to public RPC endpoints, which may experience
  rate limiting and cause issues like incorrect balance displays, failed
  transactions, or degraded performance during high traffic periods
</Note>

**Best Practices**

\*\*

* **Redundancy**: Configure multiple RPC endpoints per chain for failover protection
* **Monitoring**: Implement RPC endpoint health monitoring and automatic failover
* **Authentication**: Use authenticated endpoints with proper API key management
* **Geographic Distribution**: Consider RPC provider locations relative to your user base for optimal latency

### Explorer URLs

.. TBD ..

### Partner Fees

The partner fee system enables revenue generation through transaction based commissions. The `fees.partner` parameter allows you to configure partner fees for each transaction processed through the widget. The `partner` field expects a value in basis points (bps), where 100 bps equals 1% of the transaction volume. The maximum allowed fee is 10% (1000 bps) to ensure reasonable cost structures for end users

```typescript
const config = {
  sdk: {
    fees: {
      partner: 100, // 1% partner fee
      payoutAddress: "0xabc...xyz", // Address to receive accumulated fees
    },
  },
};
```

<Note>
  To ensure partner fees are correctly collected and distributed, you must
  specify the `payoutAddress` in your configuration. This address will receive
  the accumulated fees for each transaction. Alternatively, you can configure
  this address via the [developer portal](https://portal.gluex.xyz) for
  centralized management across multiple integrations
</Note>

**Partner Fee Implementation Details:**

* **Fee Calculation**: Fees are calculated as a percentage of the total transaction volume
* **Fee Collection**: Fees are automatically deducted during the swap process and distributed to the specified payout address within each transaction
* **Transparency**: Clearly communicate fee structures to end users for transparency and trust

## Form Values

The widget provides comprehensive and flexible options for preconfiguring default values and dynamically updating parameters for chains, tokens, amounts, and addresses. This functionality makes it easy to set up and maintain desired swap parameters, creating seamless user experiences that can adapt to changing requirements and user preferences

### Configuration

The most straightforward approach is to preconfigure values directly in the widget configuration object during initialization. This method ensures consistent default values across all widget instances and provides a stable foundation for your application's swap functionality

```typescript
const config = {
  // Network configuration
  // set source chain
  fromChain: 1,
  // set destination chain
  toChain: 1,

  // Token configuration
  // set source token
  fromToken: "0xabc...xyz",
  // set source token
  toToken: "0x123...890",

  // Amount configuration
  // set source token amount
  fromAmount: 1000000,

  // Destination configuration
  // set the destination wallet address
  toAddress: {
    name: "My Vault",
    address: "0x123...678",
  },
};
```

<Note>
  The widget currently supports only swap operations. Therefore, you should
  specify either fromChain or toChain, or set both to the same value
</Note>

**Configuration Value Types and Validation:**

* **Chain IDs**: Use standard chain identifiers (1 for Ethereum, 137 for Polygon, etc.)
* **Token Addresses**: Must be valid ERC20 contract addresses with proper checksum formatting
* **Amounts**: Specify in token's native decimal format (eg: for USDC with 6 decimals, 1000000 = 1 USDC)
* **Addresses**: All addresses must be valid Ethereum format with proper checksum encoding

#### Configuration Updates

The widget supports dynamic configuration updates after initialization, enabling real-time form value changes based on user interactions, market conditions or application state changes. This functionality is particularly valuable for applications using state management libraries like Redux, Zustand or React Context, allowing seamless integration with existing application architectures

**FormUpdateKey Mechanism**

The `formUpdateKey` is a critical component of the state management update system that triggers form re-rendering when configuration changes occur:

```typescript
interface WidgetConfiguration {
  // ... other configuration options

  /**
   * Key that triggers form updates when changed
   * Should be updated whenever you want to apply config changes to the form
   * Can be any string value - commonly used patterns:
   * - Timestamp: Date.now().toString()
   * - UUID: crypto.randomUUID()
   * - Incremental counter: (counter++).toString()
   * - Hash of changed values: hashFunction(changedConfig)
   */
  formUpdateKey?: string;
}
```

**Implementation Patterns:**

<AccordionGroup>
  <Accordion title="Redux Toolkit">
    ```typescript
    import { useSelector, useDispatch } from "react-redux";
    import { updateSwapConfig, incrementUpdateKey } from "./swapSlice";

    const WidgetWithRedux = () => {
      const dispatch = useDispatch();
      const { config, updateKey } = useSelector((state) => state.swap);

      const handleUpdateFromChain = (chainId: number) => {
        // Update only the specific values you want to change
        dispatch(
          updateSwapConfig({
            fromChain: chainId,
            // Optionally clear related values when chain changes
            fromToken: undefined,
            fromAmount: undefined,
          })
        );
        dispatch(incrementUpdateKey()); // Trigger widget update
      };

      const handleUpdateTokenPair = (fromToken: string, toToken: string) => {
        dispatch(
          updateSwapConfig({
            fromToken,
            toToken,
            // Clear amounts when tokens change to prevent confusion
            fromAmount: undefined,
          })
        );
        dispatch(incrementUpdateKey());
      };

      const handlePresetTrade = (preset: "eth-to-usdc" | "usdc-to-dai") => {
        const presets = {
          "eth-to-usdc": {
            fromChain: 1,
            toChain: 1,
            fromToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
            toToken: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e", // USDC
            fromAmount: 1,
          },
          "usdc-to-dai": {
            fromChain: 1,
            toChain: 1,
            fromToken: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e", // USDC
            toToken: "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
            fromAmount: 1000,
          },
        };

        dispatch(updateSwapConfig(presets[preset]));
        dispatch(incrementUpdateKey());
      };

      return (
        <>
          <GlueXWidget
            config={{
              ...config,
              formUpdateKey: updateKey,
            }}
          />

          <div className="controls">
            <button onClick={() => handleUpdateFromChain(1)}>Ethereum</button>
            <button onClick={() => handleUpdateFromChain(137)}>Polygon</button>
            <button onClick={() => handlePresetTrade("eth-to-usdc")}>
              ETH → USDC
            </button>
            <button onClick={() => handlePresetTrade("usdc-to-dai")}>
              USDC → DAI
            </button>
          </div>
        </>
      );
    };

    // Redux slice with enhanced state management
    const swapSlice = createSlice({
      name: "swap",
      initialState: {
        config: {
          theme: "dark",
          buildUrl: true,
          slippage: 0.5,
        },
        updateKey: "0",
        history: [], // Track configuration changes for debugging
      },
      reducers: {
        updateSwapConfig: (state, action) => {
          state.history.push({
            timestamp: Date.now(),
            previous: { ...state.config },
            changes: action.payload,
          });
          state.config = { ...state.config, ...action.payload };
        },
        incrementUpdateKey: (state) => {
          state.updateKey = (parseInt(state.updateKey) + 1).toString();
        },
        resetConfig: (state) => {
          state.config = {
            theme: "dark",
            buildUrl: true,
            slippage: 0.5,
          };
          state.updateKey = Date.now().toString();
        },
      },
    });
    ```
  </Accordion>

  <Accordion title="Zustand">
    ```typescript
    import { create } from "zustand";
    import { subscribeWithSelector } from "zustand/middleware";

    interface SwapStore {
      config: WidgetConfig;
      updateKey: string;
      isUpdating: boolean;
      lastUpdate: number;

      // Actions
      updateConfig: (updates: Partial<WidgetConfig>) => void;
      resetConfig: () => void;
      setPreset: (presetName: string) => void;

      // Advanced features
      batchUpdate: (updates: Partial<WidgetConfig>[]) => void;
      scheduleUpdate: (updates: Partial<WidgetConfig>, delay: number) => void;
    }

    const useSwapStore = create<SwapStore>()(
      subscribeWithSelector((set, get) => ({
        config: {
          theme: "dark",
          buildUrl: true,
          slippage: 0.5,
        },
        updateKey: "0",
        isUpdating: false,
        lastUpdate: Date.now(),

        updateConfig: (updates) =>
          set((state) => ({
            config: { ...state.config, ...updates },
            updateKey: Date.now().toString(),
            lastUpdate: Date.now(),
            isUpdating: false,
          })),

        resetConfig: () =>
          set({
            config: {
              theme: "dark",
              buildUrl: true,
              slippage: 0.5,
            },
            updateKey: Date.now().toString(),
            lastUpdate: Date.now(),
            isUpdating: false,
          }),

        setPreset: (presetName) => {
          const presets: Record<string, Partial<WidgetConfig>> = {
            "ethereum-usdc": {
              fromChain: 1,
              toChain: 1,
              fromToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
              toToken: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e",
            },
            "cross-chain-usdc": {
              fromChain: 1,
              toChain: 137,
              fromToken: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e",
              toToken: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
            },
          };

          const preset = presets[presetName];
          if (preset) {
            get().updateConfig(preset);
          }
        },

        batchUpdate: (updates) => {
          const mergedUpdate = updates.reduce(
            (acc, update) => ({ ...acc, ...update }),
            {}
          );
          get().updateConfig(mergedUpdate);
        },

        scheduleUpdate: (updates, delay) => {
          set({ isUpdating: true });
          setTimeout(() => {
            get().updateConfig(updates);
          }, delay);
        },
      }))
    );

    // Subscribe to config changes for debugging
    useSwapStore.subscribe(
      (state) => state.config,
      (config, previousConfig) => {
        console.log("Config updated:", {
          previous: previousConfig,
          current: config,
        });
      }
    );

    const WidgetWithZustand = () => {
      const { config, updateKey, updateConfig, setPreset, isUpdating } =
        useSwapStore();

      const handleQuickUpdate = () => {
        updateConfig({
          fromChain: 1,
          toChain: 137,
          fromAmount: 1000000,
        });
      };

      return (
        <div>
          <GlueXWidget
            config={{
              ...config,
              formUpdateKey: updateKey,
            }}
          />

          <div className="controls">
            <button onClick={handleQuickUpdate} disabled={isUpdating}>
              Quick Cross-chain Setup
            </button>
            <button onClick={() => setPreset("ethereum-usdc")}>
              ETH → USDC Preset
            </button>
            <button onClick={() => setPreset("cross-chain-usdc")}>
              Cross-chain USDC
            </button>
          </div>
        </div>
      );
    };
    ```
  </Accordion>

  <Accordion title="React Context">
    ```typescript
    import { createContext, useContext, useReducer, useCallback } from "react";

    interface SwapState {
      config: WidgetConfig;
      updateKey: string;
      loading: boolean;
      error: string | null;
      history: Array<{
        timestamp: number;
        action: string;
        config: WidgetConfig;
      }>;
    }

    type SwapAction =
      | { type: "UPDATE_CONFIG"; payload: Partial<WidgetConfig> }
      | { type: "RESET_CONFIG" }
      | { type: "SET_LOADING"; payload: boolean }
      | { type: "SET_ERROR"; payload: string | null }
      | { type: "CLEAR_HISTORY" };

    const swapReducer = (state: SwapState, action: SwapAction): SwapState => {
      switch (action.type) {
        case "UPDATE_CONFIG":
          const newConfig = { ...state.config, ...action.payload };
          return {
            ...state,
            config: newConfig,
            updateKey: Date.now().toString(),
            error: null,
            history: [
              ...state.history.slice(-9), // Keep last 10 entries
              {
                timestamp: Date.now(),
                action: "UPDATE_CONFIG",
                config: newConfig,
              },
            ],
          };

        case "RESET_CONFIG":
          const resetConfig = {
            theme: "dark",
            buildUrl: true,
            slippage: 0.5,
          };
          return {
            ...state,
            config: resetConfig,
            updateKey: Date.now().toString(),
            error: null,
            history: [
              ...state.history.slice(-9),
              {
                timestamp: Date.now(),
                action: "RESET_CONFIG",
                config: resetConfig,
              },
            ],
          };

        case "SET_LOADING":
          return { ...state, loading: action.payload };

        case "SET_ERROR":
          return { ...state, error: action.payload, loading: false };

        case "CLEAR_HISTORY":
          return { ...state, history: [] };

        default:
          return state;
      }
    };

    const SwapContext = createContext<{
      state: SwapState;
      dispatch: React.Dispatch<SwapAction>;
      updateConfig: (updates: Partial<WidgetConfig>) => void;
      resetConfig: () => void;
    } | null>(null);

    export const SwapProvider: React.FC<{ children: React.ReactNode }> = ({
      children,
    }) => {
      const [state, dispatch] = useReducer(swapReducer, {
        config: {
          theme: "dark",
          buildUrl: true,
          slippage: 0.5,
        },
        updateKey: "0",
        loading: false,
        error: null,
        history: [],
      });

      const updateConfig = useCallback((updates: Partial<WidgetConfig>) => {
        dispatch({ type: "SET_LOADING", payload: true });

        // Validate updates before applying
        try {
          // Add validation logic here
          if (updates.fromAmount && updates.fromAmount < 0) {
            throw new Error("Amount cannot be negative");
          }

          dispatch({ type: "UPDATE_CONFIG", payload: updates });
        } catch (error) {
          dispatch({ type: "SET_ERROR", payload: error.message });
        } finally {
          dispatch({ type: "SET_LOADING", payload: false });
        }
      }, []);

      const resetConfig = useCallback(() => {
        dispatch({ type: "RESET_CONFIG" });
      }, []);

      return (
        <SwapContext.Provider
          value={{ state, dispatch, updateConfig, resetConfig }}
        >
          {children}
        </SwapContext.Provider>
      );
    };

    const WidgetWithContext = () => {
      const context = useContext(SwapContext);
      if (!context) throw new Error("Must be used within SwapProvider");

      const { state, updateConfig, resetConfig } = context;

      const handleUpdateConfig = (updates: Partial<WidgetConfig>) => {
        updateConfig(updates);
      };

      const handleChainSwitch = (fromChain: number, toChain: number) => {
        updateConfig({
          fromChain,
          toChain,
          // Clear token selection when chains change
          fromToken: undefined,
          toToken: undefined,
        });
      };

      return (
        <div>
          <GlueXWidget
            config={{
              ...state.config,
              formUpdateKey: state.updateKey,
            }}
          />

          <div className="controls">
            <button onClick={() => handleChainSwitch(1, 137)}>ETH → Polygon</button>
            <button onClick={() => handleChainSwitch(137, 1)}>Polygon → ETH</button>
            <button onClick={resetConfig}>Reset Configuration</button>

            {state.error && <div className="error">Error: {state.error}</div>}

            {state.loading && (
              <div className="loading">Updating configuration...</div>
            )}
          </div>

          {/* Debug panel - remove in production */}
          <details>
            <summary>Configuration History ({state.history.length})</summary>
            <pre>{JSON.stringify(state.history, null, 2)}</pre>
          </details>
        </div>
      );
    };
    ```
  </Accordion>
</AccordionGroup>

### URL search params

To initialize form values in the widget using URL search parameters, you must ensure that `buildUrl` is set to `true` in the widget configuration. This feature enables deep linking, shareable swap configurations, and easy integration with web analytics and tracking systems

```typescript
const config = {
  // instruct the widget to use and build url search params
  buildUrl: true,
};
```

**Parameter Structure**

The widget accepts the following URL search parameters with comprehensive support for all configurable values:

```
https://<base-url>?fromAmount=<amount>&fromChain=<chainId>&fromToken=<tokenAddress>&toAddress=<destinationAddress>&toChain=<chainId>&toToken=<tokenAddress>
```

**Parameter Reference:**

| Parameter    | Type   | Description                                   | Example            |
| ------------ | ------ | --------------------------------------------- | ------------------ |
| `fromAmount` | string | Source token amount in token's decimal format | `1000000` (1 USDC) |
| `fromChain`  | string | Source blockchain ID                          | `1` (Ethereum)     |
| `fromToken`  | string | Source token contract address                 | `0xA0b86a33...`    |
| `toAddress`  | string | Destination wallet address                    | `0x742d35Cc...`    |
| `toChain`    | string | Destination blockchain ID                     | `137` (Polygon)    |
| `toToken`    | string | Destination token contract address            | `0x2791Bca1...`    |

**Best Practices**

When constructing URLs programmatically, ensure proper encoding and validation:

```typescript
const buildSwapUrl = (baseUrl: string, params: SwapParams) => {
  const urlParams = new URLSearchParams();

  // Add parameters with proper validation
  if (params.fromAmount && params.fromAmount > 0) {
    urlParams.set("fromAmount", params.fromAmount.toString());
  }

  if (params.fromChain) {
    urlParams.set("fromChain", params.fromChain.toString());
  }

  if (params.fromToken && isValidAddress(params.fromToken)) {
    urlParams.set("fromToken", params.fromToken);
  }

  if (params.toAddress && isValidAddress(params.toAddress)) {
    urlParams.set("toAddress", params.toAddress);
  }

  if (params.toChain) {
    urlParams.set("toChain", params.toChain.toString());
  }

  if (params.toToken && isValidAddress(params.toToken)) {
    urlParams.set("toToken", params.toToken);
  }

  if (params.slippage && params.slippage > 0 && params.slippage <= 50) {
    urlParams.set("slippage", params.slippage.toString());
  }

  if (params.orderType && ["BUY", "SELL"].includes(params.orderType)) {
    urlParams.set("orderType", params.orderType);
  }

  return `${baseUrl}?${urlParams.toString()}`;
};

// Helper function for address validation
const isValidAddress = (address: string): boolean => {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
};

// Example usage
const swapUrl = buildSwapUrl("https://your-domain.com/swap", {
  fromAmount: 1000000,
  fromChain: 1,
  fromToken: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e",
  toAddress: "0x742d35Cc6634C0532925a3b8d5c01B4FBf1234567",
  toChain: 137,
  toToken: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
  slippage: 0.5,
  orderType: "SELL",
});
```

**URL Parameter Behavior**

URL parameters only affect the widget's initialization state. Dynamically changing search parameters in the URL without triggering a page reload will not update the widget's form values. For runtime updates after initialization, use the Form Reference method or Configuration Updates approach described in other sections

<Note>
  Configuration values take precedence over URL search parameters. If you want
  URL parameters to control initial form values, ensure that `fromAmount`,
  `fromChain`, `fromToken`, `toAddress`, `toChain`, `toToken`, and other
  relevant parameters are not defined in the widget configuration object. If
  both configuration values and URL parameters are present, the widget will
  overwrite URL parameters with configuration values and update the URL
  accordingly
</Note>

**Advanced URL Management:**

* **State Synchronization**: Implement bidirectional sync between URL params and application state
* **Parameter Validation**: Validate all URL parameters before applying them to prevent invalid states
* **Fallback Values**: Provide sensible defaults for missing or invalid URL parameters
* **SEO Optimization**: Use descriptive URL structures for better search engine indexing
* **Analytics Integration**: Track URL parameter usage for user behavior analysis

### Form Ref

The Form Reference method provides the most flexibility and granular control for programmatic manipulation of widget form values after initialization. This approach is ideal for building custom interfaces, creating advanced user experiences, or responding to complex user interactions and external system events

```typescript Example.tsx
export const WidgetPage = () => {
  const formRef = useRef<FormState>(null);

  const handleSetEthereum = () => {
    // Set source chain to Ethereum with URL update
    formRef.current?.setFieldValue("fromChain", 1, {
      setUrlSearchParam: true,
    });
  };

  const handleSetPolygon = () => {
    // Set destination chain to Polygon without URL update
    formRef.current?.setFieldValue("toChain", 137, {
      setUrlSearchParam: false,
    });
  };

  <div>
    <GlueXWidget config={/*..*/} formRef={formRef} />

    <div className="controls">
      <button onClick={handleSetEthereum} type="button">
        Set Source to Ethereum
      </button>
      <button onClick={handleSetPolygon} type="button">
        Set Destination to Polygon
      </button>
    </div>
  </div>;
};
```

## Allow and Deny Lists

The widget provides comprehensive `allow` and `deny` configuration options to give you precise control over which chains, tokens and liquidity sources can be utilized within your application. These filtering mechanisms enable you to create curated experiences that align with your business requirements, regulatory constraints, and user safety considerations

### Chains

Chain filtering allows you to restrict which blockchain networks are available to users, helping you focus on supported networks

```typescript
const config = {
  chains: {
    // Deny specific chains from being shown in the chains list
    deny: [1, 56], // Disable Ethereum and BSC

    // Allow only specific chains
    allow: [137, 42161, 10], // Allow only Polygon, Arbitrum, and Optimism
  },
};
```

### Tokens

Token filtering provides granular control over which tokens are available for trading, enabling you to create curated token lists that match your platform's focus

```typescript
const config = {
  tokens: {
    // Deny specific tokens (blacklist approach)
    deny: [
      {
        address: "0x...",
        chainId: 1,
      },
      {
        address: "0x...",
        chainId: 137,
      },
    ],

    // Allow only specific tokens (whitelist approach)
    allow: [
      {
        address: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e",
        symbol: "USDC",
        decimals: 6,
        chainId: 1,
        name: "USD Coin",
        logoURI:
          "https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png",
      },
      {
        address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
        symbol: "USDC",
        decimals: 6,
        chainId: 137,
        name: "USD Coin (PoS)",
        logoURI:
          "https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png",
      },
    ],
  },
};
```

#### Featured Tokens

Create curated lists of featured tokens to guide users toward high quality, liquid trading pairs and improve the overall trading experience

```typescript
const config = {
  tokens: {
    featured: [
      {
        address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        symbol: "WETH",
        decimals: 18,
        chainId: 1,
        name: "Wrapped Ether",
        logoURI:
          "https://assets.coingecko.com/coins/images/2518/thumb/weth.png",
      },
      {
        address: "0xA0b86a33E6441C8FFa4c02bae5a0Dd0D8e87fb8e",
        symbol: "USDC",
        decimals: 6,
        chainId: 1,
        name: "USD Coin",
        logoURI:
          "https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png",
      },
      {
        address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        symbol: "DAI",
        decimals: 18,
        chainId: 1,
        name: "Dai Stablecoin",
        logoURI:
          "https://assets.coingecko.com/coins/images/9956/thumb/Badge_Dai.png",
      },
    ],
  },
};
```

### Liquidity Sources

Control which liquidity sources and protocols are utilized for trade execution using the `modulesFilter` parameter, enabling you to optimize for specific characteristics like gas efficiency, slippage, or execution speed

```typescript
const config = {
  modulesFilter: ["module_1", "module_2"],
};
```

In this example, the router would only consider paths involving module\_1 and module\_2 liquidity, even if other more optimal routes existed on different protocols

<Note>
  To get the most current list of supported modules and their identifiers, you
  can visit the [liquidity modules documentation
  page](/documentation/get-started/introduction) or check the [live module
  registry](https://router.gluex.xyz/liquidity)
</Note>

**Liquidity Source Management Best Practices:**

* **Diversification**: Use multiple sources to ensure route availability and competitive pricing
* **Regular Updates**: Keep module lists updated as new protocols launch and others become deprecated
* **Reliability Focus**: Prioritize well-established protocols with proven track records

## Destination address

Developers can use the `toAddress` option to configure the destination address. The address property is required, while the name and logoURI properties are optional

```typescript
const config = {
  toAddress: {
    name: "Vault Deposit",
    address: "0xMy...VaultAddress",
    logoURI: "https://vault.address/image.svg",
  },
};
```


# Customization and Whitelabel
Source: https://docs.gluex.xyz/build-with-gluex/widget/customizations



The GlueX Widget offers comprehensive customization options to match the application's design and functionality requirements. The widget's layout stays consistent, but you can modify colors, fonts, styles, disable or hide parts of the UI and more

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and integrate the widget
</Note>

```typescript
interface WidgetThemeConfiguration = {
  // customize individual components
  components: WidgetCustomComponents;

  // sets the appearance - ("light" | "dark" | "auto")
  appearance: Appearance;
  // tweak the theme objects such as palette, shape, typography, components, container, colors, fonts and border-radius
  theme: WidgetTheme;

  // disables parts of the widget
  disabled: DisabledUIType[];
  // hides parts of the widget
  hidden: HiddenUIType[];
  // makes parts of the widget as required
  required: RequiredUIType[];
}
```

## UI Customization

### Appearance

Controls the widget's overall color scheme, so it can adapt to your app's light or dark mode or follow the user's system preference automatically. Use this to ensure visual consistency and reduce "mode flicker" when users switch themes.

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/appearance.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=3f416a9f2fba96dbd2098becdf18029e" data-path="images/products/widget/video/appearance.webm" />

| Property     | Default  | Allowed Values          | Notes                                   |
| ------------ | -------- | ----------------------- | --------------------------------------- |
| `appearance` | `"auto"` | `light`, `dark`, `auto` | `auto` will match the user's OS setting |

```ts
const config = {
  appearance: "dark",
};
```

### Elements

Fine tune which parts of the interface your users see or interact with. Disable input fields to guide user flows, hide non essential widgets for a cleaner look or mark critical fields as required to ensure data collection

#### Disabled

Grey out and prevent interaction with specific UI elements

| Property | Type      | Default | Notes                                        |
| -------- | --------- | ------- | -------------------------------------------- |
| disabled | string\[] | \[]     | List of element keys to disable (greyed out) |

```ts
const config = {
  disabled: ["fromAmount", "fromToken"],
};
```

#### Hidden

Completely remove elements from the UI

| Property | Type      | Default | Notes                                           |
| -------- | --------- | ------- | ----------------------------------------------- |
| hidden   | string\[] | \[]     | List of element keys to remove entirely from UI |

```ts
const config = {
  hidden: ["poweredBy", "language"],
};
```

Available keys:

```ts
export enum HiddenUI {
  Header = "header",
  Appearance = "appearance",
  DrawerCloseButton = "drawerCloseButton",
  History = "history",
  Language = "language",
  PoweredBy = "poweredBy",
  ToAddress = "toAddress",
  ToToken = "toToken",
  WalletMenu = "walletMenu",
  IntegratorStepDetails = "integratorStepDetails",
  ReverseTokensButton = "reverseTokensButton",
  RouteTokenDescription = "routeTokenDescription",
  WalletHeader = "walletHeader",
  ModuleEnableSettings = "moduleEnableSettings",
  ModuleDisableSettings = "moduleDisableSettings",
  HeaderChainSelect = "headerChainSelect",
  SettingsButton = "settingsButton",
  TokenCategories = "tokenCategories",
}

export type HiddenUIType = `${HiddenUI}`
```

#### Required

Ensure users fill out crucial fields before proceeding

| Property | Type      | Default | Notes                                    |
| -------- | --------- | ------- | ---------------------------------------- |
| required | string\[] | \[]     | List of element keys that must be filled |

```ts
const config = {
  required: ["toAddress"],
};
```

### Style Overrides

Override styles of built-in components without replacing them. This is useful for quick visual tweaks like borders, radii, and spacing while keeping the default behavior.

```ts
export interface WidgetOverrides {
  selectTokenCard?: SelectTokenCardStyle;
  inputBox?: SelectTokenCardHeaderStyle;
  reciveTokenDetails?: ReciveTokenDetails;
  amountSlider?: AmountSliderStyle;
  percentageButtons?: PercentageButtonsStyle;
  settingsButton?: SettingsButtonStyle;
  reviewButton?: ReviewButtonOverride;
}
```

Usage:

```ts
const config = {
  // ...other widget config
  override: {
    inputBox: {
      style: {
        // add your styles here
      },
    },
    selectTokenCard: {
      style: {
        // add your styles here
      },
    },
    reviewButton: {
      text: "",
      style: {
        // add your button styles here
      },
    },
  },
};
```

Examples of when to use overrides vs components:

* Use overrides for simple visual changes (borders, spacing, colors)
* Use custom components when changing structure, layout, or behavior

## Theme Customizations

### Layout

Override the outer container's dimensions and spacing to fit any layout fixed width/sidebar, full-page modal or embedded card. Control styling factors like height, max-height, padding, box shadow and more for a perfect visual fit

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/layout.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=48d701163d92e58bd92df6bbc7c88745" data-path="images/products/widget/video/layout.webm" />

| Property        | Type   | Default | Notes                          |
| --------------- | ------ | ------- | ------------------------------ |
| theme.container | object | —       | CSS style object for container |

```ts
const config = {
  theme: {
    container: {
      width: "400px",
      height: "600px",
      maxHeight: "800px",
      boxShadow: "0px 8px 32px rgba(0, 0, 0, 0.08)",
      padding: "16px",
    },
  },
};
```

### Shape

Adjust corner radii globally across cards, buttons and panels either a single radius for everything or separate values for primary (cards) and secondary (buttons) elements

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/shape.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=5f047b5089272918b7f69f43b0b0c6cb" data-path="images/products/widget/video/shape.webm" />

| Property                          | Type   | Default | Notes                      |
| --------------------------------- | ------ | ------- | -------------------------- |
| theme.shape.borderRadius          | number | —       | Base radius in pixels      |
| theme.shape.borderRadiusSecondary | number | —       | Secondary (buttons) radius |

```ts
const config = {
  theme: {
    shape: {
      borderRadius: 12,
      borderRadiusSecondary: 16,
    },
  },
};
```

### Typography and Fonts

Define the widget's typographic scale font family, base font size and weight variants for regular, medium and bold text. Use your brand's font stack for full design cohesion

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/typography.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=066d90c4f00ddcdb3b72c0c53032b86b" data-path="images/products/widget/video/typography.webm" />

| Property                           | Type   | Default | Notes                           |
| ---------------------------------- | ------ | ------- | ------------------------------- |
| theme.typography.fontFamily        | string | —       | CSS font-family string          |
| theme.typography.fontSize          | number | —       | Base font size in pixels        |
| theme.typography.fontWeightRegular | number | —       | Numeric weight for regular text |
| theme.typography.fontWeightMedium  | number | —       | Numeric weight for medium text  |
| theme.typography.fontWeightBold    | number | —       | Numeric weight for bold text    |

```ts
const config = {
  theme: {
    typography: {
      fontFamily: "Verdana, sans-serif",
      fontSize: 14,
      fontWeightRegular: 400,
      fontWeightMedium: 500,
      fontWeightBold: 700,
    },
  },
};
```

### Color System

Define full light and dark palettes - primary, secondary, background, text and semantic colors (success, error, warning, info) giving you end to end theming control with one config object

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/colors.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f3d4d354909ad334f05d10ce5ade6a05" data-path="images/products/widget/video/colors.webm" />

```ts
const config = {
  theme: {
    colorSchemes: {
      light: {
        palette: {
          primary: { main: "#02F994", review: "#02F994" },
          secondary: { main: "#F5B5FF" },
          background: {
            default: "#FFFFFF",
            paper: "#F5F5F5",
            selected: "#E0E0E0",
          },
          text: { primary: "#1A1A1A", secondary: "#757575" },
          success: { main: "#4CAF50" },
          error: { main: "#F44336" },
          warning: { main: "#FF9800" },
          info: { main: "#2196F3" },
        },
      },
      dark: {
        palette: {
          /* dark-mode overrides here */
        },
      },
    },
  },
};
```

## Component Customization

The GlueX Widget offers robust component customization through custom component overrides. This means you can tailor the look and feel of various elements to perfectly match your application's design

<Accordion title="Learn how to Customize">
  ### Step 1: Build Your Custom Component

  Create your own React component that matches the expected props for the widget element you want to customize

  For example, to customize the token selector button, you might write:

  ```typescript
  // custom/token-selector.tsx
  import { type SelectTokenButtonProps } from "@gluex/widget";

  export const CustomTokenHeader: React.FC<SelectTokenButtonProps> = ({
    formType, // "from" | "to" - Indicates if this is the source or destination token
    token, // Selected token information
    chain, // Selected chain information
    isSelected, // is token selected
    compact, // Whether to show compact view
    onClick, // Handler for when the selector is clicked
  }) => {
    return <div>{/* Your custom token header UI */}</div>;
  };
  ```

  ### Step 2: Apply in Configuration

  Simply import your custom component and include it in your widget configuration

  <Note>
    For repetitive components, you can customize each of them individually (eg:
    token selection - "from" and "to" buttons separately)
  </Note>

  ```typescript
  import { GlueXWidget, type WidgetConfigPartialProps } from "@gluex/widget";
  import { CustomTokenHeader } from "./custom/token-selector";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = {
      integrator: "YOUR_INTEGRATOR_ID",
      apiKey: "YOUR_API_KEY",
      appearance: "light",

      // Add the custom components
      components: {
        // Use different components or styles for from/to
        SelectTokenButton: {
          from: CustomTokenHeader, // Custom component for "from" token
          to: CustomTokenHeader, // Custom component for "to" token
        },
      },
    };

    return <GlueXWidget config={config} />;
  };
  ```
</Accordion>

<Warning>
  Ensure your custom component implements all required handler functions and
  events. Missing handlers may cause unexpected behavior or break widget
  functionality
</Warning>

### Amount Selection

```tsx
import { type PercentageAmountSelectorProps } from "@gluex/widget";

export const CustomPercentageAmountSelector = ({
  onAmountChange, // (percentage: number) => void
  isLoading, // Whether data is loading
}: PercentageAmountSelectorProps) => {
  const percentages = [
    { value: 0.25, label: "25%" },
    { value: 0.5, label: "50%" },
    { value: 0.75, label: "75%" },
    { value: 1, label: "MAX" },
  ];

  return <div>{/* Your custom percentage selection UI */}</div>;
};
```

### Token Amount Display

```tsx
import { type TokenAmountPriceProps } from "@gluex/widget";

export const CustomTokenAmountPrice = ({
  amount, // Token amount
  token, // Token information
  tokenPrice, // Current token price
  isLoading, // Whether data is loading
}: TokenAmountPriceProps) => {
  return <div>{/* Your custom amount display UI */}</div>;
};
```

### Transaction Details

```tsx
import { type TransactionDetailsProps } from "@gluex/widget";

export const CustomTransactionDetails = ({
  tokens, // From/To token information
  fees, // Network, protocol, and total fees
  minReceived, // Minimum amount to receive
  providers, // List of providers used
}: TransactionDetailsProps) => {
  return <div>{/* Your custom transaction details UI */}</div>;
};
```

### Completed Transaction

```tsx
import { type CompletedTransactionDetailsProps } from "@gluex/widget";

export const CustomCompletedTransaction = ({
  tokens, // From/To token information
  amounts, // Transaction amounts
  fees, // Transaction fees
  transaction, // Transaction details with hash and link
  providers, // List of providers used
  showRouteSection, // Whether to show route section
  showDetailsSection, // Whether to show details section
}: CompletedTransactionDetailsProps) => {
  return <div>{/* Your custom completed transaction UI */}</div>;
};
```


# Events
Source: https://docs.gluex.xyz/build-with-gluex/widget/events



The GlueX Widget provides a comprehensive event system through the `useWidgetEvents` hook that allows you to subscribe to various widget events.
These hooks helps you retrieve helpful information and to track swap progress, monitor quote execution, observe chain and token selections, track UI interactions and more

<Note>
  We actively work on extending the list of available widget events. If you need
  support for a specific event, please contact us via our [support
  channels](https://bento.me/gluex-protocol)
</Note>

## Setup

First, import the necessary types and hooks:

```tsx
import {
  WidgetEvent,
  useWidgetEvents,
  type Route,
  type RouteExecutionUpdate,
} from "@gluex/widget";

export const WidgetEvents = () => {
  const events = useWidgetEvents();

  useEffect(() => {
    const onRouteExecutionStarted = (route: Route) => {
      // Handle route start
    };

    const onRouteExecutionUpdated = (update: RouteExecutionUpdate) => {
      // Handle route updates
    };

    const onRouteExecutionCompleted = (route: Route) => {
      // Handle route completion
    };

    const onRouteExecutionFailed = (update: RouteExecutionUpdate) => {
      // Handle route failure
    };

    events.on(WidgetEvent.RouteExecutionStarted, onRouteExecutionStarted);
    events.on(WidgetEvent.RouteExecutionUpdated, onRouteExecutionUpdated);
    events.on(WidgetEvent.RouteExecutionCompleted, onRouteExecutionCompleted);
    events.on(WidgetEvent.RouteExecutionFailed, onRouteExecutionFailed);

    // Cleanup subscriptions
    return () => {
      events.all.clear();
    };
  }, [events]);

  return <></>;
};
```

<Note>
  For optimal performance and to avoid unnecessary re-renders or unexpected
  behavior in your main widget component, we recommend using the
  `useWidgetEvents` hook outside of the component where the primary
  `GlueXWidget` is rendered
</Note>

## Event Type

The widget emits various events that you can listen to:

```tsx
enum WidgetEvent {
  // Route Events
  RouteExecutionStarted = "routeExecutionStarted"     // When a route starts executing
  RouteExecutionUpdated = "routeExecutionUpdated"     // Progress updates during execution
  RouteExecutionCompleted = "routeExecutionCompleted" // When route completes successfully
  RouteExecutionFailed = "routeExecutionFailed"       // When route execution fails
  RouteHighValueLoss = "routeHighValueLoss"           // High value loss detection
  RouteSelected = "routeSelected"                     // When a route is selected

  // Chain and Token Events
  SourceChainTokenSelected = "sourceChainTokenSelected"
  DestinationChainTokenSelected = "destinationChainTokenSelected"

  // Wallet Events
  WalletConnected = "walletConnected"
  SendToWalletToggled = "sendToWalletToggled"

  // UI and Form Events
  PageEntered = "pageEntered"
  FormFieldChanged = "formFieldChanged"
  SettingUpdated = "settingUpdated"
  TokenSearch = "tokenSearch"
  TransactionError = "transactionError"
}
```

## Available Events

### Route Events

#### RouteExecutionStarted

Fires when the user clicks the "Start swapping" or "Start bridging" button, initiating the execution of a selected route. This marks the beginning of the cross-chain transaction process.

**Payload**: `Route`

```typescript
interface Route {
  id: string; // Unique identifier for this route instance
  fromChainId: number; // Numeric ID of source chain (e.g. 1 = Ethereum, 137 = Polygon)
  fromAddress?: string; // Wallet address tokens are taken from (if pre-filled)
  fromToken: TokenWithPriceAndAmount & WithAdditionalDetails; // Source token metadata + price/amount info
  fromAmount: string; // Amount of source token user requested (in token units)
  effectiveFromAmount?: string; // Actual amount used after fee/slippage adjustments
  fromAmountUSD: string; // USD value of `fromAmount`
  toChainId: number; // Numeric ID of destination chain
  toAddress?: string; // Destination wallet address (if sending to different wallet)
  toToken: TokenWithPriceAndAmount & WithAdditionalDetails; // Destination token metadata + price/amount info
  toAmount: string; // Expected amount of destination token
  toAmountReceive: string; // Amount that will actually arrive (after fees)
  toAmountMin: string; // Minimum acceptable output (slippage protection floor)
  toAmountUSD: string; // USD value of `toAmount`
  gasCostUSD?: string; // Estimated gas cost in USD
  steps: GlueXStep[]; // Ordered list of low-level execution steps (bridge, swap, etc.)
}
```

**Handler**:

```typescript
const onRouteExecutionStarted = (route: Route) => {
  console.log("Route execution started:", route.id);
  console.log(
    `Converting ${route.fromAmount} ${route.fromToken.symbol} on chain ${route.fromChainId}`
  );
  console.log(
    `Expected to receive ${route.toAmountReceive} ${route.toToken.symbol} on chain ${route.toChainId}`
  );
};
```

#### RouteExecutionUpdated

Fires during route execution to provide real-time progress updates. Contains the current process step and updated route information, allowing you to track execution progress and display status to users.

**Payload**: `RouteExecutionUpdate`

```typescript
interface RouteExecutionUpdate {
  route: Route; // Updated route object with current state
  process: Process; // Current execution process details
}

interface Process {
  id: string; // Unique process identifier
  status: ProcessStatus; // Current status (pending, running, completed, failed)
  type: ProcessType; // Type of process (swap, bridge, approval, etc.)
  txHash?: string; // Transaction hash if available
  message?: string; // Human-readable status message
  error?: string; // Error message if process failed
}
```

**Handler**:

```typescript
const onRouteExecutionUpdated = (update: RouteExecutionUpdate) => {
  const { route, process } = update;

  console.log(`Route ${route.id} update:`, process.status);
  console.log(`Current step: ${process.type}`);

  if (process.txHash) {
    console.log(`Transaction hash: ${process.txHash}`);
  }
};
```

#### RouteExecutionCompleted

Fires when a route execution completes successfully. All steps have been executed and the user has received their destination tokens.

**Payload**: `Route`

**Handler**:

```typescript
const onRouteExecutionCompleted = (route: Route) => {
  console.log("Route execution completed successfully:", route.id);
  console.log(
    `Successfully converted ${route.fromAmount} ${route.fromToken.symbol} to ${route.toAmountReceive} ${route.toToken.symbol}`
  );

  // Show success notification
  showSuccessNotification(
    `Swap completed! You received ${route.toAmountReceive} ${route.toToken.symbol}`
  );
};
```

#### RouteExecutionFailed

Fires when route execution fails at any step. Provides details about the failure through the process object.

**Payload**: `RouteExecutionUpdate`

**Handler**:

```typescript
const onRouteExecutionFailed = (update: RouteExecutionUpdate) => {
  const { route, process } = update;

  console.error("Route execution failed:", route.id);
  console.error("Failure reason:", process.error);

  // Show error notification to user
  showErrorNotification(
    `Swap failed: ${process.error || "Unknown error occurred"}`
  );
};
```

#### RouteHighValueLoss

Fires when the system detects a significant value loss (high slippage, fees, or unfavorable market conditions) and displays a warning to the user.

**Payload**: `RouteHighValueLossUpdate`

```typescript
interface RouteHighValueLossUpdate {
  fromAmountUSD: number; // USD value of input amount
  toAmountUSD: number; // USD value of expected output
  gasCostUSD?: number; // Estimated gas costs in USD
  feeCostUSD?: number; // Protocol/bridge fees in USD
  valueLoss: number; // Total value loss as percentage (0.05 = 5%)
}
```

**Handler**:

```typescript
const onRouteHighValueLoss = (valueLoss: RouteHighValueLossUpdate) => {
  console.warn("High value loss detected:");
  console.warn(`Input: $${valueLoss.fromAmountUSD}`);
  console.warn(`Output: $${valueLoss.toAmountUSD}`);
  console.warn(`Total loss: ${(valueLoss.valueLoss * 100).toFixed(2)}%`);

  // Show warning modal
  showHighValueLossWarning({
    inputValue: valueLoss.fromAmountUSD,
    outputValue: valueLoss.toAmountUSD,
    lossPercentage: valueLoss.valueLoss,
    gasCost: valueLoss.gasCostUSD,
    fees: valueLoss.feeCostUSD,
  });
};
```

#### RouteSelected

Fires when a user selects a specific route from the available options. This happens before execution begins.

**Payload**: `RouteSelected`

```typescript
interface RouteSelected {
  route: Route; // The selected route object
}
```

**Handler**:

```typescript
const onRouteSelected = (selection: RouteSelected) => {
  const { route } = selection;

  console.log("Route selected:", route.id);
  console.log(
    `Route details: ${route.fromToken.symbol} → ${route.toToken.symbol}`
  );
  console.log(`Estimated output: ${route.toAmount} ${route.toToken.symbol}`);
};
```

### Token and Chain Selection Events

#### SourceChainTokenSelected

Fires when the user selects or changes the source chain and token combination.

**Payload**: `ChainTokenSelected`

```typescript
interface ChainTokenSelected {
  chainId: Chain["id"]; // Numeric chain ID (e.g., 1 for Ethereum)
  tokenAddress: string; // Token contract address (or "0x0" for native tokens)
}
```

**Handler**:

```typescript
const onSourceChainTokenSelected = (selection: ChainTokenSelected) => {
  console.log(
    `Source selected: Token ${selection.tokenAddress} on chain ${selection.chainId}`
  );
};
```

#### DestinationChainTokenSelected

Fires when the user selects or changes the destination chain and token combination.

**Payload**: `ChainTokenSelected`

**Handler**:

```typescript
const onDestinationChainTokenSelected = (selection: ChainTokenSelected) => {
  console.log(
    `Destination selected: Token ${selection.tokenAddress} on chain ${selection.chainId}`
  );
};
```

### Wallet Events

#### WalletConnected

Fires when a user successfully connects their wallet through the widget's internal wallet management UI.

**Payload**: `WalletConnected`

```typescript
interface WalletConnected {
  address?: string; // Connected wallet address
  chainId?: number; // Currently connected chain ID
  chainType?: ChainType; // Type of chain (EVM, Solana, etc.)
}
```

**Handler**:

```typescript
const onWalletConnected = (wallet: WalletConnected) => {
  console.log("Wallet connected:", wallet.address);
  console.log("Connected to chain:", wallet.chainId);
};
```

#### SendToWalletToggled

Fires when the user toggles the "send to different wallet" option by clicking the wallet icon next to the action button.

**Payload**: `boolean` (true if enabled, false if disabled)

**Handler**:

```typescript
const onSendToWalletToggled = (isEnabled: boolean) => {
  console.log("Send to wallet toggled:", isEnabled);

  if (isEnabled) {
    // Show destination wallet input
    showDestinationWalletInput();
    console.log("User can now specify a different destination wallet");
  } else {
    // Hide destination wallet input
    hideDestinationWalletInput();
    console.log("Tokens will be sent to connected wallet");
  }
};
```

### UI and Navigation Events

#### PageEntered

Fires when the user navigates to a different page within the widget.

**Payload**: `NavigationRouteType` (string indicating the page/route name)

**Handler**:

```typescript
const onPageEntered = (page: NavigationRouteType) => {
  console.log("User navigated to page:", page);
};
```

#### ReviewTransactionPageEntered

Fires when the user enters the transaction review page by clicking on a specific route.

**Payload**: `Route` (optional - the route being reviewed)

**Handler**:

```typescript
const onReviewTransactionPageEntered = (route?: Route) => {
  console.log("User entered transaction review page");

  if (route) {
    console.log("Reviewing route:", route.id);
    console.log(
      `Route summary: ${route.fromAmount} ${route.fromToken.symbol} → ${route.toAmount} ${route.toToken.symbol}`
    );

    // Pre-populate review page with route details
    populateReviewPage(route);
  }

  // Track review page entry
  analytics.track("review_page_entered", {
    routeId: route?.id,
    hasRoute: !!route,
  });

  // Show transaction warnings or additional info
  showTransactionWarnings(route);
};
```

### Form and Settings Events

#### FormFieldChanged

Fires whenever any form field value changes in the widget (amount input, slippage settings, etc.).

**Payload**: `FormFieldChanged`

```typescript
type FormFieldChanged = {
  [K in keyof DefaultValues]: {
    fieldName: K; // Name of the changed field
    newValue: DefaultValues[K]; // New value
    oldValue: DefaultValues[K]; // Previous value
  };
}[keyof DefaultValues];
```

**Handler**:

```typescript
const onFormFieldChanged = (change: FormFieldChanged) => {
  console.log(`Form field "${change.fieldName}" changed:`);
  console.log(`  Old value: ${change.oldValue}`);
  console.log(`  New value: ${change.newValue}`);

  // Field-specific logic
  switch (change.fieldName) {
    case "amount":
      // Recalculate routes when amount changes
      if (change.newValue && parseFloat(change.newValue) > 0) {
        debounceRecalculateRoutes();
      }
      break;
    case "slippage":
      // Update slippage warnings
      validateSlippageSetting(change.newValue);
      break;
  }
};
```

#### SettingUpdated

Fires when any widget setting is updated (theme, slippage tolerance, gas price, etc.).

**Payload**: `SettingUpdated`

```typescript
interface SettingUpdated<K extends keyof SettingsProps = keyof SettingsProps> {
  setting: K; // Name of the updated setting
  newValue: SettingsProps[K]; // New setting value
  oldValue: SettingsProps[K]; // Previous setting value
  newSettings: SettingsProps; // Complete updated settings object
  oldSettings: SettingsProps; // Complete previous settings object
}
```

**Handler**:

```typescript
const onSettingUpdated = (update: SettingUpdated) => {
  console.log(`Setting "${update.setting}" updated:`);
  console.log(`  Old value: ${update.oldValue}`);
  console.log(`  New value: ${update.newValue}`);
};
```

#### TokenSearch

Fires when the user searches for tokens in the token selection interface.

**Payload**: `TokenSearch`

```typescript
interface TokenSearch {
  value: string; // Search query entered by user
  tokens: TokenWithPriceAndAmount[]; // Array of tokens matching the search
}
```

**Handler**:

```typescript
const onTokenSearch = (search: TokenSearch) => {
  console.log(`User searched for: "${search.value}"`);
  console.log(`Found ${search.tokens.length} matching tokens`);

  // Display search results
  displaySearchResults(search.tokens);
};
```

### Error and Support Events

#### TransactionError

Fires when a transaction error occurs during route execution, providing detailed error information for debugging and support.

**Payload**: `TransactionErrorEvent`

```typescript
interface TransactionErrorEvent {
  supportId?: string; // Unique support ID for tracking
  errorCode: string; // Standardized error code
  errorMessage: string; // Human-readable error message
  chainId?: number; // Chain where error occurred
  tokenSymbol?: string; // Token involved in failed transaction
  toolName?: string; // Bridge/DEX tool that failed
  stepType?: string; // Type of step that failed (swap, bridge, approval)
  txHash?: string; // Transaction hash if available
  timestamp: string; // ISO timestamp of error
}
```

**Handler**:

```typescript
const onTransactionError = (error: TransactionErrorEvent) => {
  console.error("Transaction error occurred:");
  console.error(`  Error code: ${error.errorCode}`);
  console.error(`  Message: ${error.errorMessage}`);
  console.error(`  Support ID: ${error.supportId}`);

  if (error.txHash) {
    console.error(`  Transaction: ${error.txHash}`);
  }

  // Show user-friendly error message
  showErrorNotification({
    title: "Transaction Failed",
    message: error.errorMessage,
    supportId: error.supportId,
    actionButton: "Contact Support",
  });
};
```

#### ContactSupport

Fires when the user clicks the "Contact support" button, typically from the transaction details page or error states.

**Payload**: `ContactSupport`

```typescript
interface ContactSupport {
  supportId?: string; // Unique identifier for support context
}
```

**Handler**:

```typescript
const onContactSupport = (support: ContactSupport) => {
  console.log("User requesting support");

  if (support.supportId) {
    console.log(`Support ID: ${support.supportId}`);
  }
};
```

#### LowAddressActivityConfirmed

Fires when the user confirms they want to proceed despite low activity on the destination address, typically shown as a security warning.

**Payload**: `LowAddressActivityConfirmed`

```typescript
interface LowAddressActivityConfirmed {
  address: string; // The address with low activity
  chainId: number; // Chain ID where address has low activity
}
```

**Handler**:

```typescript
const onLowAddressActivityConfirmed = (
  confirmation: LowAddressActivityConfirmed
) => {
  console.log("User confirmed low activity address:");
  console.log(`  Address: ${confirmation.address}`);
  console.log(`  Chain ID: ${confirmation.chainId}`);
};
```


# Features
Source: https://docs.gluex.xyz/build-with-gluex/widget/features



### Core Capabilities

* **Extensive Protocol Support**: The GlueX Widget natively supports all tokens, chains and liquidity modules integrated into GlueX, ensuring broad access to the DeFi ecosystem giving access to a vast array of assets and networks without additional setup

* **Comprehensive DeFi Operations**: Beyond simple swaps, the widget facilitates a wide spectrum of DeFi activities, including:

  * Routing: Intelligent routing across various protocols to find the most optimal paths for transactions
  * Swap: Token exchanges across all supported chains
  * Bridge: Asset transfers between diverse networks and ecosystems
  * Lend and Borrow: Access to decentralized lending and borrowing protocols
  * Stake, Unstake, Restake: Participate in staking programs with full control over your assets
  * Mint and Redeem: Interact with various token minting and redemption mechanisms
  * Farm Yield: Engage in yield farming strategies to maximize returns
  * Provide Liquidity: Contribute to liquidity pools and earn fees
  * And many more DeFi operations

* **Flexible Display Variants**: The GlueX Widget offers flexible display options to fit seamlessly into any application layout:

  * **Compact Mode**: Ideal for integrating into smaller sections of your application without overwhelming the UI
  * **Drawer Mode**: Provides a sleek, slide-out interface that integrates smoothly into existing designs, perfect for a non-intrusive experience
  * **Full-Page Mode**: Offers a comprehensive, dedicated view for complex interactions or a primary DeFi experience within your application

* **Granular Control over Assets and Networks**: Developers have precise control over the widget's offerings, with options to explicitly **allow or deny certain chains and tokens** allowing you to tailor the user experience to your specific application's needs

* **Liquidity Module Filtering**: Advanced filtering capabilities enabling you to **select and display only specific liquidity modules** that are most relevant to your application's focus or user base

* **Extensive Theming System**:

  * **32+ Preconfigured Themes**: Choose from a rich library of professionally designed themes to instantly match your brand's aesthetic
  * **Deep Customization Options**: Go beyond themes with granular control over colors, typography, shapes, spacing and every visual aspect to create a look and feel that perfectly aligns with your brand identity
  * **Dark Mode Support**: Integrates with user system preferences for dark mode, ensuring a comfortable viewing experience in all lighting conditions and enhancing user accessibility

* **Configurable Components**: Show, hide, or customize any individual component within the widget. This allows for a **highly modular and adaptable user interface**, giving you complete flexibility over its appearance and functionality

* **Wallet Integration**: Supports **smooth integration with any wallet provider** of your choice, ensuring broad compatibility

* **Industry Standard Adherence**: Built with adherence to top industry standards:

  * **EIP-5792**: For batched transactions and improved transaction management
  * **ERC-2612**: Enabling gasless approvals for ERC20 tokens
  * **EIP-712**: For structured data signing
  * **Permit2**: For efficient and secure token approvals

* **Comprehensive Transaction Management**:

  * **Real-time Transaction Progress View**: Users can easily monitor the status of their transactions from initiation to completion
  * **Detailed Transaction History**: Provides a record of past transactions for easy tracking, auditing and reference

* **Wallet Health Checks**: Includes automated checks to ensure connected wallets are in a healthy state and compatible with the ongoing operations, preventing potential issues

* **Route Settings**: Flexibility to configure their preferred route settings, such as **slippage tolerance, gas preferences and transaction speed**

* **Wide Framework Compatibility**: Extensively tested for compatibility with leading web development frameworks:

  * [React](/build-with-gluex/widget/integration/integrate-widget-with-react)
  * [Next](/build-with-gluex/widget/integration/integrate-widget-with-nextjs)
  * [Vite](/build-with-gluex/widget/integration/integrate-widget-with-vite)
  * [Gatsby](/build-with-gluex/widget/integration/integrate-widget-with-gatsby)
  * [Vue](/build-with-gluex/widget/integration/integrate-widget-with-vue)
  * [Rainbowkit](/build-with-gluex/widget/integration/integrate-widget-with-rainbowkit)

<Note>
  We will roll out support to other frameworks in the future based on their
  demand
</Note>


# Internationalization
Source: https://docs.gluex.xyz/build-with-gluex/widget/i18n



\[COMING SOON ...]


# Installation and Quickstart
Source: https://docs.gluex.xyz/build-with-gluex/widget/installation

Easy installation to go onchain under 5 minutes

## Installation

To begin, install the necessary packages. We recommend using the latest stable versions for optimal performance and security

<CodeGroup>
  ```bash npm theme={null}
  npm install wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash yarn theme={null}
  yarn add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash pnpm theme={null}
  pnpm add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash bun theme={null}
  bun add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```
</CodeGroup>

## Quickstart

Before you start with integration, you'll need to obtain your API Key and Integrator ID. These are essential for authenticating your application and tracking its usage with GlueX.
You can easily generate these credentials by logging into the [GlueX Portal](https://portal.gluex.xyz).

Once you have your credentials, you can integrate the GlueX Widget with just a few lines of code:

```typescript  theme={null}
import { GlueXWidget, WidgetConfiguration } from "@gluex/widget"

const config: Partial<WidgetConfiguration> = {
  apiKey: enviroment.GLUEX_API_KEY,
  integrator: enviroment.INTEGRATOR_ID,
};

export const WidgetPage = () => {
  return <GlueXWidget config={config} />;
};
```

<Info>
  Explore widget template repositories for different frameworks in our
  [examples repository](https://github.com/gluexprotocol/gluex-examples).
</Info>


# Installing the GlueX widget
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/installing-the-widget

Learn how to seamlessly integrate the GlueX Widget into your web application to enable powerful DeFi functionalities for your users

The GlueX Widget provides a ready-to-use, customizable UI component that simplifies the integration of advanced DeFi operations (like token swaps, bridge, lend, stake, zap and swidge) directly into your application. This guide walks you through the general installation process, covering prerequisites and package installation

## Prerequisites

Before you begin installing the GlueX widget, please ensure you have the following in place:

* **Integrator ID and API key**: You must have registered for and obtained your unique Integrator ID and API Key from the **[GlueX Developer Portal](https://portal.gluex.xyz)**. These credentials are essential for authenticating your API requests and for tracking your usage and any partner specific configurations (like fees)
* **Node.js and package manager**: Ensure you have a recent version of Node.js installed on your system, along with its package manager (npm/yarn/pnpm/bun)

## Installation

### Install the package

The GlueX widget is distributed as an npm package. It relies on `wagmi` and `@tanstack/react-query` as peer dependencies for managing blockchain interactions and data fetching, respectively.

Use your preferred package manager to install the widget, SDK and their essential peer dependencies:

<CodeGroup>
  ```bash npm
  npm install wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash yarn
  yarn add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash pnpm
  pnpm add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash bun
  bun add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```
</CodeGroup>

### Update dependencies (if necessary)

The widget utilizes `wagmi` and `@tanstack/react-query`. If your project already includes these packages, it is crucial to ensure they are updated to versions compatible with the GlueX widget to avoid conflicts or unexpected behavior

> For comprehensive guidance on upgrading `wagmi` to its latest compatible version, please refer to the official [wagmi migration guide](https://wagmi.sh/react/migration-guide)

## Next Steps

Once the necessary packages are installed, the next crucial step is to integrate the GlueX Widget into your specific application framework. We provide dedicated guides to streamline this process for popular development environments:

* [React Integration Guide](/build-with-gluex/widget/integration/integrate-widget-with-react)
* [NextJS Integration Guide](/build-with-gluex/widget/integration/integrate-widget-with-nextjs)
* [Vite Integration Guide](/build-with-gluex/widget/integration/integrate-widget-with-vite)
* [Gatsby Integration Guide](/build-with-gluex/widget/integration/integrate-widget-with-gatsby)
* [Rainbowkit Integration Guide](/build-with-gluex/widget/integration/integrate-widget-with-rainbowkit)
* Vue Integration Guide (coming soon)

Choose the guide that best matches your project's technical stack to proceed with the integration

## Support

If you have any questions, require assistance during installation or need further guidance on integrating, please join our our [official Telegram channel](https://t.me/+_VmO_gIrNjxiZWE0)


# Integrate GlueX widget as an Iframe
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-the-widget-as-iframe

Learn how to integrate the widget into your application as an Iframe, enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

While the GlueX Widget is primarily designed as a modular web component for direct integration into popular frontend frameworks (React, Next.js, Gatsby, Vue, etc), it can also be effectively embedded into any web application as an `<iframe>`. This method offers broad compatibility and isolation, making it a versatile option for diverse development environments

This guide will walk you through the process of setting up, configuring and customizing the GlueX Widget when delivered via an iframe

## Why Use the iFrame?

Choosing to integrate the GlueX Widget via an iframe offers distinct advantages, particularly for certain project types and architectural needs:

* **Compatibility**: The iframe method is highly universal. If your frontend framework is not directly supported by our web component guides (eg: Angular or vanilla projects without a build step), using an iframe allows you to integrate the widget into virtually any web application
* **Simplicity**: Embedding an iframe is a straightforward HTML task. It typically requires minimal code and doesn't introduce additional external dependencies or complex build configurations to your main application
* **Isolation**: The widget runs within its own isolated browse context. This minimizes potential conflicts with your existing application's styles, scripts and global variables, providing a sandboxed environment for the widget's functionality. This can be beneficial for security and maintaining application stability

## Integration

(coming soon)

### Configuration

(coming soon)

### Customization

(coming soon)

### Key Consideration

(coming soon)

### Best Practices

(coming soon)


# Integrate GlueX widget with ConnectKit
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-connectkit

Learn how to integrate the widget into your ConnectKit + Next.js application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with ConnectKit (Next.js) applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [ConnectKit example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-connectkit-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with ConnectKit specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget

<CodeGroup>
  ```tsx Widget.tsx
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your ConnectKit + Next.js application

```tsx App.tsx
import { Widget } from "./components/Widget";

function App() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default App;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Dynamic
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-dynamic

Learn how to integrate the widget into your Dynamic + Next.js application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Dynamic (Next.js) applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Dynamic example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-dynamic-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with Dynamic specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget

<CodeGroup>
  ```tsx Widget.tsx
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your Dynamic + Next.js application

```tsx App.tsx
import { Widget } from "./components/Widget";

function App() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default App;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Gatsby
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-gatsby

Learn how to integrate the widget into your Gatsby application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Gatsby applications and requires minimal configuration for smooth integration, offering a powerful, ready to use UI component for seamless DeFi interactions

<Info>
  For a complete working example, check out our full [Gatsby example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-gatsby-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with gatsby specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx theme={null}
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your Gatsby application

```tsx pages/index.tsx theme={null}
import { Widget } from "../components/Widget";

function HomePage() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default HomePage;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Next.js
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-nextjs

Learn how to integrate the widget into your next.js application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Next.js applications and requires minimal configuration for smooth integration. Due to the nature of server side rendering (SSR) in Next and how different wallet libraries manage their connections to wallet extensions, the widget needs to be specifically rendered on the client side. To achieve this, make use of the 'use client' directive, which ensures that the widget component is only rendered in the client side environment

<Info>
  For a complete working example, check out our full [Next.js example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-nextjs-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with next.js specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration - App Router

With the Next.js App Router, components are primarily rendered on the server by default. To ensure the widget (and its dependencies like wagmi) runs exclusively on the client, you'll utilize the `"use client"` directive and a small client side rendering wrapper component

First, create a `Widget.tsx` file (or a similar descriptive name) within your components directory. This component will encapsulate the GlueX widget and ensure it renders only on the client side

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  "use client";

  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx theme={null}
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your application

```tsx app/page.tsx theme={null}
import { Widget } from "../components/Widget";

function HomePage() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default HomePage;
```

### Integration - Pages Router

If you are using the traditional Pages Router, you need to use the dynamic import feature with `ssr: false` to import the widget dynamically

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  import dynamic from "next/dynamic";

  const GlueXWidget = dynamic(
    () => import("@gluex/widget").then((mod) => mod.GlueXWidget),
    {
      loading: () => <div>Loading...</div>,
      ssr: false,
    }
  );

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return <GlueXWidget config={config} />;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your application

```tsx pages/index.tsx theme={null}
import { Widget } from "../components/Widget";

function HomePage() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default HomePage;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Nuxt
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-nuxt

Learn how to integrate the widget into your Nuxt application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Nuxt applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Nuxt example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-nuxt-integration)
</Info>

### Prerequisites

Before proceeding with Nuxt specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.vue` file in your components directory to encapsulate the GlueX widget:

<CodeGroup>
  ```vue Widget.vue
  <script setup>
  import { onMounted, onUnmounted, ref } from 'vue';
  import { createRoot } from 'react-dom/client';
  import { createElement } from 'react';
  import { GlueXWidget } from '@gluex/widget';

  const container = ref(null)
  let root = null

  const config = {
    integrator: "",
    apiKey: "",

    // ... rest of the widget configuration
    // Example:
    // appearance: 'dark',
    // theme: {
    //   container: {
    //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
    //     borderRadius: '16px',
    //   },
    // },
  };

  onMounted(() => {
    const mountNode = document.createElement('div')
    container.value.appendChild(mountNode)

    root = createRoot(mountNode)
    root.render(createElement(GlueXWidget, { config }))
  })

  onUnmounted(() => {
    if (root) root.unmount()
  })
  </script>

  <template>
    <div class="widget-container" ref="container"></div>
  </template>
  ```
</CodeGroup>

**Usage in Your App**

You can now import and use the widget component anywhere in your Nuxt application:

```vue pages/index.vue
<script setup>
import Widget from '~/components/Widget.vue'
</script>
<template>
  <div>
    <h1>My DeFi App</h1>
    <Widget />
  </div>
</template>
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Rainbowkit
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-rainbowkit

Learn how to integrate the widget with Rainbowkit enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Rainbowkit applications and requires minimal configuration for smooth integration. This guide demonstrates how to integrate the widget specifically with Rainbowkit and Next.js

Due to the nature of server side rendering (SSR) in Next and how different wallet libraries manage their connections to wallet extensions,
the widget needs to be specifically rendered on the client side. To achieve this, make use of the 'use client' directive, which ensures that the
widget component is only rendered in the client side environment

<Info>
  For a complete working example, check out our full [Rainbowkit example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-rainbowkit-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with the integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration - App Router

With the Next.js App Router, components are primarily rendered on the server by default. To ensure the widget (and its dependencies like wagmi) runs exclusively on the client, you'll utilize the `"use client"` directive and a small client side rendering wrapper component

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  "use client";

  import React from "react";

  import {
    GlueXWidget,
    WidgetSkeleton,
    type WidgetConfigPartialProps,
  } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx theme={null}
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component in your Rainbowkit application

```tsx app/page.tsx theme={null}
"use client";

import { ConnectButton } from "@rainbow-me/rainbowkit";
import { type NextPage } from "next";
import { Widget } from "./Widget";

const HomePage: NextPage = () => {
  return (
    <div>
      <ConnectButton />
      <Widget />
    </div>
  );
};

export default HomePage;
```

### Integration - Pages Router

If you are using the traditional Pages Router, you need to use the dynamic import feature with `ssr: false` to import the widget dynamically

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  import dynamic from "next/dynamic";

  const GlueXWidget = dynamic(
    () => import("@gluex/widget").then((mod) => mod.GlueXWidget),
    {
      loading: () => <div>Loading...</div>,
      ssr: false,
    }
  );

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return <GlueXWidget config={config} />;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your application

```tsx pages/index.tsx theme={null}
import { Widget } from "../components/Widget";
import { ConnectButton } from "@rainbow-me/rainbowkit";

function HomePage() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <ConnectButton />
      <Widget />
    </div>
  );
}

export default HomePage;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with React
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-react

Learn how to integrate the widget into your React application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with React applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [React example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-react-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with React specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx theme={null}
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your React application

```tsx App.tsx theme={null}
import { Widget } from "./components/Widget";

function App() {
  return (
    <div>
      <h1>My DeFi Application</h1>
      <Widget />
    </div>
  );
}

export default App;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Remix
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-remix

Learn how to integrate the widget into your Remix application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Remix (React) applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Remix example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-remix-integration)
</Info>

### Prerequisites

Before proceeding with Remix specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget:

<CodeGroup>
  ```tsx Widget.tsx
  "use client";

  import React, { useEffect, useState } from "react";
  import type { WidgetConfigPartialProps } from "@gluex/widget";

  const ClientSideWidget = ({ config }: { config: WidgetConfigPartialProps["config"] }) => {
    const [Widget, setWidget] = useState<React.ComponentType<{ config: any }> | null>(null);
    
    useEffect(() => {
      import("@gluex/widget").then(module => {
        setWidget(() => module.GlueXWidget);
      });
    }, []);

    if (!Widget) {
      return <div>Loading...</div>;
    }

    return <Widget config={config} />;
  };

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = {
      integrator: "",
      apiKey: "",

      // ... rest of the widget configuration
      // appearance: 'dark',
      // theme: {
      //   container: {
      //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
      //     borderRadius: '16px',
      //   },
      // },
    };

    return <ClientSideWidget config={config} />;
  };
  ```
</CodeGroup>

**Usage in Your App**

You can now import and use the widget component anywhere in your Remix application:

```tsx app/routes/_index.tsx
import { Widget } from "../components/Widget";

export default function Index() {
  return (
    <div>
      <h1>My DeFi App</h1>
      <Widget />
    </div>
  );
}
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Reown
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-reown

Learn how to integrate the widget into your Reown + Next.js application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Reown (Next.js) applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Reown example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-reown-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with Reown specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget

<CodeGroup>
  ```tsx Widget.tsx
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your Reown + Next.js application

```tsx App.tsx
import { Widget } from "./components/Widget";

function App() {
  return (
    <div>
      <h1>My DeFi Application</h1>
       <appkit-button />
      <Widget />
    </div>
  );
}

export default App;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Vite
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-vite

Learn how to integrate the widget into your Vite application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Vite applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Vite example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-react-integration)
</Info>

<Accordion title="Why client side rendering?">
  Wallet connection libraries (like wagmi, which the widget uses) interact
  directly with browser APIs and wallet extensions. These functionalities are
  only available in a client side (browser) environment. Attempting to render
  them on the server during the build or request time would result in errors. By
  explicitly marking components for client side rendering, we ensure
  compatibility and a smooth user experience
</Accordion>

### Prerequisites

Before proceeding with React specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.tsx` file in your components directory to encapsulate the GlueX widget:

<CodeGroup>
  ```tsx Widget.tsx theme={null}
  import React from "react";
  import { type WidgetConfigPartialProps } from "@gluex/widget";
  import { GlueXWidget, WidgetSkeleton } from "@gluex/widget";

  export const Widget = () => {
    const config: WidgetConfigPartialProps["config"] = React.useMemo(() => {
      return {
        integrator: "",
        apiKey: "",

        // ... rest of the widget configuration
        // Example:
        // appearance: 'dark',
        // theme: {
        //   container: {
        //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
        //     borderRadius: '16px',
        //   },
        // },
      };
    }, []);

    return (
      <ClientSideRender fallback={<WidgetSkeleton config={config} />}>
        <GlueXWidget config={config} />
      </ClientSideRender>
    );
  };
  ```

  ```tsx ClientSideRender.tsx theme={null}
  "use client";

  import React from "react";

  interface ClientSideRenderProps {
    children: React.ReactNode;
    fallback?: React.ReactNode;
  }

  export const ClientSideRender: React.FC<ClientSideRenderProps> = ({
    children,
    fallback = null,
  }) => {
    const [hydrated, setHydrated] = React.useState(false);

    React.useEffect(() => {
      setHydrated(true);
    }, []);

    return hydrated ? <>{children}</> : <>{fallback}</>;
  };
  ```
</CodeGroup>

**Usage in your App**

You can now import and use the widget component anywhere in your application:

```tsx App.tsx theme={null}
import { Widget } from "./components/Widget";

function App() {
  return (
    <div>
      <h1>My DeFi App</h1>
      <Widget />
    </div>
  );
}

export default App;
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Integrate GlueX widget with Vue
Source: https://docs.gluex.xyz/build-with-gluex/widget/integration/integrate-widget-with-vue

Learn how to integrate the widget into your Vue application enabling users to perform swaps, bridge assets, lend, stake, zap and swidge directly within the application

GlueX Widget is fully compatible with Vue applications and requires minimal configuration for smooth integration

<Info>
  For a complete working example, check out our full [Vue example
  repository](https://github.com/gluexprotocol/gluex-examples/tree/main/widget-vue-integration)
</Info>

### Prerequisites

Before proceeding with React specific integration, ensure you have completed the general installation steps outlined in the [General Installation](/build-with-gluex/widget/integration/installing-the-widget)

### Integration

Create a `Widget.vue` file in your components directory to encapsulate the GlueX widget:

<CodeGroup>
  ```vue Widget.vue theme={null}
  <script setup>
  import { onMounted, onUnmounted, ref } from 'vue';
  import { createRoot } from 'react-dom/client';
  import { createElement } from 'react';
  import { GlueXWidget } from '@gluex/widget';
  const container = ref(null)
  let root = null
  const config = {
    integrator: "",
    apiKey: "",
    // ... rest of the widget configuration
    // Example:
    // appearance: 'dark',
    // theme: {
    //   container: {
    //     boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.08)',
    //     borderRadius: '16px',
    //   },
    // },
  };
  onMounted(() => {
    const mountNode = document.createElement('div')
    container.value.appendChild(mountNode)
    root = createRoot(mountNode)
    root.render(createElement(GlueXWidget, { config }))
  })
  onUnmounted(() => {
    if (root) root.unmount()
  })
  </script>
  <template>
    <div class="widget-container" ref="container"></div>
  </template>
  ```
</CodeGroup>

**Usage in Your App**

You can now import and use the widget component anywhere in your Vue application:

```vue App.vue theme={null}
<script setup>
import Widget from './components/Widget.vue'
</script>
<template>
  <div>
    <h1>My DeFi App</h1>
    <Widget />
  </div>
</template>
```

### Configuration

The widget is highly configurable through its `config` prop. This allows you to tailor its behavior, default settings and connected services to match your application's requirements. For a complete list of all available configuration options and their detailed descriptions, please refer to the [widget configuration](/build-with-gluex/widget/configuration) section

### Customization

Beyond basic configuration, the widget offers extensive customization capabilities to ensure it seamlessly integrates with your application's branding and design system. You can customize nearly every visual aspect of the widget. For a complete list of all available configuration, theme options, appearance and their detailed descriptions, please refer to the [widget customization](/build-with-gluex/widget/customizations) section

<Note>
  Check out [GlueX's Widget Studio](https://studio.gluex.xyz/playground) to
  customize and generate your custom widget configuration. It provides an
  interactive interface to adjust settings and see real time previews, then
  generates the corresponding config code snippet for you
</Note>


# Overview
Source: https://docs.gluex.xyz/build-with-gluex/widget/overview

GlueX Widget - UI components for effortless DeFi integration (Routing, Swap, Bridge, Lend, Stake and more)

<img className="" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fed39689c5dd52e8b35d113030de2e47" alt="GlueX Widget" width="2026" height="1432" data-path="images/products/widget/widget.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=4c236fd072392a3494818721a49cf3ab 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6403b1f999679c77f7b1720f57461df2 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=df7729bdee19bbd0048476ba86e69819 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6972cfa5958dcbcb5561f35df341843f 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9886cfabf408b24a33f5925c4b0b88f0 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=49ce78e888b5e2fca51f46d9fd55d5d2 2500w" data-optimize="true" data-opv="2" />

The GlueX widget provides the most easiest way to integrate DeFi operations directly into any applications. It enables developers to quickly embed a secure and smooth routing experience for various DeFi operations (swap, bridge, stake, unstake, restake, lend, borrow, mint, redeem, farm yield, provide liquidity and more) with extensive customization options to perfectly match application design

### Key Features

* **Quick Integration**: Get started in minutes with just a few lines of code
* **Full Customization**: Customize colors, typography, shapes and every visual aspects
* **Multiple Display Modes**: Choose from default, drawer or compact display options
* **Theme System**: Comprehensive theming with 32+ themes and modes
* **Configurable Components**: Show, hide or customize any widget component as needed
* **Wallet Integration**: Integration smoothly with any wallet provider of your choice

<CardGroup cols={2}>
  <Card title="Try Out Now" icon="play" href="https://dapp.gluex.xyz">
    Experience DeFi at it's finest, directly in your browser. Just click and
    explore!
  </Card>

  <Card title="Integrate Now" icon="rocket" href="https://studio.gluex.xyz/playground">
    Embed GlueX Widget in minutes. Use the studio to customize, preview and
    generate the integration code
  </Card>
</CardGroup>


# Prebuilt Themes
Source: https://docs.gluex.xyz/build-with-gluex/widget/prebuilt-theme-store



The GlueX widget includes several prebuilt themes that provide a starting point for customization.
These themes demonstrate various configurations of colors, shapes and component styles, giving you an idea of how the widget can be styled to fit different design requirements

<Note>
  You can further customize these themes by modifying their properties or
  combining them with your own custom styles. This flexibility allows you to
  achieve the exact look and feel you desire for your application
</Note>

## Kelp

The Kelp theme draws inspiration from ocean depths and marine environments, featuring a sophisticated palette of deep teals and aquatic blues. This theme emphasizes natural, organic aesthetics with subtle transparency effects that create depth in your swap interface

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a0fe8106fc11c49dd58e7527c4bf72c4" alt="widget theme - kelp" width="832" height="918" data-path="images/products/widget/theme/kelp.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=88f124ef32738b8c9a5e1e5d0b95948d 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=89949f1fd9cd275e2ca6a67cfcfe4e25 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9fc47b0ee6cf4926e3b9e7a57f54103b 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f7ea1d24771250f0f0dba1643c492e79 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c3309becaefc79cece0c0f036af28140 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kelp.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c567e94fe6d0f99bb2459d4e03b64714 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#FFFFFF66",
        "review": "#17b4b4f2"
      },
      "background": {
        "paper": "#FFFFFFB3",
        "default": "#FFFFFFB3",
        "selected": "#17b4b459"
      },
      "text": {
        "primary": "#075A5A",
        "secondary": "#3F6870"
      },
      "divider": "#17b4b499"
    }
  }
}
```

## Sakura

The Sakura theme captures the delicate beauty of Japanese cherry blossoms, featuring soft pinks and warm whites. This theme emphasizes elegance and refinement, making DeFi trading feel more approachable and aesthetically pleasing

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1cb4f2deab32267713973e26fae195ad" alt="widget theme - sakura" width="832" height="918" data-path="images/products/widget/theme/sakura.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9e138e752f1638197a4870f2caa127ee 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=cfb5aa56f1935ed5780dbf0012073105 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d56a3c26dd043277af1c710c7417cdf8 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=16e1f986f4966ab0b9c90690a1836221 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e1e27b9d1e69d7b5c44a3f1e0ca1881f 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/sakura.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2d0081fef4df9aac4fc09c41631375a9 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#FFFFFF66",
        "review": "#ff2f7bf2"
      },
      "background": {
        "paper": "#FFFFFFB3",
        "default": "#FFFFFFB3",
        "selected": "#ff2f7b45"
      },
      "text": {
        "primary": "#D62F6C",
        "secondary": "#815B69"
      },
      "divider": "#ff2f7b70"
    }
  }
}
```

## Uranium

The Uranium theme embodies cutting-edge DeFi aesthetics with bold green-on-dark styling reminiscent of terminal interfaces and advanced trading platforms. This theme emphasizes technological sophistication and professional trading environments

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b02de91a1a48847bebee1813c3eef59a" alt="widget theme - uranium" width="832" height="918" data-path="images/products/widget/theme/uranium.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=3e163035ca1bb0a18e817b4069a2df47 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=10b05ab22e55f7c5251159e72cbf04a3 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=cadeeadf755a347a9dcb28dee241abb9 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=86cd431bd41cdddfa52f5b0cc2b900d1 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=3a29c8e4d01dfa5de8236f2c4a80fd92 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/uranium.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=acfeccb9ea115322a20203097914379d 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#121212B3",
        "review": "#225a00f2"
      },
      "background": {
        "paper": "#121212B3",
        "default": "#121212B3",
        "selected": "#225a005e"
      },
      "text": {
        "primary": "#55C500",
        "secondary": "#BFBFBF"
      },
      "divider": "#225a00f2"
    }
  }
}
```

## Neon Minimal

The Neon Minimal theme combines clean, minimal design principles with strategic bright accents. This theme creates a modern, sophisticated DeFi interface that feels both professional and contemporary

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=014c4b4364c1308b741abb782dde99bb" alt="widget theme - neon minimal" width="832" height="918" data-path="images/products/widget/theme/neon-minimal.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6910583e17eb344d0ddcbeaae3523649 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a763e49e9067a40233fbb16df752d143 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d025d7822c81befb04b059a4525f3e28 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0ac3cfdeb9ae6947372872985159f481 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=74df97dca8d2583951eb5fee930a1440 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/neon-minimal.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=ee9d3f9a0e1e98c784404b631e40182b 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#E1DEDE",
        "review": "#ED03F9"
      },
      "background": {
        "paper": "#0000000D",
        "default": "#E1DEDE",
        "selected": "#ED03F94D"
      },
      "text": {
        "primary": "#1a1a1a",
        "secondary": "#777777"
      },
      "divider": "#0000004a"
    }
  }
}
```

## Bitcoin

The Bitcoin theme reflects cryptocurrency's most recognizable color scheme with classic orange and white styling. This theme conveys trust, stability, and connection to Bitcoin's established brand recognition in the DeFi space

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=dc563b22d193b801e71d5df6fc8fc1c8" alt="widget theme - bitcoin" width="832" height="918" data-path="images/products/widget/theme/bitcoin.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1638b05066c72f1fdb86ae96c4a89ad2 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9f5373ec8cf75ecc89cbfcec082e95fd 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=717664101da5cd2ff73d97b1b5350f6d 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1c60d5838791c5ebaf6cea7bcc0ee8d2 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b177d3934aa38b4c3a1afa937931d867 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/bitcoin.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a35c4182a02492a7ddce33174c682082 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#FFFFFF",
        "review": "#F6921A"
      },
      "background": {
        "paper": "#FDFDFD",
        "default": "#FFFFFF",
        "selected": "#F8E0C4"
      },
      "text": {
        "primary": "#F6921A",
        "secondary": "#747474"
      },
      "divider": "#f6a84aa3"
    }
  }
}
```

## Punk

The Punk theme embraces bold, alternative aesthetics with striking purple and pink combinations. This theme breaks conventional DeFi design patterns while maintaining functionality and creating memorable user experiences

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=938e3ebe679772063f25e3d3e7750041" alt="widget theme - punk" width="832" height="918" data-path="images/products/widget/theme/punk.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2f25b5de510630255f611d16fde0f949 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=94051e5974b2c5644e0f9ef4875332b5 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b33d82223f909f7da78c5e8bc0b86a7f 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=22e989eb31a22bb1a8fb8d57c5a9752b 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d3c31decb9116abe62d0c077a27e58f1 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/punk.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=ac7b7787a168518564887dbc8defddc3 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#250B59B3",
        "review": "#5300c1f2"
      },
      "background": {
        "paper": "#250B59B3",
        "default": "#250B59B3",
        "selected": "#5300c1f2"
      },
      "text": {
        "primary": "#FF57D3",
        "secondary": "#AA6DAF"
      },
      "divider": "#74536b"
    }
  }
}
```

## Kinetiq

The Kinetiq theme focuses on movement and energy with a sophisticated dark theme and bright blue accents. This theme emphasizes modern technology and creates an interface that feels responsive and dynamic for active trading

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=cd95d9ed95db5cc0435d6e66ab4274f9" alt="widget theme - kinetiq" width="832" height="918" data-path="images/products/widget/theme/kinetiq.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6a702659b5965dc00c6f5b74bd3139f5 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c638d5708b16a75321158015ecfa965c 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0e7a30ce59512cc9e69e6745916a5db1 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e920452f6359ee8a6048df328af2be3e 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1f8c2912ef0a6566359eb13075a9e680 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/kinetiq.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9375fccd63a48b3c0d7b14c9fe955433 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#FFFFFF",
        "review": "#4ABFE2"
      },
      "background": {
        "paper": "#FFFFFF0D",
        "default": "#03161A",
        "selected": "#FFFFFF0D"
      },
      "text": {
        "primary": "#FFFFFF",
        "secondary": "#9FA4A7"
      },
      "divider": "#9FA4A766"
    }
  }
}
```

## Green

The Green theme provides a fresh, clean approach to DeFi interfaces with natural green accents on white backgrounds. This theme emphasizes growth, prosperity, and positive market movement while maintaining professional credibility

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=881e4c3a24f49a7dd18265289bf6a690" alt="widget theme - green" width="832" height="918" data-path="images/products/widget/theme/green.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=860c7b62d760988c50d653c0109d9c20 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0c0c2c98f9c395bda86cc9b9c140bde7 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e06a5513e99ab17d1dcfc02d2f1487a8 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=76aa3484e69394f4fc89234551536a86 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8b0c4b2f14d63ced6336670d422d5211 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/theme/green.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=85b36d748e66d7ff9de9328f92a56cca 2500w" data-optimize="true" data-opv="2" />

**Palette**

```json
{
  "theme": {
    "palette": {
      "primary": {
        "main": "#FFFFFF",
        "review": "#2ab213e6"
      },
      "background": {
        "paper": "#a19e9e33",
        "default": "#FFFFFF",
        "selected": "#2ab21354"
      },
      "text": {
        "primary": "#000000",
        "secondary": "#1b6b31"
      },
      "divider": "#1b6b31"
    }
  }
}
```


# Variants and Sub-Variants
Source: https://docs.gluex.xyz/build-with-gluex/widget/variants



GlueX widget comes in two variants - **compact** and **drawer**. Variants allow customization of the exterior of the widget, like the presenting as a drawer. There are also several subvariants that helps to customize the interior look and feel as well as functionality

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/variant.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bd3a99f486f3a7a83c7d04a279bd6243" data-path="images/products/widget/video/variant.webm" />

## Variant

Choose how the widget is presented on your page - a compact overlay for minimal footprint or a sliding drawer for a richer, side panel experience

| Property   | Type                  | Default   | Notes |
| ---------- | --------------------- | --------- | ----- |
| variant    | "compact" \| "drawer" | "compact" |       |
| subvariant | "router" \| "earn"    | "router"  |       |

<Note>
  Check out the [GlueX Studio](https://studio.gluex.xyz/playground) to play
  around with variants
</Note>

To use one of the variants, set the variant option in the widget configuration

```ts
const config = {
  // either of "compact" or "drawer"
  variant: "drawer",

  // either of "router" or "earn"
  subvariant: "router",
};
```

### Compact (Default)

The compact variant is ideal for scenarios where screen real estate is limited, such as smaller screens or integrated sections of your web application. It provides all essential functionalities in a condensed view, allowing easy embedding anywhere on your page

<img className="rounded" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=499805ef260765dedfab45187a4a3ef7" alt="widget variant - compact" width="1904" height="1332" data-path="images/products/widget/image/compact.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=aa5e0c72a6f421933c3cc0aeb4d2747d 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2cc4483d8a48475b8edda9649d1f2e79 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=eb381f0d727ff47d7f58efb7ad8d949b 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=cfe81037ba9fb857e57a4b95a02b3444 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a31c5ccd23afd18a9ad7d849f802b0f6 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/compact.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=5e3fd10b6577ddb1300b0aaae3c3e767 2500w" data-optimize="true" data-opv="2" />

To use the **compact** variant, set the variant option in the widget configuration

```ts
const config = {
  // .. rest of the configuration ..
  variant: "compact",
};
```

### Drawer

The drawer variant presents the widget as a sliding side panel, offering a richer user experience. It can be dynamically shown or hidden based on user interaction and maintains the same layout as the compact variant

<img className="rounded" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c275c727b65190a961a5706764089008" alt="widget variant - drawer" width="2034" height="1194" data-path="images/products/widget/image/drawer.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=849aba918301987d9942953aae3fb337 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=32a1c9d7e0b7bd172b1982b628c314a6 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b9fb2e7a019b6bbb11260a15f1c37acd 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c47f1504ce968b359a24edb5cef3de1b 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=eea3bbf0f85eb6a80f043630c20a7895 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/image/drawer.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=03236356ca7469bb549a2991d936c4ff 2500w" data-optimize="true" data-opv="2" />

To use the **drawer** variant, set the variant option in the widget configuration

```ts
const config = {
  // .. rest of the configuration ..
  variant: "drawer",
};
```

**How do we control the drawer?**

The drawer doesn’t have a pre built button to open and close it. To control the drawer you need to create and assign a `ref` to the widget

Here is an example of controlling the drawer with ref:

```typescript
export const WidgetPage = () => {
  const drawerRef = useRef<WidgetDrawer>(null);

  const toggleWidget = () => {
    drawerRef.current.toggleDrawer();
  };

  return (
    <>
      <button onClick={toggleWidget}>Open Widget</button>
      <GlueXWidget
        ref={drawerRef}
        config={{
          /* .. rest of the config .. */
          variant: "drawer",
        }}
      />
    </>
  );
};
```

## Sub Variant

Subvariants enable you to present different workflows or specialized functionalities to your users within the widget

To use a specific subvariant, simply set the subvariant option in your widget configuration

```typescript
const config = {
  variant: "compact",
  subvariant: "router",
};
```

### Router (Default)

The "router" (or default) subvariant provides the standard routing functionality in a compact view, allowing users to perform swaps or other core operations and is suitable for general purpose use

To use the **router** variant, set the subvariant option in the widget configuration

```ts
const config = {
  // .. rest of the configuration ..
  subvariant: "router",
};
```


# Wallet Management
Source: https://docs.gluex.xyz/build-with-gluex/widget/wallet-management



The widget comes with a built in wallet management interface, allowing developers or partners to use the widget as a standalone application.
However, when embedding the widget into an existing application, reusing the existing wallet management interface of that app makes the most sense

<video autoPlay muted loop playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/video/wallet-management.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c9191289fc367fb3e0172dce6823aedd" data-path="images/products/widget/video/wallet-management.webm" />

## Wagmi

The widget primarily uses [Wagmi](https://wagmi.sh/) internally and offers excellent support for all wagmi based libraries such as [RainbowKit](https://rainbowkit.com), [ReownAppKit](https://reown.com), [Dynamic](http://dynamic.xyz), etc.

If your application already handles wallet management using wagmi or wagmi based library the widget will automatically detect if it's wrapped in `WagmiProvider` and reuse your existing wallet management setup without any extra configuration

Here's an example of how to preconfigure basic wallet management using wagmi:

```typescript
import { GlueXWidget } from "@gluex/widget";

import { createClient } from "viem";
import { WagmiProvider, createConfig, http } from "wagmi";
import { mainnet } from "wagmi/chains";
import { injected } from "wagmi/connectors";

const wagmiConfig = createConfig({
  chains: [mainnet],
  connectors: [injected()],
  client({ chain }) {
    return createClient({ chain, transport: http() });
  },
});

export const WidgetPage = () => {
  return (
    <WagmiProvider config={wagmiConfig} reconnectOnMount>
      <GlueXWidget config={/*..*/} />
    </WagmiProvider>
  );
};
```

**Manage Chains**

It's crucial to keep your wagmi chains configuration synchronized with the widget's chain list.
This ensures all functionalities, such as switching chains, work correctly. You have two main approaches for this:

* **Manual Configuration**: Manually update both the widget and wagmi chain configurations to include all the chains you want to support in your application and the widget. Refer to the configuration page for more details on the widget’s chain configuration

* **Dynamic Updates**: Get all available chains supported by GlueX and dynamically update your wagmi configuration. The widget provides hooks to simplify this approach

```typescript
import React, { useRef } from "react";

import { useSyncWagmiConfig } from "@gluex/wallet-management";
import { injected } from "@wagmi/connectors";
import { createClient, http } from "viem";
import { mainnet } from "viem/chains";
import { createConfig, WagmiProvider, type Config } from "wagmi";

const connectors = [injected()];

export const WalletProvider: React.FC<React.PropsWithChildren> = ({
  children,
}) => {
  const wagmi = useRef<Config>();

  if (!wagmi.current) {
    wagmi.current = createConfig({
      chains: [mainnet],
      client({ chain }) {
        return createClient({ chain, transport: http() });
      },
      ssr: true,
    });
  }

  useSyncWagmiConfig(wagmi.current, connectors, [
    /*.. chains ..*/
  ]);

  return (
    <WagmiProvider config={wagmi.current} reconnectOnMount={false}>
      {children}
    </WagmiProvider>
  );
};
```

<Info>
  For a complete working example, check out our [example
  repository](https://github.com/gluexprotocol/gluex-examples)
</Info>

## Ethers.js

If you're using [Ethers.js](https://docs.ethers.org/v5) or any other alternative library in your project, you can still integrate with the widget. You'll need to convert your `Signer / Provider` objects to wagmi’s [injected connector](https://wagmi.sh/react/api/connectors/injected) before wrapping the widget with `WagmiProvider`


# Features
Source: https://docs.gluex.xyz/build-with-gluex/yield/features

Comprehensive capabilities of the GlueX Yield Router API for dilution-aware DeFi yield optimization

### Dilution-Aware APY Calculations

* **Historic APY**: Traditional backward-looking metric showing current liquidity provider earnings based on past fee generation and interest accrual. Useful for understanding baseline pool performance .

* **Diluted APY**: Forward-looking metric that calculates realistic yield after accounting for new capital dilution effects. Essential for large allocators and accurate yield projections, providing honest expectations rather than misleading historical snapshots.

* **Rewards APY**: Protocol incentive calculations that capture additional yield from governance tokens, liquidity mining programs, and ecosystem rewards. Separate from base lending/trading fees to provide clear yield component breakdown.

* **APY Slippage Quantification**: Measures the difference between Historic and Diluted APY, providing explicit visibility into yield reduction from capital deployment. Critical for risk assessment and allocation strategy optimization.

### Advanced Pool Analytics

* **Dual Lookup Architecture**: Query pools using either pool contract addresses or LP token addresses through optimized GSI indexes. Provides flexibility for different integration patterns and data source preferences without requiring protocol-specific knowledge.

* **Real-Time TVL Calculations**: Dynamic Total Value Locked computation that reflects current market conditions and recent deposit/withdrawal activity. Essential for accurate dilution calculations and pool health assessment.

* **Cross-Protocol Abstraction**: Unified interface across diverse DeFi protocols including lending platforms, DEXs, yield farms, and liquid staking derivatives. Abstracts complex protocol mechanics into standardized yield calculations.

* **Token Validation System**: Comprehensive input token validation ensuring provided addresses match pool underlying assets. Prevents invalid calculations and provides clear error messaging for debugging integration issues.

### Multi-Chain Infrastructure

* **17+ Blockchain Networks**: Native support across Ethereum, Base, Arbitrum, Polygon, Avalanche, BNB Smart Chain, Optimism, Gnosis, Mantle, Linea, Scroll, Taiko, Blast, Sonic, Berachain, Unichain, and HyperEVM with consistent API interfaces.

* **Chain-Specific Optimizations**: Tailored RPC handling, block time considerations, and gas optimization strategies for each network.

### High-Performance Infrastructure

* **Multi-Layer Caching**: TTL-based caching for pool data and APY calculations with configurable expiration times. Reduces response latency while maintaining data accuracy for dynamic DeFi markets.

* **Async Processing**: Concurrent execution of blockchain calls, database queries, and calculations across multiple chains. Parallel processing minimizes response times for complex multi-pool operations.

* **Intelligent State Aggregation**: Batched blockchain calls through multicall contracts to minimize RPC overhead. Supports standard calls, concentrated liquidity analysis, and reference price aggregation for efficient data retrieval.

* **Real-Time Monitoring**: Comprehensive metrics tracking including request volumes, cache efficiency, error rates, and system performance. Automated health checks ensure consistent service availability.

* **Error Management**: Structured error responses with detailed context and request tracing. Facilitates rapid debugging and provides clear feedback for integration issues.

### Developer-Centric Design

* **RESTful API Architecture**: Clean, predictable endpoints following REST principles with consistent request/response patterns. Standardized HTTP status codes and comprehensive error messaging for reliable integration.

* **Extensive Input Validation**: Multi-layer validation including Ethereum address formatting, chain support verification, token address validation, and parameter range checking. Provides clear feedback for invalid inputs with specific error guidance.

* **Structured Error Responses**: Consistent error format with success flags, descriptive messages, error type classification, operation step identification, and unique request IDs for debugging and support.

* **Multiple Programming Language Support**: Native examples and patterns for Python, JavaScript, and cURL with async/await patterns, error handling, and best practices for each language ecosystem.

* **Flexible Pool Resolution**: Support for both pool address and LP token address queries with automatic protocol detection and token relationship validation. Enables integration regardless of available data sources.

### Advanced Protocol Support

* **Protocol-Agnostic Framework**: Unified interface supporting lending protocols, automated market makers, yield farms, liquid staking, and synthetic assets. Abstracts protocol complexity while preserving calculation accuracy.

* **Dynamic Module Loading**: Runtime protocol module initialization based on pool requirements. Supports adding new protocols without service restarts or configuration changes.

* **State Management Sophistication**: Complex state dependency resolution with primary and dependent state calls. Handles protocol-specific requirements like oracle updates, fee calculations, and reward distributions.

* **Computation Cost Optimization**: Intelligent cost factor management and gas estimation for transaction-heavy protocols. Optimizes calculation accuracy while managing computational overhead.

## Learn More

For an in-depth understanding of how diluted APY works and why it's essential for accurate yield calculations, explore our comprehensive tutorial:

[All About Diluted APY](/tutorials/yield/all-about-diluted-apy) - Deep dive into dilution-aware yield calculations with practical examples and real-world scenarios.


# Overview
Source: https://docs.gluex.xyz/build-with-gluex/yield/overview

GlueX Yield Router API - Dilution-aware framework for DeFi yield optimization across 17+ blockchain networks

The yield router is a specialized API service that analyzes and calculates Annual Percentage Yield (APY) across different DeFi protocols and liquidity pools. The GlueX Yield Router API provides developers with accurate, dilution aware yield calculations that account for the real impact of capital deployment on returns

## Base URL

All API endpoint requests are made relative to the following base URL:

```http
https://yield-api.gluex.xyz
```

## Supported Networks

The API operates across 17 blockchain networks:

* ethereum
* base
* arbitrum
* polygon
* avalanche
* bnb
* optimism
* gnosis
* mantle
* linea
* scroll
* taiko
* blast
* sonic
* berachain
* unichain
* hyperevm

## API Endpoints

The service provides four core endpoints for yield analysis:

* **`/historical-apy`** - Calculate historical APY based on past performance
* **`/diluted-apy`** - Calculate APY accounting for new capital impact
* **`/rewards-apy`** - Calculate APY from protocol incentives and rewards
* **`/tvl`** - Get Total Value Locked for specific pools

## The Challenge with Traditional APY

Most DeFi platforms display Historic APY - a metric showing what current liquidity providers earn based on past performance. This approach has significant limitations:

* **Backward-looking**: Reflects past earnings, not future potential
* **Static assumptions**: Assumes fee generation remains constant regardless of pool size changes
* **Dilution blindness**: Ignores how new capital affects existing returns
* **Misleading for large deposits**: Particularly problematic when deposit size is significant relative to pool size

Historic APY answers "What are current participants earning?" rather than "What will I earn if I deposit funds?"

## Diluted APY Solution

The API introduces Diluted APY - a forward-looking metric that calculates realistic yield projections after accounting for capital dilution.

**Historic APY Formula:**
Historic APY = (Daily Fees × 365) / Current TVL

**Diluted APY Formula:**
Diluted APY = (Daily Fees × 365) / (Current TVL + New Liquidity)

This approach provides realistic projections that account for how new capital shares existing fee pools, considers the specific amount being deposited, and quantifies "APY slippage" from dilution effects.

## Getting Started

The API is designed for developers who need accurate yield calculations in their applications. Whether building portfolio management tools, yield aggregators, or institutional dashboards, the service provides the foundation for informed DeFi yield decisions.

Begin with the installation guide to set up your environment and start making API calls within minutes.

## Next Steps

* **[Explore Features](/build-with-gluex/yield/features)**: Dive deep into the comprehensive capabilities and technical features of the Yield Router API
* **[All About Diluted APY](/tutorials/yield/all-about-diluted-apy)**: Understand the mathematics and practical applications of diluted APY calculations

The GlueX Yield Router API represents the next evolution in DeFi yield optimization—moving beyond misleading metrics to provide actionable, dilution-aware intelligence for sophisticated capital allocation strategies.


# Widget Changelog
Source: https://docs.gluex.xyz/changelog/widget



<Update label="June 2025" description="">
  ### Breaking Changes

  * **Released v2** of the widget

  <img className="rounded" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fed39689c5dd52e8b35d113030de2e47" alt="GlueX Widget" width="2026" height="1432" data-path="images/products/widget/widget.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=4c236fd072392a3494818721a49cf3ab 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6403b1f999679c77f7b1720f57461df2 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=df7729bdee19bbd0048476ba86e69819 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6972cfa5958dcbcb5561f35df341843f 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9886cfabf408b24a33f5925c4b0b88f0 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/widget/widget.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=49ce78e888b5e2fca51f46d9fd55d5d2 2500w" data-optimize="true" data-opv="2" />

  ### New Features

  * Added EIP7702 support
  * Introduced `module filters` enabling filter references based on available liquidity modules per chain
  * Integrated Yield API to accurately visualize the historical and diluted yield of assets
  * Introduced new widget themes - `Sophon`, `Sakura`, `Kelp`, `Uranium`, `Bitcoin`, `Punk`, `Neon Minimal`
  * Introduced customizable components (initially customizable for Swap completion page, Transaction details, Token price and amount display, Percentage input buttons, Token selection)
  * Introduced a new way to track and show active transactions

  ## Improvements

  * Set up Rollup bundling for widget, SDK and wallets packages
  * Enhanced playground color controls (alpha support, custom inputs)
  * Updated information display for network costs and partner fees
  * Removed default hover and ripple effects

  ### Bug Fixes

  * Fixed high value loss warning display on the main page
  * Added HyperEVM native token support in the zero address utility
  * Ensured tokens gracefully fallback to an empty array when none are available
  * Resolved minor playground issues and build errors
  * Restricted “Powered by” component size to prevent layout breakage
  * Fixed token list skeleton and scrolling quirks
  * Addressed type generation and build errors in widget
  * Fixed input and receive amount font size, token overflow and "no liquidity module" issues

  ### Documentation

  * Detailed documentation added for new sdk, widget and portal
  * Added React and Rainbowkit examples
  * Refreshed internal changelogs and pre publish notes

  ### Chores

  * Added a surplus fee flag parameter (feature not enabled)
  * Updated project dependencies to latest
  * Introduced copy icons, unknown token avatar and transition support
  * Set up changeset management for automatic migrations
  * Updated notice and changelog files
</Update>

<Update label="May 2025" description="">
  ### New Features

  * Implemented a toggleable drawer component

  ### Bug Fixes

  * Fixed decimal input handling in amount fields
  * Improved font loading logic and associated error handling
  * Minor appearance fixes across the UI
  * Corrected external wallet management flow
  * Adjusted drawer variant defaults and fixed drawer height
  * Refined appearance control logic and theme handling
  * Updated skeleton component styling
  * Tweaked layout and color control behaviors

  ### Chores

  * Added ignore loader and updated configuration
  * Refactored widget layout
</Update>

<Update label="April 2025" description="">
  ### New Features

  * Show effective output amount in the receive box
  * Added support for partial wallet management

  ### Improvements

  * Format input amounts with commas for better readability
  * Added token balance checks

  ### Bug Fixes

  * Improved general error handlers

  ### Chores

  * Added notice and patch files
</Update>

<Update label="March 2025" description="">
  ### New Features

  * Introduced dynamic surge protection with configurable thresholds (default 5% threshold and trade reversal)
  * Added gas limit estimation and automatic retry on quote reverts
  * Added block and transaction explorer buttons next to transaction hashes
  * Configurable ChainRegistry for custom chain metadata

  ### Improvements

  * Display effective amount in the receive box
  * Updated network cost and partner fee information displays

  ### Bug Fixes

  * Fixed type errors across sdk, widget and wallets
  * Enhanced transaction error handling and UI events
  * Corrected balance loading and refresh logic
  * Removed outdated “insufficient funds” warnings and stopped “no route” auto refetching

  ### Performance Improvements

  * Improved revert handling performance
  * Added caching for exchange rates and estimate calls
  * Disabled auto refresh when no routes are available

  ### Chores

  * Refactored codebase to remove some annotations
  * Updated core dependency to latest stable release
</Update>

<Update label="February 2025" description="">
  ### New Features

  * Introduced exchange rates, gas and fees API endpoints
  * Added support for transaction receipts

  ### Bug Fixes

  * Improved fee split logic to handle rounding discrepancies
  * Enhanced error messages and handling
  * Retry logic for API failure scenarios
  * Patched Exchange rates API when price value is not available

  ### Performance Improvements

  * 2 minute caching layer for exchange rates
  * Better estimate and visual update handling

  ### Removals

  * Removed unused helper functions
  * Cleaned out unused code for RPC fallback logic

  ### Chores

  * Configuration updates
  * Updated third party dependencies to latest minor releases
</Update>


# How does it work
Source: https://docs.gluex.xyz/documentation/about/how-gluex-works



## GlueX Modules

At the core of GlueX is the concept of "GlueX modules", which act as the essential building blocks for integrating various components needed to interact with decetralized financial applications. These modules are continuously developed and refined by a dedicated group of developers, known as "gluers" who participate in focused weekly development sessions called "glueing sprints". GlueX modules can be reused across blockchains and intent auctions. Hence, a module only needs to be onboarded once. The process is designed to ensure adaptability and continuous improvement. All this while simplifying the development process and improving performance considerably!

Once completed, these modules are compiled into comprehensive SDKs that power a suite of GlueX services, including Router, Exchange Rates, Solve, Yield, Swidge and Bridge APIs. This modular architecture allows GlueX to adapt quickly to the demands of an evolving blockchain ecosystem while maintaining a focus on delivering reliable and efficient services

## The GlueX Workflow: From Intent to Settlement

In the GlueX ecosystem, a entity’s intent such as executing a swap or any other financial transaction flows seamlessly through four core modules. Each module plays a critical role in ensuring the entire process is executed efficiently and securely. The following section illustrates how these modules work together to fulfill the entity's request

### Originator module:

The process begins when the Originator module receives an intent from an entity's application. This module abstracts the settlement protocol by collecting all the necessary details, such as the tokens to be swapped, the source and destination blockchains, and protocol specific metadata. It acts as the gateway for the entity’s request into the GlueX ecosystem, converting it into a standardized format that can be processed by the subsequent modules

### Intent module:

Once the Originator module passes the data to the Intent module, the data is abstracted into a standardized GlueX intent object. This abstraction ensures that the entity’s request can be understood and processed in a unified way across all modules, irrespective of the originating protocol. The Intent module is responsible for ensuring that complex trade logic, such as routing, multiple order types and cross chain transactions, are handled seamlessly while preserving the entity’s original intent across all steps

### Blockchain module:

The Blockchain module is where GlueX adapts to the specifics of different blockchain environments. It abstracts the complexities of interacting with various blockchains, providing a unified interface for all supported networks. It handles the complexities of each blockchain’s metadata, native tokens, operational nuances and transaction requirements, ensuring seamless compatibility across multiple networks

### Liquidity module:

The Liquidity module abstracts the process of sourcing liquidity on each blockchain. It identifies and accesses the relevant liquidity of LPs across different protocols. The module abstracts the path to liquidity by considering factors such as liquidity pool availability, fees, and slippage, ensuring that the swap is executed efficiently

Once the appropriate liquidity sources are identified, the process flows back through the Blockchain module, where the necessary blockchain details are finalized. The Intent module ensures that the data remains consistent, and the Originator module completes the settlement by executing the transaction on-chain.


# Partnership Opportunities
Source: https://docs.gluex.xyz/documentation/about/partnership-opportunities

Explore partnership opportunities with GlueX

## Official Partnerships

For any business partnership discussions, you can reach out to the following team members:

<Columns cols={2}>
  <Card title="Advit Mahale">
    **Head of Business Development**

    <br />

    <div className="flex flex-col gap-2.5">
      <span className="">
        <Icon icon="telegram" /> [@advit04](https://t.me/advit04)
      </span>

      <span className="">
        <Icon icon="twitter" /> [@0xadvit](https://x.com/0xadvit)
      </span>

      <span className="">
        <Icon icon="mail" /> [](mailto:)
      </span>
    </div>
  </Card>
</Columns>


# Powered by GlueX
Source: https://docs.gluex.xyz/documentation/about/powered-by

List of projects powered by GlueX

GlueX is at the heart of many innovative DeFi products. Below is a curated selection of live integrations:

## Trading Platforms

<CardGroup cols={3}>
  <Card title="CowSwap" href="https://cow.fi/" />

  <Card title="1inch" href="https://1inch.io/" />

  <Card title="Definitive.fi" href="https://definitive.fi/" />
</CardGroup>

## DeFi Protocols

<CardGroup cols={3}>
  <Card title="LIDO" href="https://lido.fi/" />

  <Card title="Brahma.fi" href="https://brahma.fi/" />

  <Card title="Valantis" href="https://valantis.io/" />

  <Card title="HypurrFi" href="https://hypurr.fi/" />

  <Card title="Hyperwave" href="https://app.hyperwavefi.xyz/assets/hwhlp" />

  <Card title="Hyperstable" href="https://app.hyperstable.xyz/" />

  <Card title="Sentiment" href="https://sentiment.xyz/" />
</CardGroup>

## Web3 Infrastructure

<CardGroup cols={2}>
  <Card title="Biconomy" href="https://biconomy.io/" />

  <Card title="Pyth Network" href="https://pyth.network/" />
</CardGroup>

## Wallets

<CardGroup>
  <Card title="Okto Wallet" href="https://okto.tech/" />
</CardGroup>

## Power Users

The realiability of GlueX also makes it a go-to for solo traders and arbitrageurs who require highly-performant solutions.


# What can I build on GlueX
Source: https://docs.gluex.xyz/documentation/about/what-can-I-build-on-gluex



GlueX powers a wide variety of web3 applications. Whether you're building a product where trading is central like an exchange or adding seamless token swaps to an app where trading is just one feature, GlueX makes it easy to plug in liquidity.

<Info>
  All of the use cases below can be implemented via our drop in widget or fully
  programmatic API and SDK. Choose the integration style that best fits your
  architecture!
</Info>

## Exchanges

Build fully featured, high performance trading platforms (centralized, decentralized or hybrid) without reinventing the routing layer. GlueX handles order aggregation across DEXs and AMMs, advanced pathfinding for best price, slippage protection and onchain settlement. Out of the box support for market orders, custom fee tiers and pegged orders lets you launch a complete exchange in days, not months

## Marketplaces

Whether you’re selling NFTs, ingame items or tokenized real world assets, add instant payment routing so buyers can pay in any token and sellers receive their preferred asset. GlueX transparently swaps between payment and payout tokens, hides gas complexity behind a single UX, and ensures you capture volume through optimized routing

## Wallets

Integrate in app swaps so your users never leave their wallet interface. With a single API call you can quote, approve and execute trades, all in a gas efficient manner. Provide one click token bridging, auto routing across chains and personalized slippage settings. Ideal for custodial, non custodial and browser extension wallets

## DeFi Protocols

Enhance lending, borrowing, leverage and yield farming protocols by plugging in best price swap functionality. Use GlueX as the settlement layer for collateral swaps, liquidation auctions, or protocol rebalancing. Combine with your own smart contract logic for composable, gas-optimized flows

## Social & Consumer Apps

Add token tipping, peer to peer swaps, or community lotteries to social networks, streaming platforms or content apps. GlueX’s simple embeddable components handle quotes, approvals and execution so you can focus on UX, engagement and community features

## AI Agents

Power autonomous trading bots and onchain AI agents that monitor market conditions and execute strategies in real time. GlueX’s low latency quote API and smart routing ensure your agents always get the best fill, whether they’re arbitraging across chains or implementing market making strategies

## DeFi Automation

Create automated and conditional flows such as recurring buys, portfolio rebalances, stop loss triggers, and more. Combine our SDK with your task scheduler to define events like “if ETH drops below \$1,900, swap USDC to ETH” Automate complex strategies without maintaining your own routing infrastructure

<Info>
  Check out our [full set of tutorials](/tutorials) for step by step guides on
  each use case above
</Info>


# What is GlueX
Source: https://docs.gluex.xyz/documentation/about/what-is-gluex



GlueX Protocol is an abstraction framework designed to uniformly represent blockchains, intents, intent originators and liquidity providers for deploying high performance, universal smart order routing algorithms. Tap into aggregated liquidity from **200+ sources** across **17 EVM chains**, with the most efficient trade execution engine in DeFi. Our suite of APIs has processed over **106 million** order flows and **\$10 billion+** in volume from more than **1 million** traders on apps like CowSwap, 1inch, Biconomy, ProjectX, Okto and more

<img className="hidden dark:block" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6ecaf09abca8bd3e4ea6b9a7f943c7a1" alt="GlueX Widget" width="1200" height="675" data-path="images/hero/stats-dark.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=123eaf462d489baa56f41612957802b7 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bb77b9b9765c662f3c8d76c574ded04d 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=ac9332e41986c3a1e0286b8c7f9e2c97 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b0e69ba571658fbf7f69294507f8c33c 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=7590cba4673d7b370ef61a132a360ab1 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-dark.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c4c1371d1ca89e1fcafb6ce37503b840 2500w" data-optimize="true" data-opv="2" />

<img className="block dark:hidden" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1c94e6ea3d09928342677ce594236adb" alt="GlueX Widget" width="1200" height="675" data-path="images/hero/stats-light.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8fad963aff69f8e72803b192c0456b93 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1d84a436c9e2bfd83e3514218ea922f1 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a5ea38acef49b5d61a737ae8d837034a 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6c211a7644b6e0a65ae1eb4fb148c533 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=107178d5206e0661d4ac73c522337b19 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/stats-light.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9042efb4591fe40e154bbb26a27e37d6 2500w" data-optimize="true" data-opv="2" />

## Why GlueX?

In the rapidly evolving landscape of DeFi, GlueX stands out as a reliable, efficient and secure partner for your DeFi needs.
Our proven track record and robust infrastructure speak for themselves:

* **\$10B+ in lifetime trade volume** optimized since 2022
* **\$6M+ in daily trade volume** processed
* **100k+ wallets served**
* **100+ liquidity sources** integrated across **17 chains**
* Trusted by [**20+ partners**](/documentation/about/powered-by) including top DeFi platforms

## How GlueX Delivers Value

### Advanced Order Routing

Our proprietary algorithm continually benchmarks routes across chains to deliver the best output. Traders get transparent pricing, protected slippage and access to hidden liquidity

### Comprehensive Liquidity Integration

Seamlessly aggregate onchain pools, off chain RFQ venues and bridge services. GlueX continuously integrates new sources, so you always have best in market coverage

### Robust APIs for Growth

Whether you’re a bootstrap startup or an enterprise, our endpoints and SDKs scale with you. Authenticate once, then query quotes, place orders and fetch data programmatically

### Versatile Product Suite

* **Router**: Our core smart order routing engine aggregates liquidity from 200+ sources, splits large trades across multiple paths and picks the optimal route to minimize slippage and fees

* **Yield**: A comprehensive pools data API that surfaces realtime metrics for liquidity pools and vaults across all integrated protocols. Fetch TVL, current APY (including compound interest projections), underlying token weights and performance perfect for dashboards, analytics tools or automated strategy engines

* **Realtime Token Price**: Lightning fast price feeds for 500k+ tokens on 17 chains, to power everything from portfolio trackers to onchain oracles

* **Zap**: One step liquidity provisioning - deposit a token (split, swap and add balanced positions) into pools and vaults, ideal for unlocking yield without manual token routing or multiple transactions

* **Stake**: Delegate or lock up tokens across multiple staking protocols with a single API call

* **Lend**: Programmatic access to lending and borrowing markets to supply or borrow assets in one transaction

### Secure & Audited Infrastructure

GlueX smart contracts and off chain services undergo rigorous security reviews and audits. All transactions settle on-chain, ensuring transparency and user custody

### Responsive Collaboration

Our team partners closely with integrators providing custom routing logic, SLAs and co-marketing support to accelerate your go-to-market

## Integration Options

Choose the path that fits your needs:

<Columns cols={2}>
  <Card img="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=262df6688e0d5171366708fee31444e9" title="Widget" href="/build-with-gluex/widget/overview" width="1200" height="675" data-path="images/hero/widget-dark.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8c2ac9a5c2b6d9dc3a2ff62462656f42 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2ea3f1eaee6c80e30293c8146f69c0fa 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0f7ce78bc1885ccdc1bc1edfa917bdf5 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d6c33dc9c55268a0bdadd6d41857ae46 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=7f75e2709a73f26fec96a05342fd5521 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/widget-dark.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=171adeae11ea4067ef2f2a8d3b288712 2500w" data-optimize="true" data-opv="2">
    UI components for effortless DeFi integration
  </Card>

  <Card img="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bace964d01ee2edbec5a2450acb4c78f" title="API and SDK" href="/api-reference/about/overview" width="1200" height="675" data-path="images/hero/api-and-sdk-dark.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=14fe213bb1eb6584b08c87fbcb4d40d9 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bb636b861d704802941e4a360a92128d 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=792024e95965409605ab71f0e43e0b71 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d92a0b8a02d82ec468e06679b1be5b9a 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=10d6f40ba631dfc18aedad7ffaf79a0d 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/api-and-sdk-dark.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d6ce324e605c86174144c564fd6ad27e 2500w" data-optimize="true" data-opv="2">
    API suite for efficient and secure onchain interaction
  </Card>
</Columns>

## Getting Started

1. **Apply** for your [Integrator ID](https://portal.gluex.xyz)
2. **Choose** Widget or API & SDK integration
3. **Launch** your application

<Info>
  New to smart order routing? Visit our [Getting Started](/tutorials) guide for
  step by step tutorials!
</Info>


# Why build with GlueX Protocol
Source: https://docs.gluex.xyz/documentation/about/why-build-with-gluex



Building with GlueX empowers developers and protocols to seamlessly integrate decentralized financial applications with a modular, scalable and interoperable framework. Whether you're a application developer, a DeFi protocol, an infrastructure provider or a liquidity provider, GlueX simplifies complex integrations and unlocks powerful capabilities to expand your ecosystem

## What GlueX brings to the table

### Simplified Integration and Development

GlueX eliminates the complexity of integrating multiple protocols and blockchains, allowing developers to focus on building innovative solutions

* **Focused Development**: Ready to use interfaces and our growing collection of modules streamlines interaction with protocols, blockchains and liquidity sources, reducing the need for custom development. This allows you to focus on the core logic of your product, instead of searching for the right sources
* **Accelerated Development**: Prebuilt and thoroughly tested components shorten development timelines and speed up the release of new features
* **Customizable Workflows**: Developers can tailor GlueX’s architecture to fit their unique needs, avoiding unnecessary configurations
* **Low Maintenance Overhead**: GlueX handles updates for supported protocols and blockchains, minimizing the need for ongoing maintenance

### Interoperability and Scalability

GlueX ensures seamless communication across diverse protocols and blockchains while enabling projects to scale effortlessly

* **Chain and Protocol Interoperability**: GlueX abstracts differences across protocols and blockchains, enabling smooth execution of crosschain transactions
* **Standardized Communication**: Data formats are unified across all interactions, ensuring compatibility between protocols and blockchains
* **Future Ready**: GlueX can easily integrate new protocols and blockchains, adapting to the evolving DeFi landscape
* **Support for Ecosystem Growth**: Applications built with GlueX can plug into an expanding ecosystem, keeping pace with emerging trends in decentralized finance

### Optimized Performance and Efficiency

GlueX ensures every transaction is executed efficiently, balancing cost-effectiveness with high performance

* **Streamlined Processes**: GlueX’s abstraction layers remove unnecessary steps, ensuring fast and smooth execution of transactions
* **Builtin Advanced Logic**: Complex trade scenarios, such as routing, multi-order execution and cross chain swaps are handled seamlessly without additional development

### Security and Reliability

GlueX offers a secure and dependable foundation, ensuring that every transaction is protected and executed reliably.

* **High Security Standards**: GlueX incorporates safeguards to protect against vulnerabilities and unauthorized access
* **Proven Stability**: Components are rigorously tested to ensure they operate reliably under a variety of conditions, with over 10B+ USD flowing settled though our framework
* **Compliance Friendly**: GlueX simplifies adherence to industry standards and regulatory requirements, ensuring compatibility with DeFi protocols


# Best Practices
Source: https://docs.gluex.xyz/documentation/get-started/best-practice



To maximize the performance, security and reliability of your application when integrating with GlueX, we recommend adhering to the following best practices

## Key Management and Security

Secure handling of your API keys is paramount to protect your application and users

<AccordionGroup>
  <Accordion title="Never Hardcode API Keys">
    Store your API keys in environment variables or a secure secret management
    service (eg: AWS Secrets Manager, Google Cloud Secret Manager, HashiCorp
    Vault, Kubernetes Secrets). Avoid committing them directly into your source
    code, especially in public repositories
  </Accordion>

  <Accordion title="Use Dedicated Keys">
    Always use separate API keys for development, staging and production
    environments. This limits the blast radius in case a key is compromised
  </Accordion>

  <Accordion title="Restrict Access (Principle of Least Privilege)">
    Grant access to API keys only to the necessary applications and personnel.
    Utilize the IP whitelisting or domain whitelisting feature for your API keys
    to restrict where your keys can be used
  </Accordion>

  <Accordion title="Rotate Keys Periodically">
    Implement a routine for periodically rotating your API keys to minimize the
    risk associated with long lived credentials
  </Accordion>

  <Accordion title="Monitor API Key Usage">
    Keep an eye on your API key usage statistics in the GlueX portal to detect
    any unusual activity or surges
  </Accordion>
</AccordionGroup>

## Error Handling and Resiliency

Building a resilient application means anticipating and gracefully handling potential failures

<AccordionGroup>
  <Accordion title="Error Handling">
    Always check the response for errors from the API calls. Do not assume
    success. Log error codes and messages for debugging
  </Accordion>

  <Accordion title="Retry Logic with Exponential Backoff">
    For transient network issues or rate limit (`429 Too Many Requests`) errors,
    implement retry logic. Use an exponential backoff strategy (eg: wait 1s,
    then 2s, then 4s, etc, with a maximum number of retries) to avoid
    overwhelming the API and allow it to recover
  </Accordion>

  <Accordion title="Handle Insufficient Tokens/Approvals">
    For transaction-related APIs (like Router), ensure your application checks
    for sufficient user token balances and necessary ERC20 token approvals
    *before* attempting a transaction. Provide clear feedback to the user if
    these prerequisites are not met
  </Accordion>

  <Accordion title="User Friendly Error Messages">
    Translate technical API error messages into clear, actionable and user
    friendly messages for your end users
  </Accordion>

  <Accordion title="Fallback Mechanisms">
    Consider implementing fallback mechanisms for critical operations if the API
    is temporarily unavailable or returns an unexpected error
  </Accordion>
</AccordionGroup>

## Performance and Efficiency

Optimize your integration for speed and resource utilization

<AccordionGroup>
  <Accordion title="Batch Requests">
    For APIs that support it (eg: Exchange Rates API allows up to 25 pairs per
    call), batch multiple requests into a single API call to reduce network
    overhead and improve efficiency
  </Accordion>

  <Accordion title="Cache Data Strategically">
    Cache static or infrequently changing data (eg: supported chains, token
    lists) on your application's side to reduce redundant API calls. Implement
    appropriate cache invalidation strategies
  </Accordion>

  <Accordion title="Optimize API Calls">
    Only request the data you need. If an API allows for partial responses or
    specific field selection, use it to minimize data transfer size
  </Accordion>

  <Accordion title="Preflight Checks for Transactions">
    Before prompting a user to sign a transaction, use the price's simulation
    capabilities to estimate gas, check for potential errors (eg: slippage,
    insufficient liquidity), and provide an accurate preview to the user
  </Accordion>
</AccordionGroup>

## User Experience and Transparency

A good user experience builds trust and encourages adoption

<AccordionGroup>
  <Accordion title="Provide Clear Transaction Details">
    For any operation involving onchain transactions, clearly display all
    relevant details to the user before they confirm: input/output tokens,
    amounts, estimated gas fees, estimated slippage and the destination
    chain/address
  </Accordion>

  <Accordion title="Realtime Feedback">
    Offer realtime feedback on transaction status (pending, confirmed, failed)
    and update UI elements accordingly
  </Accordion>

  <Accordion title="Gas Fee Transparency">
    Always inform users about estimated gas fees upfront. Allow users to
    potentially adjust gas settings if your application supports it
  </Accordion>

  <Accordion title="Slippage Control">
    If using swap or routing features, provide users with the option to set
    their preferred slippage tolerance, and clearly warn them if the estimated
    slippage is high
  </Accordion>

  <Accordion title="Explain Complexities">
    For multi-step operations or novel DeFi interactions (eg: vault entries,
    staking), provide clear explanations or tooltips to help users understand
    what's happening
  </Accordion>
</AccordionGroup>

## Security

Beyond API key security, ensure your overall application adheres to security best practices

<AccordionGroup>
  <Accordion title="Input Validation">
    Always validate and sanitize all user inputs before sending them to GlueX
    APIs. This helps prevent injection attacks and unexpected behavior
  </Accordion>

  <Accordion title="Protect Private Keys">
    If your application handles private keys (eg: backend signing), ensure they
    are stored and used in a highly secure, isolated environment (eg: Hardware
    Security Module (HSM), secure enclaves)
  </Accordion>

  <Accordion title="Regular Security Audits">
    Conduct regular security audits and penetration testing of your application,
    especially before major releases or after significant architectural changes
  </Accordion>

  <Accordion title="Stay Updated">
    Keep your GlueX SDKs, libraries and dependencies up to date to benefit from
    the latest features, performance improvements and security patches
  </Accordion>

  <Accordion title="Compliance">
    Understand and adhere to any relevant regulatory compliance requirements
    (eg: KYC/AML for specific use cases) that might apply to your application's
    operations
  </Accordion>
</AccordionGroup>

## Monitoring and Logging

Robust monitoring and logging are your eyes and ears in production

<AccordionGroup>
  <Accordion title="Logging">
    Log all the requests and responses, including timings, status codes and
    relevant request/response bodies. This is invaluable for debugging and post
    mortem analysis
  </Accordion>

  <Accordion title="Structured Logging">
    Use structured logging (eg: JSON logs) for easier parsing and analysis by
    automated tools
  </Accordion>

  <Accordion title="Alerting">
    Set up alerts for critical metrics:

    * High error rates (eg: 5xx responses, transaction failures)
    * API rate limit nearly exhausted
    * Unexpected latency spikes
    * Discrepancies in data (eg: prices, balances)
  </Accordion>
</AccordionGroup>

## Deployment

Streamline your development process for efficiency and reliability

<AccordionGroup>
  <Accordion title="Automated Testing">
    Implement unit, integration and end to end tests for your integration to
    catch regressions early and ensure correct functionality
  </Accordion>

  <Accordion title="CI/CD Pipelines">
    Utilize Continuous Integration/Continuous Deployment pipelines to automate
    testing, building and deployment, ensuring consistent and reliable releases
  </Accordion>

  <Accordion title="Staging Environment">
    Maintain a dedicated staging environment that mirrors your production setup
    for final testing before deployment to live users
  </Accordion>
</AccordionGroup>


# Go Live Checklist
Source: https://docs.gluex.xyz/documentation/get-started/go-live



# Preparing for Production

Congratulations on building your DeFi application with GlueX!

Before you launch your integration to a live audience, it's essential to follow a robust go live process. This checklist will guide you through the critical steps to ensure your application is secure, performant and ready for real world usage

### Review Integrator Settings

Before going live, verify all your GlueX account settings are configured for a production environment. This involves more than just a quick glance

* **Access the Dashboard**: Log in to the [GlueX developer portal](http://portal.gluex.xyz/)
* **Key Management**: Generate new and dedicated API keys for your production environment distinct from your development/testing keys and should be treated as highly sensitive
* **Whitelist Domains**: Ensure your production server's domain or IP addresses are whitelisted for the API key (defaults to all domains)
* **Billing and Payment**: Ensure your payment information is up to date and your chosen plan aligns with your expected production usage to prevent service interruptions

### Secure the Keys

Protecting your production API keys is paramount to your application's security

* **Environment Variables**: Never hardcode API keys directly into your codebase. Use environment variables (eg: `GLUEX_API_KEY`) that are loaded securely at runtime
* **Secret Management**: For enhanced security, consider using dedicated secret management services to store and retrieve your production keys
* **Restrict Access**: Implement strict access controls, ensuring only authorized personnel and your production servers/services can access these keys
* **Test Authentication**: After swapping to live keys, perform a basic API call to confirm successful authentication

### Implement Information Capture

Comprehensive logging and monitoring are crucial for diagnosing issues, tracking performance, and understanding user behavior in a live environment

* **Detailed Logging**: Implement thorough logging for all requests and responses within your application (include request parameters, full response data, timestamps and any error messages for better debugging)
* **Error Reporting**: Configure an error tracking system to automatically capture and alert you to any unhandled exceptions

### Finalise the Plan

Choosing the correct GlueX plan ensures you have the necessary capacity and features for your live application

* **Estimate Usage**: Based on your testing and projected user base, accurately estimate your anticipated API call volume, transaction volume and feature requirements
* **Review Pricing Tiers**: Familiarize yourself with GlueX's current pricing plans and their associated benefits (rate limits, dedicated support, advanced features)
* **Select Appropriate Plan**: Choose the plan that best matches your estimated usage and business needs

### Understand Rate Limits

To maintain service stability, GlueX implements API rate limits. Understanding and planning for these is vital for uninterrupted operation.

* **Review Limit Documentation**: Check the API documentation for the specific rate limits associated with your chosen production plan
* **Implement Retry Logic**: Integrate retry mechanisms with exponential backoff to gracefully handles `429 Too Many Requests` errors by retrying calls after increasing intervals
* **Monitor Usage**: Utilize the portal to track your current API usage against your rate limits

### Rigorous Testing

The final and most critical step is to perform comprehensive testing in an environment that mirrors your production setup as closely as possible

* **Staging Environment**: Deploy your application to a staging environment that uses your API keys and infrastructure, but is isolated from real users

* **End to End Testing**: Conduct thorough end to end tests covering all critical user flows:

  * Happy Paths: Ensure all core functionalities (swaps, bridging, lending, etc) work as expected
  * Edge Cases: Test with minimum, maximum values, unsupported tokens, low liquidity scenarios and various network conditions
  * Error Handling: Verify that your application gracefully handles API errors, network issues and transaction failures

* **Load and Stress Testing**: Simulate peak user traffic to ensure your application and its integration can handle the expected load without performance degradation or errors

* **Monitor Testing**: Verify that your logging, monitoring, and alerting systems are functioning correctly during these tests

* **Rollback Plan**: Have a clear rollback strategy in place in case any unforeseen issues arise during or after launch

### Drop Us a Line!

We're here to support your success. Let us know when you're going live and how we can help!

* **Reachout**: Reach out to our partnership team or your dedicated account manager to inform us of your upcoming launch. This allows us to provide better support and potentially monitor your integration more closely during critical periods

* **Share Your Success**: We love to see what our partners build! Share your live application with us, and we might feature it on our channels


# Integrating using AI
Source: https://docs.gluex.xyz/documentation/get-started/integrate-ai



AI is a powerful tool for developers and AI can supercharge your GlueX integrations whether you’re scaffolding a new project or generating code snippets on the fly. Explore the various methods below to incorporate GlueX into your AI assisted coding environment

## Cursor, Copilot, Windsurf

TBD

## V0, Lovable

TBD

## Enhancing AI with Contextual Documentation

To maximize the effectiveness of your AI tools (Cursor, Copilot, Windsurf, V0, Lovable) when working with GlueX, it's essential to provide them with specific contextual documentation about the integration.

This guide details how you can effectively supply this crucial information

<AccordionGroup>
  <Accordion title="Full Documentation Bundle">
    GlueX supports both the [llms.txt](https://docs.gluex.xyz/llms.txt) and [llms-full.txt](https://docs.gluex.xyz/llms-full.txt), read about those [here](https://github.com/AnswerDotAI/llms-txt). This feature means you can easily integrate GlueX documentation into **LLM** that supports external context files or even into your **custom AI tooling and scripts**

    ### How to Use These Files for Context:

    1. **Understand the Files:**

       * **`llms.txt`**: This file contains a curated, concise set of GlueX documentation, ideal for quick context or when token limits are a concern. It focuses on structure, core concepts and frequently used components
       * **`llms-full.txt`**: This file provides a more extensive and detailed collection of GlueX documentation, offering a deeper well of information for complex queries or comprehensive code generation

    2. **Integrate with your AI tool:**
       * **Direct upload/link:** Many AI platforms (like Cursor, Copilot, Windsurf, V0 and custom solutions) allow you to upload text files or link to external URLs. You can directly point your AI to `https://docs.gluex.xyz/llms.txt` or `https://docs.gluex.xyz/llms-full.txt`
       * **Local copy:** For offline use or custom environments, you can download these files and include them in your project directory
       * **Explicit referencing in prompts:** When crafting your AI prompts, explicitly mention that you've provided GlueX documentation as context (Eg: "Using the context from `llms-full.txt`, generate a GlueX integration for X feature...")

    ### When to Use This Method:

    * **Broad understanding:** This is ideal when you need the AI to have a **general understanding of GlueX** for tasks like scaffolding new projects, explaining architectural patterns, or answering high level questions
    * **Complex integrations:** For more intricate GlueX integrations, using `llms-full.txt` provides the depth needed for the AI to generate accurate code
    * **Reduced hallucinations:** By providing direct, authoritative documentation, you significantly reduce the AI's tendency to "hallucinate" incorrect information, leading to more reliable outputs
    * **Custom AI workflows:** If you're building custom AI agents or scripts that interact with GlueX, these files offer a read -made dataset for training or runtime context
  </Accordion>

  <Accordion title="Feature level Context">
    The "Copy page" button offers a few powerful options to streamline your AI assisted workflow:

    1. **View page as markdown:**
       * Clicking this option will display the entire content of the current documentation page in its raw Markdown format and is useful for reviewing the content structure before copying or for understanding how the page is formatted

    2. **Copy page as markdown:**
       * This option instantly copies the entire page content as Markdown to your clipboard. You can then paste this directly into your AI's input field, a dedicated context window or a local file you're using to feed context to your AI. This is perfect for providing focused, relevant information without manually selecting text

    3. **Ask claude/chatGPT to use page as context:**
       * This is a highly integrated feature designed for direct use with LLMs like Claude or ChatGPT. When you select this, GlueX automatically formats a prompt that includes the current page's content as context and often suggests a follow up action. This significantly reduces the manual effort of copying and pasting, making it smoother to ask questions or generate code based on that specific page

    ### When to Use This Method:

    * **Highly targeted tasks:** Ideal when you want the AI to focus on a particular GlueX function, API endpoint or module without being distracted by unrelated information
    * **Generating precise code snippets:** If you need a code example for a specific GlueX method, using this feature ensures the AI has the most relevant documentation
    * **Debugging specific issues:** When troubleshooting, providing the AI with the exact documentation page related to the component or error can lead to faster and more accurate solutions
    * **Concise explanations:** Get the AI to explain a specific concept from the docs in simpler terms or from a different perspective
  </Accordion>
</AccordionGroup>


# Welcome
Source: https://docs.gluex.xyz/documentation/get-started/introduction

Welcome to GlueX 👋

<video autoPlay muted loop playsInline className="rounded-xl block dark:hidden !my-0" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/hero-light.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6138c3b708b751e9a4b25313ca643788" data-path="images/hero/hero-light.webm" />

<video autoPlay muted loop playsInline className="rounded-xl hidden dark:block !my-0" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/hero/hero-dark.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=620c8388e12cdaf93f2235de94e0d7e8" data-path="images/hero/hero-dark.webm" />

## About GlueX

GlueX is the execution and data layer of decentralized finance (DeFi) providing a unified suite of onchain and offchain services designed to simplify the complexities of DeFi. Our modular framework abstracts away the complexities by standardizing integrations across diverse blockchains, exchange venues and liquidity providers within a unified framework to simplify, optimize and expedite the access to DeFi. This architecture enables the creation of truly composable applications without requiring developers to build and maintain complex manual integrations across multiple protocols

<Note>
  BEYOND SWAPS
  <br /> GlueX allows you not only to do swap but also equips you for entering and
  exiting lending positions, borrow or repay loans, depositing into yield farming
  strategies, adding or removing liquidity to diverse pools, stake or unstake in
  vaults and staking contracts, mint or redeem assets, execute flash loan and more
</Note>

* **Smart Routing**

  Our advanced routing engine continuously aggregates liquidity from multiple liquidity modules, analyzing every potential execution path in real time guaranteeing optimal trade execution by identifying the most efficient and cost effective routes, ensuring users always receive the best possible outcomes for their transactions

* **Metachain Liquidity**

  Access unparalleled liquidity depth sourced from diverse DeFi modules including DEXs, lending protocols, staking platforms, restaking services, AMMs, yield generating vaults and other specialized protocols spanning both primary and secondary markets, providing unprecedented access to liquidity across the DeFi ecosystem

* **Optimal Pricing**

  Through our sophisticated routing algorithms and deep liquidity aggregation, GlueX consistently delivers optimal pricing. We minimize slippage and ensure your orders are executed at the most favorable rates available across all integrated networks, translating to better returns for every transaction

* **Expansive Coverage**

  Execute trades with confidence across our comprehensive network supporting thousands of tokens spanning all integrated blockchain networks. This extensive coverage enables seamless asset movement and trading opportunities, regardless of the underlying blockchain or token standard, providing users with unlimited flexibility in their DeFi operations.

* **Builtin Safety**

  Builtin security incorporating guardrails, including MEV protection, dynamic surge protection and intelligent partial fill order capabilities actively shielding from front running, safeguard against low liquidity pool risks and mitigate exposure to extreme market volatility

<CardGroup cols={2}>
  <Card title="Concepts and Architecture" icon="play" href="">
    Learn how GlueX is built and how the modules fit together
  </Card>

  <Card title="Quickstart Guide" icon="rocket" href="">
    Integrate in minutes with our step by step tutorial
  </Card>

  <Card title="DeFi API suite" icon="code" href="">
    Explore the API suite - Router, Exchange Rates, Swidge, Yield, Debt and more
  </Card>

  <Card title="Join the Community" icon="users" href="https://bento.me/gluex-protocol">
    Be part of the GlueX community
  </Card>
</CardGroup>

## Why GlueX?

In the rapidly evolving landscape of DeFi, GlueX stands out as a reliable, efficient and secure partner for your DeFi needs.
Our proven track record and robust infrastructure speak for themselves:

* **\$10B+ in lifetime trade volume** optimized since 2022
* **\$6M+ in daily trade volume** processed
* **100k+ wallets served**
* **100+ liquidity sources** integrated across **17 chains**
* Trusted by **20+ partners** including top DeFi platforms

## Where to Begin?

Ready to start building with GlueX? We've structured our documentation to help you get started quickly and master our platform.
Choose the path that best fits your needs:

<CardGroup cols={1}>
  <Card title="Build with GlueX" icon="code" href="/build-with-gluex">
    Dive into our developer resources and start building powerful DeFi
    applications
  </Card>

  <Card title="API Reference" icon="gears" href="/api-reference">
    Explore comprehensive API documentation to integrate GlueX services into
    your projects
  </Card>

  <Card title="Tutorials" icon="book-open-reader" href="/tutorials">
    Follow step by step tutorials and real world examples to accelerate your
    learning and implementation
  </Card>
</CardGroup>

## Join Our Community

We believe in the power of collaboration and community. Join us to stay updated, get support and connect with other innovators in the GlueX ecosystem

* [Telegram](https://t.me/gluexprotocol) - Join our channel for updates, community discussions and direct support

* [X](https://x.com/GluexProtocol) - Follow us for the latest announcements, updates, and insights into the DeFi space

* [Discord](https://discord.com/invite/gluex) - For real time discussions, quick questions and direct support from the team

* [Github](https://github.com/gluexprotocol) - Explore our repositories, contribute to open source initiatives or submit issues

* [Blog](https://blog.gluex.xyz) - Stay informed about new features, partnerships and educational content


# Quickstart
Source: https://docs.gluex.xyz/documentation/get-started/quickstart

Start building awesome DeFi application in under 10 minutes

Welcome to the GlueX Quickstart Guides! Whether you're a developer integrating GlueX into your platform or a partner looking to utilize our framework or embed our widget, these guides will help you get up and running quickly and efficiently

GlueX provides a comprehensive suite of tools to simplify complex DeFi interactions:

* **Router**: Bridge, swap, lend, stake and compose multistep flows in one call
* **Exchange Rates**: Fetch real time pricing across chains
* **Yield**: Discover and optimize yield values
* **Debt**: Borrow, repay and manage debt positions in a single transaction
* **Widget**: Prebuilt UI components for a secure and smooth UX
* **Swidge** *(Coming Soon)*
* **Solve** *(Coming Soon)*

## Router

The Route API is a powerful and flexible automated pathfinding engine designed for developers to implement efficient onchain interaction logic and calculate optimal path between any two DeFi positions. Whether you’re swapping tokens, entering positions, adding liquidity or moving assets, the API provides everything needed for handling the complex routing logic automatically

### Getting Your First Router Quote

The first step in using the GlueX Router API is to generate a quote for a desired DeFi operation. This can be achieved by sending a POST request to the `/v1/quote` endpoint. It's recommended to start with the below example request and then explore more customization options in the [Router API Reference](/api-reference/router-api/post-quote)

### Sample Request

The first step in using the GlueX Router API to generate a quote. This can be achieved by sending a `POST` request to the `/v1/quote` endpoint. It is recommended to start with the below example request and apply more customization from (here)\[/docs/router/quote]

<CodeGroup>
  ```bash bash
  curl 'https://router.gluex.xyz/v1/quote' \
  -H 'content-type: application/json' \
  -H 'x-api-key: <api-key>' \
  --data-raw '{
    "inputToken": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "outputToken": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "inputAmount": "100000000",
    "userAddress": "0x2...A9D",
    "outputReceiver": "0x2...A9D",
    "chainID": "ethereum",
    "uniquePID": "<unique-pid>",
    "isPermit2": false
  }'
  ```

  ```javascript javascript
  const axios = require("axios");

  const response = await axios.post(
    "https://router.gluex.xyz/v1/quote",
    {
      inputToken: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      outputToken: "0xdac17f958d2ee523a2206206994597c13d831ec7",
      inputAmount: "100000000",
      userAddress: "0x2...A9D",
      outputReceiver: "0x2...A9D",
      chainID: "ethereum",
      uniquePID: "<unique-pid>",
      isPermit2: false,
    },
    {
      headers: {
        "content-type": "application/json",
        "x-api-key": "<api-key-here>",
      },
    }
  );

  console.log(response.data);
  ```

  ```python python
  import requests

  headers = {
    'content-type': 'application/json',
    'x-api-key': '<api-key-here>'
  }

  data = {
    "inputToken": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "outputToken": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "inputAmount": "100000000",
    "userAddress": "0x2...A9D",
    "outputReceiver": "0x2...A9D",
    "chainID": "ethereum",
    "uniquePID": "<unique-pid>",
    "isPermit2": False
  }

  response = requests.post('https://router.gluex.xyz/v1/quote', headers=headers, json=data)

  print(response.json())
  ```
</CodeGroup>

### Sample Response

```bash
{
  "statusCode": 200,
  "result": {
    "inputToken": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "outputToken": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "feeToken": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "inputSender": "0x2...a9d",
    "outputReceiver": "0x2...a9d",
    "inputAmount": "100000000",
    "outputAmount": "110023345",
    "partnerFee": "0",
    "routingFee": "0",
    "effectiveInputAmount": "100000000",
    "effectiveOutputAmount": "110023345",
    "minOutputAmount": "107822878",
    "liquidityModules": [
      "uniswap_v2",
      "uniswap_v3",
      "sushiswap",
      "solidly_v3"
    ],
    "router": "0x6Ec7612828B776cC746fe0Ee5381CC93878844f7",
    "calldata": "0xb8039e98...00000000000",
    "isNativeTokenInput": false,
    "value": "0",
    "revert": true,
    "computationUnits": 2000000,
    "blockNumber": 22803966,
    "lowBalance": true
  }
}
```

### How to Use

Once you have the `/quote` response, you can use **any web3 library** (eg: ethers.js, web3.js, web3.py) to build, sign and send the transaction. The key fields you’ll need are:

* **`calldata`**: ABI encoded function call for the router
* **`value`**: Native token amount to attach (if input is a native token)
* **`computationUnits`**: Simulated gas estimate (recommended - `gasLimit = computationUnits × 1.3`)

Simply construct your transaction object with those fields, sign it with your EOA’s private key and broadcast it

### Learn More

<CardGroup cols={3}>
  <Card title="API Reference" icon="code" href="/api-reference/router-api/post-quote">
    Full specification and documentation for router API
  </Card>

  <Card title="Architecture" icon="play" href="">
    Learn more about the smart routing engine and it's architecture
  </Card>

  <Card title="Tutorials" icon="book-open" href="">
    Indepth integration guides and best practices
  </Card>

  <Card title="Parameter Reference" icon="setting" href="/build-with-gluex/router/request-response-format">
    Full request and response field definitions
  </Card>

  <Card title="Examples" icon="terminal" href="">
    Code snippets for common flows and use cases
  </Card>
</CardGroup>

### Examples

<AccordionGroup>
  <Accordion title="Token Swap">
    With **Router’s token swap API**, you can swap **any token A → token B** on any supported blockchain in just **one call**.
    Instead of dealing with multiple steps like approvals, liquidity sourcing and slippage calculations,
    Router takes care of everything under the hood, letting you focus on what matters - receiving your desired token directly in your wallet

    ## Why use GlueX for token swaps?

    Traditionally, swapping tokens on a blockchain involves:

    1. **Finding liquidity pools** across decentralized exchanges (DEXs)
    2. **Checking prices and slippage tolerance** to avoid bad execution
    3. **Manually approving tokens** so they can be spent by a smart contract
    4. **Building and broadcasting the transaction** with correct gas settings
    5. **Tracking the transaction** until it confirms

    Router simplifies all of this into a single, streamlined API call. When you specify:

    * The **input token** (what you’re swapping from)
    * The **output token** (what you’re receiving)
    * The **amount**
    * Your **wallet address**

    Router will:

    * **Aggregate liquidity across multiple sources** to find the best route
    * **Handle token approvals automatically**
    * **Execute the transaction in one step**
    * **Send the output tokens directly** to your wallet (or any another specified address)

    This guarantees a **faster**, **more efficient** and **user friendly** swap experience

    ***

    ## Example: Swap **USDT → WBTC** on Ethereum

    Here’s how you can swap **100 USDT** into **WBTC** on Ethereum in a single API request:

    ```json
    POST /v1/quote
    {
      "inputToken": "0xdac17f958d2ee523a2206206994597c13d831ec7",     // USDT contract address
      "outputToken": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",    // WBTC contract address
      "inputAmount": "100000000",                                     // 100 USDT (6 decimals)
      "userAddress": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91",    // Wallet executing the swap
      "outputReceiver": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91", // Wallet receiving WBTC
      "chainID": "ethereum",                                          // Target blockchain
      "uniquePID": "<your-unique-pid>"                                // Integrator ID
    }
    ```

    Here’s a real USDT → WBTC one call swap - [0x91c969f626d80c273008627d1a9d47b5f4600d9584ee045f0fdd57a080320dce](https://etherscan.io/tx/0x91c969f626d80c273008627d1a9d47b5f4600d9584ee045f0fdd57a080320dce)
  </Accordion>

  <Accordion title="Vault Entry">
    With **Router’s vault entry flow**, you can deposit into yield vaults (like Yearn, Aave, etc.) in **just one transaction**
    No matter if you already hold the vault’s underlying asset or need to swap into it first,
    Router handles all the required steps automatically, saving you from manual approvals and multiple transactions

    ## Why use GlueX for vault deposits?

    Normally, entering a vault requires several steps:

    1. **Acquire the correct deposit token** (swap into the asset the vault accepts)
    2. **Approve the vault contract** to spend your tokens
    3. **Deposit the tokens** into the vault
    4. **Wait for confirmation** before receiving vault shares in your wallet

    Router simplifies this process into **a single API call**. You just specify:

    * The **input token** (what you’re starting with)
    * The **vault token** (the token you’ll receive, eg: yvUSDC)
    * The **amount**
    * Your **wallet address**

    Router will:

    * **Swap into the correct deposit asset** if needed
    * **Approve the vault contract automatically**
    * **Deposit the tokens on your behalf**
    * **Send the vault shares (yvTokens) directly** to your wallet (or any another specified address)

    This makes vault entry **seamless**, **gas efficient** and **user friendly**

    ***

    ## Example: Example: Deposit **WBTC → MEVCapital USDC Vault**

    Here’s how you can deposit **WBTC** directly into the **MEVCapital USDC Vault** in one step:

    ```json
    POST /v1/quote
    {
      "inputToken": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",     // WBTC contract address
      "outputToken": "0xd63070114470f685b75b74d60eec7c1113d33a3d",    // MEVCapital USDC Vault token address
      "inputAmount": "50000",                                         // Amount of WBTC in satoshis (5 decimals)
      "userAddress": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91",    // Wallet executing the deposit
      "outputReceiver": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91", // Wallet receiving yvUSDC
      "chainID": "ethereum",                                          // Target blockchain
      "uniquePID": "<your-unique-pid>"                                // Integrator ID
    }
    ```

    Here’s a real WBTC → MEVCapital USDC vault deposit transaction - [0xe608be4745380168d4b882f012cb37b0282ff0ff96749ad579747143a4693c6b](https://etherscan.io/tx/0xe608be4745380168d4b882f012cb37b0282ff0ff96749ad579747143a4693c6b)
  </Accordion>

  <Accordion title="Lending">
    With **Router’s lending flow**, you can supply assets to lending protocols (like Aave, Compound, etc) and
    receive interest-bearing tokens (aTokens, cTokens, etc) in **one unified action**.
    Whether you already hold the protocol’s required asset or need to swap into it first, Router automates the entire process

    ## Why use GlueX for Lending?

    Normally, lending assets requires several manual steps:

    1. **Swap into the correct deposit token** (eg: swap USDC into WETH if the protocol requires WETH)
    2. **Approve the lending protocol contract** to spend your tokens
    3. **Call the protocol’s deposit method** to supply liquidity
    4. **Receive the corresponding aToken/cToken** representing your deposit

    Router compresses this into **a single call**. You only need to specify:

    * The **input token** (what you’re starting with)
    * The **deposit token** you want to receive (eg: aWETH)
    * The **amount**
    * Your **wallet address**

    Router will:

    * **Swap into the correct asset if needed**
    * **Handle approvals automatically**
    * **Supply liquidity to the protocol**
    * **Deliver the interest bearing token directly** to your wallet (or any another specified address)

    ***

    ## Example: Lend **USDC → Receive aWETH**

    Here’s how to lend **50 USDC** and receive **aWETH** in a single API request:

    ```json
      POST /v1/quote
      {
        "inputToken": "0xa0b86991c6218b36c1d19D4a2e9eb0ce3606eb48",     // USDC contract address
        "outputToken": "0x4d5f47fa6a74757f35c14fd3a6ef8e3c9bc514e8",    // aWETH contract address (Aave)
        "inputAmount": "50000000",                                      // 50 USDC (6 decimals)
        "userAddress": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91",    // Wallet executing the deposit
        "outputReceiver": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91", // Wallet receiving yvUSDC
        "chainID": "ethereum",                                          // Target blockchain
        "uniquePID": "<your-unique-pid>"                                // Integrator ID
      }
    ```

    Here’s a real USDC → Receive aWETH lending transaction - [0x37cdcdf63b962f3a945c37436da2965c12f590cc340eee72dde1187aa9ae0a40](https://etherscan.io/tx/0x37cdcdf63b962f3a945c37436da2965c12f590cc340eee72dde1187aa9ae0a40)
  </Accordion>

  <Accordion title="Staking">
    With **Router’s staking flow**, you can stake any token into a staking protocol (such as Lido, Swell, Rocket Pool, etc)
    and receive the staked token in **a single call**. Whether you already hold the staking asset or need to swap into it first,
    Router automates the full lifecycle - from swap, to staking - in one gas optimized transaction

    ***

    ## Why Use Router for Staking?

    Normally, staking involves multiple steps:

    1. **Swap into the staking asset** if you don’t already hold it
    2. **Approve the staking contract** to spend your tokens
    3. **Send the stake transaction** to the protocol
    4. **Receive your staked token** in return

    Router combines these steps into **one unified API call**. You just specify:

    * The **input token** (what you’re staking with)
    * The **staked token** you want to receive
    * The **amount**
    * Your **wallet address**

    Router will:

    * **Swap if required** into the correct staking asset
    * **Approve the staking contract**
    * **Stake on your behalf**
    * **Deliver the staked token directly** to your wallet

    ***

    ## Example: Stake **DAI → swETH**

    Here’s how to stake **DAI** → **swETH** in one call using Router:

    ```json
      POST /v1/quote
      {
        "inputToken": "0x6b175474e89094c44da98b954eedeac495271d0f",                      // DAI contract address
        "outputToken": "0xf951e335afb289353dc249e82926178eac7ded78",                     // swETH contract address
        "inputAmount": "506591370407006083313",                                           // Amount of DAI (18 decimals)
        "userAddress": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91",                                       // Wallet executing the stake
        "outputReceiver": "0xb06B08B7bDb9C21c3a95F6688994172C25A54d91                   "                  , // Wallet receiving swETH
        "chainID": "ethereum",                                                          // Target blockchain
        "uniquePID": "866a61811189692e8eccae5d2759724a812fa6f8703ebffe90c29dc1f886bbc1" // Unique request ID
      }
    ```

    Here’s a real USDC → Receive DAI\*\* into **swETH** lending transaction - [0x37cdcdf63b962f3a945c37436da2965c12f590cc340eee72dde1187aa9ae0a40](https://etherscan.io/tx/0x37cdcdf63b962f3a945c37436da2965c12f590cc340eee72dde1187aa9ae0a40)
  </Accordion>

  <Accordion title="Crosschain">
    COMING SOON...
  </Accordion>
</AccordionGroup>

## Exchange Rate

The Exchange Rates API provides an easy to use, scalable solution for retrieving on-chain exchange rates between any two token pairs across multiple supported blockchains. Whether you’re building a DeFi app, wallet or trading platform, you can fetch realtime, accurate rates in a single batch call

### Sample Request

The first step in using the GlueX Exchange Rates API to fetch the price of a token pair. This can be achieved by sending a `POST` request to the root `/` endpoint. It is recommended to start with the below example request and apply more customization from (here)\[/api-reference/exchange-rate-api/post-price]

<Note>Each call can batch upto 25 pairs per request</Note>

<CodeGroup>
  ```bash bash
  curl 'https://exchange-rates.gluex.xyz/' \
    -H 'content-type: application/json' \
    --data-raw '[{
      "domestic_blockchain": "ethereum",
      "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      "foreign_blockchain": "ethereum",
      "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7"
    }]'
  ```

  ```javascript javascript
  const axios = require("axios");

  const response = await axios.post(
    "https://exchange-rates.gluex.xyz/",
    [
      {
        domestic_blockchain: "ethereum",
        domestic_token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        foreign_blockchain: "ethereum",
        foreign_token: "0xdac17f958d2ee523a2206206994597c13d831ec7",
      },
    ],
    {
      headers: {
        "content-type": "application/json",
      },
    }
  );

  console.log(response.data);
  ```

  ```python python
  import requests

  headers = {
    'content-type': 'application/json'
  }

  data = [{
    "domestic_blockchain": "ethereum",
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_blockchain": "ethereum",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7"
  }]

  response = requests.post('https://exchange-rates.gluex.xyz/', headers=headers, json=data)

  print(response.json())
  ```
</CodeGroup>

### Sample Request

```bash
[
  {
    "domestic_token": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "foreign_token": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "domestic_blockchain": "ethereum",
    "foreign_blockchain": "ethereum",
    "price": "0.9991396602323227"
  }
]
```

### How to Use

* Parse the JSON: Iterate over the array to extract price for each token pair
* Batching: Request up to 25 pairs at once to minimize round trips
* No Auth Needed: Public access by default, supply an API key header for higher rate limits when available

### Learn More

<CardGroup cols={3}>
  <Card title="API Reference" icon="code" href="">
    Full specification and documentation for exchange rates API
  </Card>

  <Card title="Architecture" icon="play" href="">
    Learn more about the how the exchange rates works
  </Card>

  <Card title="Tutorials" icon="book-open" href="">
    Indepth integration guides and best practices
  </Card>

  <Card title="Parameter Reference" icon="setting" href="">
    Full request and response field definitions
  </Card>

  <Card title="Examples" icon="terminal" href="">
    Code snippets for common flows and use cases
  </Card>
</CardGroup>

### Examples

<AccordionGroup>
  <Accordion title="" />

  <Accordion title="" />

  <Accordion title="" />

  <Accordion title="" />

  <Accordion title="">
    COMING SOON...
  </Accordion>
</AccordionGroup>

## Widget

The GlueX Widget offers a plug and play UI for embedding full featured DeFi operations like routing, swap, bridge, stake, lend and more into your applicaation with minimal code and maximum customization

### Installation

Install the core packages (using your preferred package manager):

<CodeGroup>
  ```bash npm
  npm install wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash yarn
  yarn add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash pnpm
  pnpm add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```

  ```bash bun
  bun add wagmi @tanstack/react-query @gluex/widget @gluex/sdk
  ```
</CodeGroup>

### Sample Integration

Embed the widget in your React (or compatible) app with just a few lines:

```typescript
import { GlueXWidget, WidgetConfiguration } from "@gluex/widget";

const config: Partial<WidgetConfiguration> = {
  apiKey: environment.GLUEX_API_KEY,
  integrator: environment.INTEGRATOR_ID,
};

export const DeFiWidget = () => {
  return <GlueXWidget config={config} />;
};
```

### Learn More

<CardGroup cols={3}>
  <Card title="Configuration" icon="setting" href="/build-with-gluex/widget/configuration">
    Full list of `<GlueXWidget />` properties and default values
  </Card>

  <Card title="Theming Guide" icon="palette" href="/build-with-gluex/widget/customizations">
    Deep dive into theme, style, shape, typography and color overrides
  </Card>

  <Card title="Event System" icon="zap" href="/build-with-gluex/widget/events">
    How to hook into widget events for analytics and UX
  </Card>

  <Card title="Advanced Examples" icon="terminal" href="/build-with-gluex/widget/integration/installing-the-widget">
    Prebuilt layouts and custom component overrides
  </Card>

  <Card title="Widget Studio" icon="play" href="https://studio.gluex.xyz/playground">
    Visual tool for generating theme and config JSON
  </Card>
</CardGroup>


# Requesting Exchange Rates
Source: https://docs.gluex.xyz/documentation/integrating-gluex/exchange-rate/how-to-request-exchange-rates

A comprehensive guide to fetch exchange rates for any token pairs

This guide provides a structured, step by step approach to fetch exchange rates for token pair using GlueX Exchange Rates API. It covers everything about fetching exchange rates, from basic requests to advanced implementation patterns for production applications

## Prerequisites

Before you begin, ensure you have:

* Basic understanding of REST API concepts
* Access to a development environment with HTTP request capabilities
* Understanding of blockchain token addresses and chain identifiers

## Preparing the Request

The Exchange Rates API uses a flexible request structure that supports both single token lookups and batch operations

### Request Body

* **domestic\_token**: The primary token address you want to price
* **domestic\_blockchain**: The blockchain where the domestic token resides
* **foreign\_blockchain**: The blockchain for the comparison token
* **foreign\_token**: The comparison token address

```json
[
  {
    "domestic_token": "tokenA-address",
    "foreign_token": null,
    "domestic_blockchain": "blockchain_id_1",
    "foreign_blockchain": "blockchain_id_1"
  },
  {
    "domestic_token": "tokenB-address",
    "foreign_token": "tokenC-address",
    "domestic_blockchain": "blockchain_id_2",
    "foreign_blockchain": "blockchain_id_2"
  }
]
```

## Making the Request

<CodeGroup>
  ```bash bash
  curl -X POST "https://exchange-rates.gluex.xyz" \
    -H "Content-Type: application/json" \
    -d '[{"domestic_token": "tokenA-address", "foreign_token": null, "domestic_blockchain": "blockchain_id_1", "foreign_blockchain": "blockchain_id_1"}, {"domestic_token": "tokenB-address", "foreign_token": "tokenC-address", "domestic_blockchain": "blockchain_id_2", "foreign_blockchain": "blockchain_id_2"}]'
  ```

  ```python python
  import requests
  import json

  url = "https://exchange-rates.gluex.xyz"
  data = [
      {
          "domestic_token": "tokenA-address",
          "foreign_token": None,
          "domestic_blockchain": "blockchain_id_1",
          "foreign_blockchain": "blockchain_id_1",
      },
      {
          "domestic_token": "tokenB-address",
          "foreign_token": "tokenC-address",
          "domestic_blockchain": "blockchain_id_2",
          "foreign_blockchain": "blockchain_id_2",
      }
  ]
  headers = {"Content-Type": "application/json"}
  response = requests.post(url, headers=headers, data=json.dumps(data))
  print(response.json())
  ```
</CodeGroup>

## Handling the Response

The response will contain a list of exchange rates for the requested token pairs

```json
[
  {
    "domestic_token": "tokenA-address",
    "price": 0.00010741495276069063,
    "foreign_token": "blockchain_id_1_native-currency-address",
    "domestic_blockchain": "blockchain_id_1",
    "foreign_blockchain": "blockchain_id_1"
  },
  {
    "domestic_token": "tokenB-address",
    "price": 1.0013751780636744e-12,
    "foreign_token": "tokenC-address",
    "domestic_blockchain": "blockchain_id_2",
    "foreign_blockchain": "blockchain_id_2"
  }
]
```

You're ready to integrate real time exchange rates into your app!


# Get a GlueX API key - Portal
Source: https://docs.gluex.xyz/documentation/integrating-gluex/getting-an-api-key



Set up an account on the [GlueX Developer Portal](https://portal.gluex.xyz) to generate API keys and manage your applications

<video autoPlay muted playsInline className="w-full aspect-video rounded-xl" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/portal.webm?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=494c535eb763834730985160ca75161b" data-path="images/products/portal/portal.webm" />

Follow these steps to get started, in less than 5 minutes!

## Create an Account

To create an account on the [GlueX Developer Portal](https://portal.gluex.xyz/register) provide your name, a valid email address and a password of your choice (we recommend at least eight characters, mixing letters and numbers), you can also optionally provide your Telegram handle for support and your organization name for tailored assistance

Alternatively, you can click **Continue with Github** to sign up instantly using your Github credentials. After submitting the form, you’ll receive a prompt to verify your email address before you can log in

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1a4993ea31fa6592908cdca232c3e3c6" alt="Developer Portal - Registration" width="2920" height="1570" data-path="images/products/portal/register.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=02c08def9ea7c224a30dbee03a7140b9 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=941918c64a5047e5b75cc4ab84ca131e 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=4f53a9cf4a69c0a5dc5f10045f957c16 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=60250460d2774e9203bca36eafaf6e92 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=583de2adc34b3d0af26f0c8e4d5b782a 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/register.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2928a12dc78f6d591b40c5d71fafe520 2500w" data-optimize="true" data-opv="2" />

<Warning>
  If you are already an integrator without access to the Portal, please DO NOT
  create a new account. Instead, please [contact
  us](https://bento.me/gluex-protocol) for the login credentials
</Warning>

## Verify Your Account

Upon registration, you will receive a verification email from *[no-reply@gluex.xyz](mailto:no-reply@gluex.xyz)* with the subject **“Welcome to GlueX – Complete Your Signup”**

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9bf8cc0ebf2e48800731dc7e8196ff37" alt="Developer Portal - Verify SignUp Email" width="2256" height="1298" data-path="images/products/portal/verification-signup.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=13456cf7c376a2b5f57b2a506287b3f2 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f3dbe04c966227c6d8bdb93da8442d3e 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=ba7d67faa43ee6aa877024a311839a8b 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a19e5bcd454e51dd8b742c745acf7fcc 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e7f46449b98847f15d72c404f30ce73e 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verification-signup.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1f9f5402ae24717414b1159ce6766442 2500w" data-optimize="true" data-opv="2" />

Please open the email and locate the **one-time password (OTP)**. Enter this OTP into the verification field on the Portal and click **Verify**.

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b44b3aaf6ab90158584849fa4095a73a" alt="Developer Portal - Verify OTP" width="2930" height="1574" data-path="images/products/portal/verify-otp.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=21e511f37558dff1ae9e1d8b5f81fe08 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8b3dfc31b9725c6ee6c822e6dd97481f 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d6fa2dee5893f13223ee1d613a641e0d 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c7d30357e188c5c5fbe517e6b4697518 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=a547c772454a47d5bb73e92d5a8b5e95 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/verify-otp.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=56fe6ff84e331dc3abda3e5b14e0eee4 2500w" data-optimize="true" data-opv="2" />

Once your email is verified, you will be redirected to the Portal and a confirmation banner, will appear at the top of the screen

<Note>
  If you do not receive the verification email within a few minutes, please
  check your spam or junk folder. You may also click **Resend Now** to request a
  new email
</Note>

## Login

To log in to the [GlueX Developer Portal](https://portal.gluex.xyz/login), enter your registered email address and password in the login form. If you signed up using Github, you can simply click **Continue with Github** for instant access

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=23ace0f4177673dffaeb3e49aae8246d" alt="Developer Portal - Login" width="3024" height="1568" data-path="images/products/portal/login.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f6c6c1c81807a723f05d8a8ad7b34fcf 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=01f92dd4dba80e17525a832e84535b13 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=3b63e08189ca247535f9da3c75a7caff 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e394fc8cbe1d6f850a68c57871d9438e 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=972827384adee280ee935a627036ef63 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/login.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=62e92a5f32ee763fc604f96689469bbf 2500w" data-optimize="true" data-opv="2" />

## Portal Tour

### API Key Management

When you log in for the first time (or, if you haven’t generated any API keys yet), the API Key Management section will display an empty state with instructions and an option to generate your **first API key**

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f53eb76252aa6be83716ba1a1e5c469e" alt="Developer Portal - Empty" width="3024" height="1564" data-path="images/products/portal/api-management-empty.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6a723a200627b775a7f206c018a28596 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9230483ba16d60a5f3819604a7068549 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c201d39790a345cf34ba893189e997f0 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=70b826bdd3d11012f6f0f0b59b4d9cdb 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e5eb5e754df9b9525a4c302700875382 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-empty.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=385eb67e7938802c0ff37d44dcb17a0a 2500w" data-optimize="true" data-opv="2" />

After generating an API key, you’ll be able to view and copy both your **API key** and your unique **Integrator ID**. The Integrator ID is essential for tracking analytics, usage, and associating requests with your account

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c67ba621f8a0e0c5b0292abdf944880d" alt="Developer Portal - With Key" width="2926" height="1572" data-path="images/products/portal/api-management-with-key.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=5b294ec92ad4de1315f67ccc6e7a2028 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1823e9a86adfe74b8984f802495f7b86 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=88074d3b5aa95a5c117f54600e6f6595 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fe97781de75c1a3958eff015fa7077c8 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=633adc8115ef900fe9064fd88cef44b8 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/api-management-with-key.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2d4e9cee727a36017e9dd3991961df2c 2500w" data-optimize="true" data-opv="2" />

Use the copy buttons next to each field to quickly copy your API key and Integrator ID

**Best Practices**

* Store your API keys securely and never share them publicly
* Rotate or delete unused keys regularly to minimize risk
* Use descriptive names for each key to keep your integrations organized
* Monitor usage and set up alerts for unusual activity (feature coming soon)

#### Rotating an API Key

If you need to update your API key for security reasons or suspect it has been compromised, click **Rotate** next to the key. This will instantly invalidate the old key and generate a new one

> For best security, rotate your API key periodically

<Note>
  Only `basic` plan keys can be rotated. If you are a power user, please reach
  out to support for assistance
</Note>

#### Deleting an API Key

To permanently remove an API key, click **Delete**. This action cannot be undone, and any applications using the deleted key will lose access immediately

<Note>
  Only `basic` plan keys can be deleted. If you are a power user, please reach
  out to support for assistance
</Note>

#### Upgrading an API Key

If you require higher rate limits or additional features, contact us to **Upgrade** your tier. You may be asked to provide details about your use case

> Learn more about available plans and features

#### Whitelisting Domains

*(Coming Soon)*

Restrict API access to specific domains for added security. You’ll be able to add, edit, or remove whitelisted domains directly

#### API Key Usages

*(Coming Soon)*

Visualize your API usage, monitor rate limits and track analytics such as request volume, error rates and performance metrics

### Metrics

*(Coming Soon)*

The Metrics page will provide comprehensive Router analytics, including:

* **Total Volume:** Track the overall transaction volume processed
* **Trades:** View the number of trades executed
* **Active Users:** Monitor user engagement and activity
* **Trade Sizes:** Analyze the distribution of trade sizes
* **Top Tokens:** Identify the most frequently traded tokens
* **Size Distribution:** Visualize how trade sizes are distributed
* **Trade Logs:** Access detailed logs for each trade

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=474c2d0e803e6757bef5801b26497ea2" alt="Developer Portal - Metrics" width="2930" height="1570" data-path="images/products/portal/metrics-coming-soon.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=0ab3b7c574b0b26eb7c86fe4c309d819 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9aad6cf194eadf34a8254dcb71c55b89 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=834453ed5678e473f1add0dc28adb293 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6ef174abf68fa0c40460a0d19eabb50c 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=718cd259d4213618d6b0f8b848ec96f2 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/metrics-coming-soon.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=e330a56c66ba4b2cd40f01a6a5987ef9 2500w" data-optimize="true" data-opv="2" />

### Revenue

*(Coming Soon)*

The Revenue page will feature advanced revenue analytics, such as:

* **Total Revenue:** See your cumulative earnings
* **Growth:** Track revenue growth over time
* **Fee Rate:** Review the current fee rates applied
* **Surplus Fees:** Analyze surplus fee generation
* **Fee Tier Performance:** Compare performance across different fee tiers

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fddcc3e0f9d9dbeb7db8ddfcaba1100e" alt="Developer Portal - Revenue" width="2924" height="1568" data-path="images/products/portal/revenue-coming-soon.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fd345487afc0cc3f32835a7afd8d3fed 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6d69c0b1b6bbe9514b25c42fefbabc30 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=42792cadf1a7b37b481d28b2dc49529b 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9fc9a2345945f7351e0560196d019949 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=257bd24fc9da399a64d9d1d2aaabc380 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/revenue-coming-soon.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=c63ff5ab2277c8c46bb36adc13652d82 2500w" data-optimize="true" data-opv="2" />

### Settings

In the Settings section, you can update your user profile, manage account details and configure preferences to personalize your experience

<img className="rounded max-h-[480px]" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9e1aa7747bac0a1a6a95a93694dc25ec" alt="Developer Portal - Settings" width="2928" height="1568" data-path="images/products/portal/settings.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=fef1167ca669f3f70d6a6384b17b8802 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=63d3ee9aaa23f17d4f3f73ab05204ab7 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=00be82a0360565d681b96ec17db7f08d 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=56e5e922e64f8dd9cfa61cf7748429b7 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=81ebed38c5c2025adacf160588c9d194 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/products/portal/settings.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=727677f44540c14ba7788d1ffa921554 2500w" data-optimize="true" data-opv="2" />

## Forgot Password

If you forget your password, click **Forgot Password** to receive a password reset OTP via email.
For security, make sure to use a strong password and keep your login details confidential

<Note>
  If you experience any issues logging in, such as not receiving the password
  reset email or trouble with Github authentication, please [contact
  support](https://bento.me/gluex-protocol) for assistance
</Note>


# Getting Your First Quote
Source: https://docs.gluex.xyz/documentation/integrating-gluex/router/getting-your-first-quote

A comprehensive guide to integrating with the GlueX Router API

This guide provides a structured, step by step approach to integrating with the Router API. It covers everything from obtaining access credentials to executing onchain swaps through the router, ensuring developers can quickly implement token routing functionality in their applications

***

## Prerequisites

Before starting this integration guide, ensure you have:

* Basic understanding of blockchain concepts and smart contract interactions
* A web3 enabled development environment
* Access to the target blockchain networks you wish to support
* A wallet or application requiring token swap functionality

## Obtain an API Key

To begin using the GlueX Router API, developers must register via the official GlueX developer portal. This registration process ensures proper access control and enables tracking of API usage for your specific integration

### Registration Process

1. **Navigate to the Portal**: Visit the [GlueX developer portal](https://portal.gluex.xyz/login)
2. **Complete Registration**: Fill out the onboarding form, providing details about:
   * Personal information
   * Your application or project name
   * Target use cases and supported chains
3. **Receive Credentials**: Upon successful login, you will receive:
   * **API Key**: A unique identifier for authenticating your requests
   * **Partner Identifier**: A distinct identifier linking transactions to your integration

<Note>
  For a detailed walkthrough of the registration process, refer to the [Get a
  GlueX API key – Portal](/documentation/integrating-gluex/getting-an-api-key)
  guide
</Note>

### Important Considerations

* Store your API credentials securely and never expose them in client side code
* Implement proper environment variable management in your deployment pipeline
* Consider using API key rotation strategies for enhanced security
* Monitor your API usage to detect any unauthorized access

## Fetch Available Liquidity

Before initiating any trade, it's crucial to verify which chains and liquidity modules are currently supported. This step ensures your application can make informed routing decisions and provide users with accurate availability information.

### Endpoint

```http
GET /liquidity
```

The endpoint returns supported chains and liquidity modules, which help optimize your routing logic

### Request Headers

```http
x-api-key: your-api-key
Content-Type: application/json
```

### Best Practices

* **Cache Strategically**: Store liquidity data with appropriate TTL (recommended: 15 minutes)
* **Update Regularly**: Poll this endpoint periodically to ensure your application reflects current network conditions

## Estimate Swap Using `/v1/price`

The `/v1/price` endpoint provides real time price estimates for token swaps. This endpoint should be frequently polled in applications to show users up to date price quotes and ensure optimal trading conditions

### Endpoint

```http
POST /v1/price
```

### Request Headers

```http
x-api-key: your-api-key
Content-Type: application/json
```

### Request Parameters

* **`inputToken`**: Contract address of the token being sold
* **`outputToken`**: Contract address of the token being purchased
* **`inputAmount`** or **`outputAmount`**: Specify either input or output amount (not both)
* **`uniquePID`**: Your partner identifier from the registration process

**Example**

```json
{
  "inputToken": "0x...abc",
  "outputToken": "0x...xyz",
  "inputAmount": "1000000000000000000",
  "userAddress": "0x...user",
  "outputReceiver": "0x...user",
  "chainID": "<chain-identifier>",
  "uniquePID": "<your-integrator-id></your-integrator-id>"
}
```

The price endpoint returns information about the estimated output amount, price impact, route information, fee breakdown and gas estimates

### Best Practices

* **Polling Frequency**: Update quotes every 10 - 30 seconds for active interfaces
* **Error Handling**: Implement retry logic with exponential backoff for failed price requests
* **Price Staleness**: Warn users when quotes are older than 30 - 60 seconds

## Approve Token Transfer

Before the router can execute any swap, users must grant permission for the router contract to spend their input tokens. This is a standard ERC 20 approval process that ensures secure token handling

### Standard Approval

Before executing a swap, users must approve the router contract to spend their input tokens. This is done by calling the ERC-20 `approve` method, specifying the router address and the exact amount to be swapped. This step is required for all ERC-20 tokens and ensures secure token handling

### Permit2 (Optional)

GlueX supports Permit2, a more efficient approval mechanism that combines approval and execution into a single transaction, improving user experience and reducing gas costs.
Enable by setting:

```json
{
  // ...
  "isPermit2": true
}
```

### Best Practices

* **Exact Amount**: Approve only the required amount for maximum security

## Obtain Calldata Using `/v1/quote`

Once the user confirms the swap parameters and all necessary approvals are in place, the `/v1/quote` endpoint provides the exact calldata required to execute the trade on-chain

### Endpoint

```http
POST /v1/quote
```

### Request Headers

```http
x-api-key: your-api-key
Content-Type: application/json
```

### Request Parameters

* **`inputToken`**: Contract address of the token being sold
* **`outputToken`**: Contract address of the token being purchased
* **`inputAmount`** or **`outputAmount`**: Specify either input or output amount (not both)
* **`uniquePID`**: Your partner identifier from the registration process

**Example**

```json
{
  "inputToken": "0x...abc",
  "outputToken": "0x...xyz",
  "inputAmount": "1000000000000000000",
  "userAddress": "0x...user",
  "outputReceiver": "0x...user",
  "chainID": "<chain-identifier>",
  "uniquePID": "<your-integrator-id></your-integrator-id>"
}
```

### Response

* **`calldata`**: ABI-encoded transaction data ready for execution
* **`router`**: Contract to send the transaction to
* **`value`**: Native token amount to include with the transaction (for ETH/native token swaps)

### Quote Expiration

Quotes have limited validity periods. Implement proper expiration handling:

* **Timestamp Tracking**: Monitor quote creation time
* **Automatic Refresh**: Re-fetch quotes before expiration
* **User Warnings**: Alert users when quotes are approaching expiration
* **Fallback Logic**: Handle expired quotes gracefully

## Execute Onchain

The final step involves submitting the calldata from the quote endpoint to the router contract. This transaction must be properly signed by the user and broadcast to the network

* Use a web3 library like `ethers.js` or `web3.js`
* Send transaction to the router contract address with the specified `value`
* Monitor the transaction for success

### Using ethers.js

```javascript
const transaction = {
  to: quoteData.routerAddress,
  data: quoteData.calldata,
  value: quoteData.value || 0,
  gasLimit: quoteData.gasLimit,
  gasPrice: quoteData.gasPrice,
};

const txResponse = await signer.sendTransaction(transaction);
const receipt = await txResponse.wait();

console.log(`Swap executed: ${receipt.transactionHash}`);
```

### Using web3.js

```javascript
const tx = {
  to: quoteData.routerAddress,
  data: quoteData.calldata,
  value: web3.utils.toHex(quoteData.value || 0),
  gas: quoteData.gasLimit,
  gasPrice: quoteData.gasPrice,
};

const signedTx = await web3.eth.accounts.signTransaction(tx, privateKey);
const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
```

### Error Handling Strategies

* **Insufficient Gas**: Transaction runs out of gas during execution
* **Price Impact**: Actual price differs significantly from quote
* **Liquidity Changes**: Available liquidity shifts between quote and execution
* **Network Congestion**: Transaction stuck in mempool

## Explore More

To accelerate your integration and learn advanced implementation patterns, explore our comprehensive tutorial library:

* [Deposit to a lending vault](/tutorials/defi/deposit-to-a-lending-vault)
* [Swapping native tokens](/tutorials/defi/swap-native-tokens)


# Blockchain Module
Source: https://docs.gluex.xyz/documentation/modules/blockchain



## Overview

GlueX Blockchain Modules are specialized components designed to streamline the onboarding and integration process of
different blockchains into the GlueX Protocol. These modules abstract blockchain level differences, providing a unified
interface for interacting with various blockchains. By leveraging these modules, GlueX ensures seamless compatibility
and reduces the complexity associated with supporting multiple chains with differing architectures, consensus
mechanisms and operational nuances

## Integrating a Blockchain Module

### Required Interfaces

#### Blockchain Node Access

* **Requirement:** Access to a fully synced blockchain node or a reliable third party RPC endpoint to interact with
  the target blockchain network
* **Purpose:** To enable API calls for querying the blockchain and submitting transactions

#### Blockchain specific SDK or Libraries

* **Requirement:** Include any required SDKs, libraries or APIs specific to the target blockchain (eg: web3 for
  Ethereum, cosmosSDK for cosmos chains)
* **Purpose:** Facilitate low level communication and transaction creation

#### Chain Configuration

* **Requirement:**
  * Chain ID and network details (mainnet/testnet)
  * Native token information (eg: gas currency)
  * Gas fee estimation logic specific to the chain
* **Purpose:** Configure the GlueX Protocol to understand chain specific properties

#### Implementation of Default Functionalities\*

* **Requirement:**
  * Multicall for efficient batching of read operations
  * Fetching token balances of specific addresses
  * Calculating computation cost and factor to ensure transaction validity
  * Estimating gas (transaction cost) for blockchain operations
  * Signing transactions securely and efficiently
* **Purpose:** Abstraction of default functional requirements for Gluex Protocol to interact with different
  blockchains

#### Error Handling and Fallbacks

* **Requirement:** Implement robust error handling mechanisms to account for chain-specific quirks or downtime (eg:
  transaction reverts, RPC errors)
* **Purpose:** Maintain reliability and uptime in multi chain operations

#### Abstracting Blockchain Differences

* **Requirement:** Develop chain specific logic to abstract differences in:
  * Consensus algorithms (eg: Proof-of-Stake vs Proof-of-Work).
  * Transaction formats and metadata
  * Gas fee structures and dynamic adjustments
* **Purpose:** Provide a unified GlueX interface to interact with different blockchains seamlessly

<Info>
  With these steps and requirements met, GlueX Blockchain Modules can provide
  robust and efficient integration, allowing the GlueX Protocol to operate
  across various blockchain ecosystems
</Info>


# Intent Module
Source: https://docs.gluex.xyz/documentation/modules/intent



## Overview

A GlueX Intent Module represents a high level abstraction designed to manage and execute specific user defined intents
across blockchains. An intent represents a high level goal, such as executing a token swap, placing a limit order, or
managing cross chain transactions. This module encapsulates all logic required to achieve the desired outcomes
efficiently, including search space generation, state management and optimization

### Key Features

1. **Modular Design**:Each intent module is self contained and tailored for a specific type of task, such as swaps or limit orders. This
   modularity ensures flexibility, ease of maintenance and scalability for the GlueX framework

2. **Blockchain Agnosticism**: Intent modules are designed to operate seamlessly across different blockchains. They can handle both native and wrapped
   tokens, allowing users to interact with multiple ecosystems without manual adjustments

3. **Optimization and Cost Efficiency**: GlueX Intent modules users advanced optimization algorithms to:

   * Balance execution costs (eg: gas fees) and benefits
   * Select the best execution paths based on real time conditions, such as liquidity and token prices

4. **Dynamic State Management**: The modules track and transition between various states during execution. This includes:

   * Tracking token balances
   * Maintaining execution maps and search spaces
   * Managing dependencies for accurate and efficient execution


# Liquidity Module
Source: https://docs.gluex.xyz/documentation/modules/liquidity



## Overview

A GlueX Liquidity module is an integral component of the GlueX SDK. Each module is a python based abstraction of a
specific DeFi protocol's liquidity functionality. These modules enable seamless interaction with various decentralized
finance (DeFi) protocols by unifying their distinct architectures into a standardized framework

These modules handle operations such as swapping tokens, lending, borrowing, staking and yield optimization. By
abstracting protocol complexities, GlueX ensures efficient aggregation of liquidity across multiple protocols,
optimizing trades and maximizing returns for users

### Key Features

* **Protocol Abstraction**: Each module serves as an interface to a specific protocol, encapsulating its functionality
  within a Python codebase
* **Unified Framework**: The modules standardize interactions, allowing GlueX to perform actions such as token swaps,
  lending and staking in a unified manner, regardless of the underlying protocol
* **Efficiency and Scalability**: By consolidating multiple protocols into a single framework, GlueX Liquidity modules
  ensure high performance and scalability, even as more protocols are integrated
* **Extensibility**: The modular architecture allows easy addition of new protocols, enabling GlueX to adapt quickly to
  evolving DeFi ecosystems

### Subtypes

* **Swapping modules**

* **Description**: These modules handle token exchanges using protocols that provide Automated Market Makers (AMMs)

* Example:

  * Uniswap v2: Facilitates direct token to token swaps with constant product formula

* **Lending modules**

* **Description**: These modules interact with protocols enabling lending and borrowing of assets

* Example:

  * Aave v3: Supports lending and borrowing, with features like variable interest rates and risk adjusted pools

* **Staking modules**

* **Description**: These modules connect to protocols offering staking services, locking tokens to secure networks or earn
  rewards

* Example:

  * Lido Finance: Provides staking derivatives like stETH (staked ETH)

* **Yield Optimization modules**

* **Description**: These modules work with protocols that maximize returns by automatically reallocating funds across
  various strategies

* Example:
  * Yearn Finance: Aggregates yields from lending protocols and optimizes returns

## Integrating a liquidity module

### Types of Liquidity modules

#### AMM Liquidity modules

| Type          | Examples                      | Factory              | Quoter              |
| ------------- | ----------------------------- | -------------------- | ------------------- |
| COMPLETE\_AMM | UniswapV3, BalancerV2         | Has factory contract | Has quoter contract |
| PARTIAL\_AMM  | AaveV3, Sparklend             | Has factory contract | No quoter contract  |
| MINIMAL\_AMM  | MakerPSM, Lido\_wsteth\_steth | No factory contract  | No quoter contract  |

#### MM Liquidity modules

| Type        | Examples                                           | Order Type              |
| ----------- | -------------------------------------------------- | ----------------------- |
| MM\_PF\_LOB | 0x limit order book, HashFlow API                  | Partial Fillable Orders |
| MM\_FOK     | Bebop API, Native API, HashFlow API, other MM APIs | Fill or Kill orders     |

#### Classification by Number of Liquidity Pools

| Classification      | Examples                      | Indexing     | Factory                | Number of Pools |
| ------------------- | ----------------------------- | ------------ | ---------------------- | --------------- |
| Multi pool modules  | UniswapV3, BalancerV2, AaveV2 | Required     | Has a factory contract | Multiple        |
| Single pool modules | MakerPSM, Lido\_steth\_wsteth | Not required | No factory contract    | One             |

### Detailed Types

##### Complete Liquidity modules

Complete Liquidity modules follow all best practices of a well defined liquidity module

* The protocol providing the module hosts a liquidity library
* The protocol deployed a quoter contract to assist GlueX with testing
* The protocol released the liquidity behind an immutable factory contract

**Benefits**:

* End to end testing is automated
* Fastest onboarding process due to adherence to best practices

##### Partial Liquidity modules

Partial Liquidity modules adhere to only a subset of best practices

* The protocol does not host a liquidity library, making pool indexing more complex
* Indexing is achieved via RPC calls to smart contracts, often requiring custom implementations
* Automated end to end testing is possible with well specified GluexQL queries

**Challenges**:

* Onboarding can be slower due to the need for query review and approval

##### Minimal Liquidity modules

Minimal Liquidity modules deviate significantly from best practices

* The protocol does not host a liquidity library or support RPC based indexing, making the module non indexable
* End to end testing is not possible due to lack of indexability
* Requires extensive manual review and expert evaluation for onboarding

**Challenges**:

* Slowest onboarding process due to high dependency on manual validation

### Integration Requirements

All liquidity module integrations must satisfy the following

1. **Testing Coverage**: Achieve at least 95% coverage in the end-to-end testing framework
2. **Guardian Approval**: Obtain approval from at least three “GlueX Guardians”

#### End to End Testing Framework

The testing framework is designed to help GlueX and liquidity module integrators streamline the integration process.
However, approval by at least three GlueX Guardians is mandatory. The review process focuses on the following
qualitative aspects:

**1. Quoting Contract Verification**

* Is the quoting contract code verified in the block explorer?
* Is the quoting contract immutable?

**2. GlueX Coding Standards Compliance**

* Is the liquidity module written according to the GlueX coding standards?

**3. Reputation of the Protocol Team**

* Is the protocol behind the liquidity module developed by a highly reputable team/organization?

**4. Smart Contract Verification**

* Are the smart contracts verified on the block explorer?
* Is the source code of the smart contracts available?

**5. Smart Contract Immutability**

* Are the smart contracts immutable, or are they behind a proxy contract?

**6. Factory Contract Characteristics**

* Is the factory contract immutable?
* Is the factory contract a proxy contract?


# Originator Module
Source: https://docs.gluex.xyz/documentation/modules/originator



GlueX Originator modules are specialized components within the GlueX Protocol designed to seamlessly integrate with settlement protocols to fetch and manage orders. They serve as a critical link between decentralized financial applications and the GlueX ecosystem, fetching and standardizing orders from various settlement protocols. This enables a unified, protocol agnostic approach to order processing within GlueX

## Overview

The GlueX Originator Module maintains metadata related to settlement protocols, manages inventories needed for settlements and stores settlement specific information essential for executing swaps on-chain

<img className="rounded" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=7a87bc4153b08b6c2db1b231eae955d6" alt="Originator Modules in the GlueX ecosystem" label="Originator Modules in the GlueX ecosystem" width="1108" height="517" data-path="images/documentation/modules/originator-1.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f06980f664ce5dccb96c13ad4321b554 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bfbab00cec8d33750daa891721db7118 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=5000937a7373d89f717a07dfe8346000 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=1660a6734eebcd26cd2f80f58a8a8922 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=f6b00e0ac08bf33e0f1521b05984d15a 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-1.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=b27fd32b9560b5268dce70f159573926 2500w" data-optimize="true" data-opv="2" />

### Key Features

1. **Order Collection**: Originator modules fetch orders from settlement protocols like UniswapX and CowSwap through their APIs, providing GlueX with real time liquidity and trade opportunities
2. **Intent Abstraction**: Retrieved orders are converted into standardized GlueX intent objects, enabling uniform trade handling across different protocols
3. **Metadata Retrieval**: The blockchain module gathers required blockchain details, ensuring smooth execution, especially for cross chain operations
4. **Execution Map**: GlueX uses liquidity modules to calculate optimal execution paths, minimizing costs and maximizing efficiency
5. **Settlement Object**: The execution map and order details are used to create settlement objects for on-chain execution
6. **On-Chain Execution**: Settlement objects are executed on-chain, completing the transaction securely and efficiently

### Subtypes

* **Bridge Intent Module**:
  * Facilitates cross chain transfers by setting up interactions between different blockchain networks
  * Handles validations, fee estimations and execution paths for assets moving between chains
* **Chain Intent Module**:
  * Manages interactions limited to a single blockchain
  * Simplifies execution and state management for native transactions, token swaps or other on-chain intents

## Integrating an Originator module

Integrating a settlement protocol with GlueX only requires you to furnish a few services and interfaces that GlueX can use. All other aspects will be handled by GlueX

<img className="rounded" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=124248de845cf2b353bace1b299835c7" alt="Integrating an Originator module to GlueX Protocol" label="Integrating an Originator module to GlueX Protocol" width="1216" height="536" data-path="images/documentation/modules/originator-2.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=bd9f8ab43776878d753d731626fd9653 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=d96abf938a7b82139f73c89ba8d224a8 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2796ff40a67718f20d308d1c0ad1cba5 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=17838834f347a3873fe9b6cf9e63e5ba 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=731424a71cd58970d47283d78d68d7fb 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/documentation/modules/originator-2.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=6d2cb3dc0fb12d6bd83d1384abebc0d2 2500w" data-optimize="true" data-opv="2" />

### Required Interfaces

#### API for Order Retrieval

* The protocol must expose an API that allows GlueX to fetch active orders in real time. This API should provide comprehensive details about each order, including tokens involved, amounts, deadlines and any unique order parameters
* The response should provide comprehensive details about the order and must include:
  * Tokens involved
  * Amounts
  * Deadlines / Expiration
  * Any protocol specific parameters
* The API should support high availability and efficient querying to handle the potential volume and frequency of requests made by GlueX

#### Protocol Metadata

* Each order fetched through the API should include all relevant metadata necessary for execution, such as:
  * Blacklisted tokens or pools
  * Fee structures
  * Slippage tolerances
  * Security deposits
  * Cosigner conditions

#### Contract Details

* The protocol must provide comprehensive details about the on-chain contracts used for executing settlements. This includes:
  * **Settlement Contract**: For single chain intents, the protocol must specify the settlement contract address and interface, which handles direct on-chain swaps or transfers within a single blockchain
  * **Escrow Contracts** *(optional for cross-chain intents)*: For cross chain operations, the protocol should detail escrow contracts used to lock funds securely until conditions for release are met. These escrow contracts must handle deposit and withdrawal actions in a secure, atomic manner to facilitate cross-chain settlements
* The protocol should ensure these contracts are well documented, including their ABI and any nuances involved in interacting with them, to allow GlueX integration and interaction

### Optional Enhancements

#### Security and Solvability Measures

* The protocol must implement mechanisms for solvability checks, ensuring that orders can be fulfilled without risk of failure. This may involve exposing services that validate liquidity availability or support pre execution checks

#### Rate and Pricing Information

* If the settlement protocol provides its own pricing or exchange rate service, particularly if your settlement protocol is a bridge intent protocol, it should make these rates available for GlueX to fetch and use in its decision making processes. Accurate and timely rate information ensures that orders are priced correctly and executed efficiently

#### Cross-Chain Intents/ Bridge support (if applicable)

* For protocols operating on multiple chains, we will appreciate documentation on how cross chain transactions are handled, including any relayer services or secret hashing mechanisms used for secure fund transfers
* The protocol should define processes for unlocking assets and managing cross chain liquidity securely

<Note>
  If your protocol uses different mechanisms, we can still integrate it with
  some adjustments :)
</Note>


# Audit and Security
Source: https://docs.gluex.xyz/documentation/references/audit-and-security



At GlueX, we prioritize the security and safety of our users assets above all else.
Our commitment to security is demonstrated through rigorous auditing processes, continuous monitoring and implementation of industry best practices

## Smart Contract Audits

Our smart contracts have undergone comprehensive security audits by leading blockchain security firms

### Router v1.1

* [Pelz (July 2025)](https://github.com/gluexprotocol/gluex-audits/blob/main/GlueX%20Router%20v1.1/GlueX%20Router%20v1.1%20-%20Pelz.pdf)
* [Shieldify (July 2025)](https://github.com/gluexprotocol/gluex-audits/blob/main/GlueX%20Router%20v1.1/GlueX%20Router%20v1.1%20-%20Shieldify.pdf)

### Router v1

* [Pelz (December 2024)](https://github.com/gluexprotocol/gluex-audits/blob/main/GlueX%20Router%20v1/GlueX%20Router%20v1%20-%20Pelz.pdf)
* [Shieldify (December 2024)](https://github.com/gluexprotocol/gluex-audits/blob/main/GlueX%20Router%20v1/GlueX%20%20Router%20v1%20-%20Shieldify.pdf)

<Info>
  All our smart contracts source code is verified on each chain's respective
  block explorer and available open source on [our github
  repository](https://github.com/gluexprotocol/gluex_router_contract) along with
  a full test suite. We believe in maintaining full transparency with our users
  regarding our security practices and audit findings
</Info>


# Frequently Asked Questions
Source: https://docs.gluex.xyz/documentation/references/faq

Find answers to common questions about GlueX APIs, integration, security and more

## General

<AccordionGroup>
  <Accordion title="What is GlueX?">
    GlueX is an abstraction framework that provides developers and partners with
    secure access to an API suite that uniformly represents blockchains,
    intents, intent originators and liquidity providers. It enables the
    deployment of high performance, universal smart order routing algorithms and
    facilitates interaction with decentralized finance, allowing execution of
    complex transactions across multiple EVM networks
  </Accordion>

  <Accordion title="Why should I use GlueX?">
    GlueX simplifies DeFi integration, offers optimal transaction execution
    through intelligent routing, supports a broad range of EVM chains and
    enables complex DeFi operations like swaps, bridges, lending, staking and
    zaps with a one click experience (in a single atomic transaction). It also
    provides economic benefits like zero routing fees and potential positive
    slippage rewards
  </Accordion>

  <Accordion title="What makes GlueX unique compared to other aggregators?">
    GlueX differentiates itself through its intelligent multi chain routing for
    optimal execution, comprehensive support for various DeFi operations
    (including unique "swidge" functionality), MEV resistance to protect against
    sandwich attacks and a developer friendly API with beneficial fee models
  </Accordion>

  <Accordion title="Who is GlueX designed for?">
    GlueX is ideal for application (dapp) developers, crypto wallets
    aggregators, institutional clients and companies looking to seamlessly
    integrate advanced DeFi functionalities into their applications with minimal
    complexity
  </Accordion>

  <Accordion title="Does GlueX charge routing fees?">
    No, GlueX operates with zero routing fees for integrators. Our intelligent
    routing is designed to find the most cost-effective paths for transactions.
    You can learn more about fees [here](/build-with-gluex/router/fee-structure)
  </Accordion>

  <Accordion title="How can I stay updated on GlueX news and developments?">
    You can stay updated by following our official announcements, joining our
    community channels (Telegram and Discord), and regularly checking our
    [documentation](https://docs.gluex.xyz/) and
    [blog](https://mirror.xyz/gluex.eth) for updates
  </Accordion>
</AccordionGroup>

## Core

<AccordionGroup>
  <Accordion title="Is my transaction safe using GlueX?">
    Yes, your transactions are secure with GlueX. Our routing smart contracts
    and API infrastructure are built with advanced security features to
    safeguard against common DeFi risks such as front running and sandwich
    attacks. Additionally, we implement extra protections like [Surge
    Protection](/build-with-gluex/router/advanced-features/surge-protection) to
    ensure reliable and safe onchain interactions for all users
  </Accordion>

  <Accordion title="Which chains does GlueX support?">
    GlueX supports a broad and growing range of EVM compatible chains. While the
    exact list is constantly updated, this typically includes major networks
    like Ethereum Mainnet, Polygon, Binance Smart Chain, Arbitrum, Optimism,
    Avalanche and many others. Refer to our [supported
    networks](/documentation/references/supported-networks) for the most current
    list of supported chains
  </Accordion>

  <Accordion title="What types of transactions can I execute through GlueX?">
    Through GlueX, you can execute a comprehensive range of DeFi transactions
    including: token swaps (DEX aggregation), cross chain asset bridging,
    lending, staking, yield farming, zaps(multi-step DeFi actions into one
    transaction) and our unique 'swidge' operations (swap + bridge)
  </Accordion>

  <Accordion title="How does GlueX compare to other DEX aggregators?">
    GlueX stands out by offering not just DEX aggregation but a holistic DeFi
    API suite covering bridging, lending, staking and complex operations like
    'swidge' across multiple chains. Our intelligent routing optimizes for the
    best price, slippage and gas fees, providing a more comprehensive solution
    than many single focus aggregators
  </Accordion>

  <Accordion title="How does GlueX ensure the best prices for swaps?">
    GlueX uses advanced smart order routing algorithms that aggregate liquidity
    from numerous DEXs and AMMs across all supported EVM chains. It dynamically
    analyzes real time market data to find the most efficient and cost effective
    paths for your token swaps, minimizing slippage and maximizing output
  </Accordion>

  <Accordion title="Are there any limits on transaction amounts?">
    Transaction limits can vary depending on the liquidity available for
    specific token pairs and chains, as well as any network specific
    constraints. While GlueX aims to facilitate transactions of all sizes, very
    large transactions might be split across multiple liquidity sources for
    optimal execution
  </Accordion>

  <Accordion title="Does GlueX integrate with all major DeFi protocols?">
    GlueX continuously expands its integration with a wide array of major DeFi
    protocols for liquidity, lending, staking and more. Our goal is to provide
    comprehensive access to the DeFi ecosystem. For a list of specific
    integrated protocols, please check the [liquidity
    modules](/documentation/references/liquidity-modules) section
  </Accordion>

  <Accordion title="What is MEV resistance in GlueX transactions?">
    MEV (Maximal Extractable Value) resistance in GlueX refers to features
    designed to protect your transactions from malicious MEV attacks like front
    running and sandwich attacks, where bots attempt to profit from your trades.
    Our routing mechanisms aim to minimize these risks to ensure fair execution
  </Accordion>

  <Accordion title="Can I use GlueX for institutional DeFi access?">
    Yes, GlueX APIs are built with robustness and scalability that make them
    suitable for institutional clients seeking secure, efficient and
    programmatic access to DeFi markets and operations. We can provide tailored
    solutions and support for higher volume usage
  </Accordion>

  <Accordion title="How does GlueX handle gas fees?">
    GlueX optimizes for gas efficiency by finding the most gas efficient routes
    and packaging complex transactions into minimal onchain calls. While users
    still pay network gas fees, GlueX aims to reduce the overall cost by
    optimizing the transaction structure
  </Accordion>
</AccordionGroup>

## Integration and API

<AccordionGroup>
  <Accordion title="How do I authenticate requests to the GlueX API?">
    Some GlueX API endpoints require an API key for access, while others may
    allow public usage or offer elevated rate limits with a key. API keys are
    typically passed in the request header as `x-api-key`. For details on
    authentication requirements and usage, see our [API
    Reference](/api-reference/about/overview)
  </Accordion>

  <Accordion title="What’s the difference between '/price' and '/quote'">
    The `/price` endpoint typically provides a snapshot of the current market
    price for a given token pair, often without considering the impact of a
    specific trade size or routing. The `/quote` endpoint, on the other hand,
    provides a concrete proposal for a specific transaction (eg: for a certain
    amount of tokens), including the calculated output amount, estimated gas
    fees, and potential slippage by performing an actual route calculation
  </Accordion>

  <Accordion title="What is surge protection?">
    **Surge Protection** is a built in pre trade safety mechanism designed to
    safeguard users from significant value loss during periods of shallow
    liquidity, extreme market volatility or abrupt price movements
  </Accordion>

  <Accordion title="How do I get an Integrator ID and API Key?">
    You can obtain your unique Integrator ID and API Key by registering on the
    [GlueX Developer Portal](http://portal.gluex.xyz). These credentials are
    required to authenticate your API requests and unlock access to GlueX
    services
  </Accordion>

  <Accordion title="Can I integrate GlueX into any frontend framework?">
    Yes, GlueX provides flexible integration options. While we offer dedicated
    [widget](/build-with-gluex/yield/overview) and ui components for popular
    frameworks, and you can also integrate the widget as an iframe into
    virtually any web application, regardless of the underlying frontend
    framework
  </Accordion>

  <Accordion title="Is there a sandbox or test environment available for development?">
    GlueX currently operates exclusively on mainnet and does not provide a
    testnet environment. For development and integration testing, we recommend
    using small value transactions on supported L2s. Stay tuned for updates, as
    testnet support may be added in the future
  </Accordion>

  <Accordion title="How can I handle API errors in my application?">
    GlueX API responses include standard HTTP status codes and detailed error
    messages in the response body. Your application should implement robust
    error handling logic to parse these responses, notify users and manage
    retries or alternative flows as necessary. Refer to our [API
    Reference](/api-reference/about/overview) for a list of common error codes
    and their meanings
  </Accordion>

  <Accordion title="What are common troubleshooting steps for API integration?">
    Common troubleshooting steps include verifying your keys, checking network
    connectivity, ensuring correct endpoints, validating request body
    parameters, inspecting response error messages and reviewing our
    documentation for the specific endpoint you are using. You can find a
    comprehensive list of common issues and troubleshooting steps
    [here](/troubleshooting/general/initial-steps)
  </Accordion>
</AccordionGroup>

## Developer and Support

<AccordionGroup>
  <Accordion title="Where can I find the API documentation?">
    The comprehensive API documentation is available on our website under the
    [API Reference](/api-reference/about/overview) section. It includes detailed
    information on endpoints, request/response schemas, authentication and
    examples
  </Accordion>

  <Accordion title="How do I report a bug or issue?">
    You can report bugs or issues by opening a discussion or creating an issue
    in our official github repository. Alternatively, you can reach out to our
    support team via our dedicated support channels
  </Accordion>

  <Accordion title="What kind of developer support does GlueX offer?">
    GlueX offers developer support through documentation, quickstart guides,
    community channels (Telegram) and direct technical support for partners and
    enterprise clients
  </Accordion>

  <Accordion title="Can I contribute to GlueX's open source projects?">
    GlueX has some open source components, and details on how to contribute will
    be available in the respective github repositories. We welcome community
    contributions that help improve our platform
  </Accordion>

  <Accordion title="How can I request a new feature or chain integration?">
    To request a new feature or chain integration, submit a proposal or
    discussion via our official repository, community channels or contact our
    partnership team directly. For guidance on submitting feature requests, see
    our [feature request guide](/documentation/requests/feature-request)
  </Accordion>

  <Accordion title="Do you offer technical workshops or tutorials?">
    GlueX offers technical workshops, twitter spaces and more in depth tutorials
    periodically. Please check our blog or announcement channels for information
    on upcoming events
  </Accordion>

  <Accordion title="What is the typical response time for support inquiries?">
    Response times for support inquiries vary based on the channel and the
    nature of the query. Critical issues typically receive faster responses. For
    general inquiries, community channels can often provide quick answers from
    peers or active team members
  </Accordion>

  <Accordion title="How often are the API versions updated?">
    GlueX aims to continuously improve its APIs and may release updates
    periodically. We follow semantic versioning and any breaking changes are
    communicated well in advance, along with migration guides
  </Accordion>
</AccordionGroup>

## Pricing and Plans

<AccordionGroup>
  <Accordion title="What is the pricing model for GlueX API usage?">
    GlueX API operates on a transparent pricing model. While there are zero
    routing fees for transactions, specific plans might involve usage based
    fees, tier based access or custom agreements for high volume partners. For
    detailed pricing, please refer to our dedicated [pricing page](#) or contact
    our partnership team
  </Accordion>

  <Accordion title="Are there different tiers or plans available for API access?">
    Yes, we offer different tiers or plans tailored to various needs, from free
    developer access to enterprise grade solutions for high volume usage. Each
    tier might come with different rate limits, features and support levels
  </Accordion>

  <Accordion title="Do you offer a free tier for testing and development?">
    Yes, GlueX provides a free tier to allow developers and small application to
    test and build their integrations without incurring costs. This typically
    comes with certain [rate limits and
    features](/build-with-gluex/router/api-tiers-limits)
  </Accordion>

  <Accordion title="How are fees calculated for transactions?">
    While GlueX itself charges zero routing fees, transactions on the blockchain
    incur network (gas) fees. Our API optimizes for these gas fees. Any
    integrator specific fees or revenue sharing models (eg: from positive
    slippage, surplus) are detailed in the partner agreement
  </Accordion>

  <Accordion title="What are the costs associated with using the GlueX widget?">
    The GlueX widget typically uses the same underlying API as direct API
    integrations, and its usage costs are generally covered by your API plan.
    There are no separate "widget fees" or hidden charges
  </Accordion>

  <Accordion title="Can I get a custom pricing plan for my business?">
    Yes, for high volume usage, specialized features or unique business models,
    GlueX offers custom pricing plans. Please contact our partnership team to
    discuss your specific requirements
  </Accordion>

  <Accordion title="How do I monitor my API usage and associated costs?">
    We offer a [developer portal](https://portal.gluex.xyz) where you can
    monitor your API usage, view analytics and track any associated costs. This
    dashboard gives you insights into your consumption patterns
  </Accordion>

  <Accordion title="What happens if I exceed my API rate limits?">
    If you exceed your API rate limits, your requests may be temporarily
    throttled or rejected with a `429 Too Many Requests` HTTP status code. You
    might need to upgrade your plan or implement rate limiting strategies on
    your end
  </Accordion>

  <Accordion title="Are there any hidden fees?">
    GlueX is committed to transparent pricing. All fees, whether for API usage
    or network transactions, are clearly communicated. We aim for no hidden
    costs, but always recommend reviewing your specific plan details
  </Accordion>

  <Accordion title="Does the pricing include access to all GlueX APIs?">
    TBD
  </Accordion>
</AccordionGroup>

## Security and Audits

<AccordionGroup>
  <Accordion title="Has GlueX undergone security audits?">
    Yes, security is paramount for GlueX. Our smart contracts and core
    infrastructure undergo regular security audits by reputable third party
    security firms. Audit reports are published
    [here](/documentation/references/audit-and-security) for transparency
  </Accordion>

  <Accordion title="How does GlueX protect user funds?">
    GlueX operates as a non custodial service for most operations, meaning user
    funds remain in their own wallets and are never held by GlueX. Transactions
    are executed directly from the user's wallet via smart contracts, minimizing
    counterparty risk
  </Accordion>

  <Accordion title="What measures does GlueX take to prevent exploits?">
    GlueX employs a multi faceted approach to security, including rigorous smart
    contract auditing, continuous monitoring, bug bounty programs, adherence to
    best practices in secure coding and intelligent transaction routing to avoid
    vulnerable liquidity sources
  </Accordion>

  <Accordion title="Are GlueX's smart contracts open source?">
    Yes, GlueX's smart contracts are open source and publicly verifiable on
    blockchain explorers. This transparency allows the community and security
    researchers to inspect the code
  </Accordion>

  <Accordion title="What is the role of smart contract audits?">
    Smart contract audits are independent reviews conducted by security experts
    to identify and mitigate potential vulnerabilities, bugs and security risks
    in the smart contracts that power GlueX's operations, ensuring their
    integrity and safety
  </Accordion>

  <Accordion title="Is my API Key secure?">
    Your API Key is a sensitive credential. It should be kept confidential and
    never hardcoded into clien -side code. We recommend using environment
    variables or a secure backend proxy to manage your API Key, and applying
    domain restrictions where possible
  </Accordion>

  <Accordion title="Does GlueX store any personal user data?">
    GlueX adheres to strict privacy policies. As a non custodial service, we
    primarily process onchain transaction data and do not store personal user
    data beyond what is necessary for service provision
  </Accordion>

  <Accordion title="How does GlueX protect against front running and sandwich attacks?">
    GlueX's Router API employs MEV resistant strategies and smart order routing
    that are designed to minimize the risk of front running and sandwich attacks
    by optimizing transaction paths and potentially utilizing transaction relays
    where available
  </Accordion>

  <Accordion title="What is the typical update frequency for security patches?">
    Security patches are deployed as needed, with critical vulnerabilities
    addressed immediately. Regular maintenance updates also include security
    enhancements. Details on specific updates are communicated through official
    channels
  </Accordion>
</AccordionGroup>

## Performance and Reliability

<AccordionGroup>
  <Accordion title="What is GlueX's API uptime guarantee?">
    GlueX is committed to high availability. While specific uptime guarantees
    (SLA) may depend on your service plan, we strive for industry leading
    uptime, leveraging robust infrastructure and redundant systems to ensure
    continuous API access
  </Accordion>

  <Accordion title="How fast are GlueX API responses?">
    GlueX APIs are optimized for low latency. Response times can vary based on
    network congestion, the complexity of the query (eg: `quote` vs `price`),
    and your geographical location, but we aim for near real time responses
  </Accordion>

  <Accordion title="How does GlueX ensure data accuracy for exchange rates and liquidity?">
    Our Exchange Rate API and Router API use real time data feeds aggregated
    from numerous onchain and offchain sources, combined with sophisticated
    algorithms to ensure high accuracy and up to date information on prices and
    liquidity
  </Accordion>

  <Accordion title="What is the API's capacity for requests per second (RPS)?">
    API capacity and rate limits depend on your specific service plan. Higher
    tiers typically offer increased requests per second (RPS) to support larger
    scale applications. Details are available [here](#) or via direct inquiry
  </Accordion>

  <Accordion title="How does GlueX handle blockchain network congestion?">
    GlueX's intelligent routing algorithms account for network congestion when
    calculating optimal paths. While high congestion can affect transaction
    confirmation times, we aim to provide the best possible execution under
    prevailing network conditions
  </Accordion>

  <Accordion title="Is there a status page for GlueX services?">TBD</Accordion>

  <Accordion title="How quickly are new chains and protocols integrated?">
    GlueX is committed to rapidly integrating new EVM compatible chains and
    prominent DeFi protocols on demand. Integration timelines depend on the
    complexity of the network/protocol, but we strive to expand our coverage
    continuously
  </Accordion>
</AccordionGroup>

## Compliance and Legal

<AccordionGroup>
  <Accordion title="Is GlueX compliant with relevant financial regulations?">
    GlueX operates in the decentralized finance space. We prioritize compliance
    with applicable laws and regulations in the jurisdictions we operate. As the
    regulatory landscape for DeFi evolves, we continuously adapt our practices
  </Accordion>

  <Accordion title="Does GlueX perform KYC/AML checks?">
    As a non custodial API provider, GlueX typically does not perform direct KYC
    (Know Your Customer) or AML (Anti Money Laundering) checks on end users. Our
    partners are responsible for their own compliance obligations based on their
    service offerings
  </Accordion>

  <Accordion title="What are the Terms of Service for using GlueX APIs?">
    The full Terms of Service for using GlueX APIs and services are available
    [here](https://www.gluex.xyz/legal/terms-of-service). It is important to
    review these terms to understand your rights and obligations as an
    integrator
  </Accordion>

  <Accordion title="Does GlueX comply with data privacy regulations (eg: GDPR, CCPA)?">
    GlueX adheres to relevant data privacy regulations like GDPR and CCPA where
    applicable. As a non custodial service, we minimize the collection of
    personal identifiable information. Our [Privacy Policy
    provides](https://www.gluex.xyz/legal/privacy-policy) full details
  </Accordion>

  <Accordion title="Does GlueX require any specific licenses for integrators?">
    TBD
  </Accordion>

  <Accordion title="How does GlueX handle intellectual property rights for integrators?">
    Our Terms of Service outline the intellectual property rights related to the
    APIs, SDKs and documentation, as well as how integrators can use our brand
    assets
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="What are common troubleshooting steps for API integration?">
    Common troubleshooting steps include verifying your keys, checking network
    connectivity, ensuring correct endpoints, validating request body
    parameters, inspecting response error messages and reviewing our
    documentation for the specific endpoint you are using. You can find a
    comprehensive list of common issues and troubleshooting steps
    [here](/troubleshooting/general/initial-steps)
  </Accordion>

  <Accordion title="Where can I find detailed error codes and messages?">
    Detailed error codes, their meanings and potential solutions are documented
    in the respective sections of our [API
    Reference](/api-reference/about/overview). This is your primary resource for
    understanding specific API error responses
  </Accordion>

  <Accordion title="I'm getting a 429 Too Many Requests error. How can I resolve this?">
    This error means you've exceeded your plan's API rate limits. You can
    resolve it by implementing rate limiting, spacing out your requests, or
    upgrading your API plan to a higher tier with increased rate limits
  </Accordion>

  <Accordion title="My API key seems invalid. What should I do?">
    First, ensure you're using the correct API key from your GlueX developer
    portal. If the issue persists, regenerate your API key in the portal and if
    still unsuccessful, contact our support team
  </Accordion>
</AccordionGroup>

***

**Still have questions?**

Feel free to reach out on [Telegram](https://t.me/+6NrwSlEPAsA3MzE0) or open a discussion in our [Github](https://github.com/gluexprotocol) repo - our
team and community are here to help!


# Licence and Legal
Source: https://docs.gluex.xyz/documentation/references/license-and-legal

Understand the legal aspects of using GlueX APIs and UI Components

Welcome to the GlueX legal information hub for developers and partners. As a GlueX developer, partner, or contributor integrating with our ecosystem,
it's essential that you understand the legal framework governing your access and use of our APIs, UI Components, documentation and the broader GlueX Protocol.

This page provides a high-level overview of key legal considerations and serves as a central point for accessing our comprehensive legal documentation.
Your continued use of GlueX APIs, UI Components, our self-integration repository, or any other GlueX-provided resources signifies your acknowledgement and
agreement to be bound by the terms outlined in our full legal documents

<Note>
  Please read this information carefully. If you have any questions or require
  further clarification about the legal aspects of using the GlueX services,
  please contact our team at [legal@gluex.xyz](mailto:legal@gluex.xyz)
</Note>

## Overview of Legal Documents

The GlueX ecosystem operates under a robust legal framework designed to ensure transparency, security, and compliance. Below are the core legal documents that govern your relationship with GlueX

* [**API Suite License Agreement**](https://gluex.xyz/legal/api-license):
  This agreement specifically details the terms and conditions for accessing and using the GlueX APIs.
  It covers aspects such as the scope of your license, usage restrictions (including rate limits and prohibited activities),
  intellectual property rights related to the APIs, confidentiality, and support provisions

* [**General Terms of Service**](https://gluex.xyz/legal/terms-of-service):
  These terms govern the overall use of all GlueX Services, including our website, decentralized finance (DeFi) transaction services, and any related products or functionalities.
  This document covers eligibility, restricted jurisdictions, the nature of our non-custodial services, compliance obligations (eg: AML/KYC),
  intellectual property ownership, disclaimers, and limitations of liability

* [**Widget Terms of Use**](https://gluex.xyz/legal/widget-terms):
  If you integrate the GlueX Widget into your website or application, these specific terms apply.
  They outline the license grant and restrictions for widget usage, data collection and privacy considerations pertinent to the widget,
  service availability, and compliance responsibilities for integrators

* [**Privacy Policy**](https://gluex.xyz/legal/privacy-policy):
  This policy describes how GlueX collects, uses, shares, and protects personal information when you access or use our website, APIs, widget and other related services.
  It details the types of information collected, purposes of use, data sharing practices, data retention, security measures and your user rights

## Key Legal Considerations

When building with or integrating GlueX APIs, UI Components or contributing to the protocol, keep the following important legal points in mind:

* **License Scope and Limitations:**
  The licenses granted for our APIs, UI Components and open source code are generally limited, non-exclusive, non-transferable and revocable.
  They do not permit sublicensing or resale of direct access without explicit prior written consent

* **Usage Restrictions:**
  There are specific prohibitions against actions such as reverse engineering, decompiling, creating competing services, circumventing security measures
  or engaging in any activities that could disrupt GlueX's services or violate applicable laws. Your use must always be for lawful purposes

* **Open-Source Contribution (Self-Integration):**
  While our core code is open-source (typically MIT/Apache license), contributions to the [GlueX Liquidity Module Self-Integration Repository](https://github.com/gluexprotocol/liquidity-module-self-integration)
  are subject to the terms of that repository

* **End-User Agreements:**
  If your application or service integrates GlueX functionalities for your end users, you are responsible for ensuring your own terms of service
  and privacy policy adequately inform your users and protect GlueX's rights and interests as a third party service provider

* **Ownership and Intellectual Property:**
  GlueX retains all rights, titles, and interests in its platform, APIs, UI Components, content, trademarks, logos and proprietary technology.
  Your license to use these does not transfer any ownership to you

* **Data Privacy Compliance:**
  When using GlueX APIs or the Widget, certain transaction logs, IP addresses and usage metrics may be collected and processed by GlueX as outlined in our Privacy Policy.
  You must also ensure that your own collection and handling of user data comply with all applicable data protection laws (eg: GDPR, CCPA)

* **Regulatory & Sanctions Compliance:**
  You are solely responsible for ensuring that your use of GlueX Services complies with all applicable laws and regulations in your jurisdiction,
  including but not limited to anti-money laundering (AML), know-your-customer (KYC) and sanctions compliance (eg: OFAC, EU, UN restrictions)

* **No Warranties & Assumption of Risk:**
  GlueX Services (APIs, Widget, Protocol) are provided "as-is" and "as-available." We offer no warranties regarding uninterrupted operation, freedom from errors, or accuracy.
  You acknowledge and accept the inherent risks of decentralized financial transactions, including smart contract vulnerabilities, market volatility
  and the irreversibility of blockchain transactions. GlueX is not liable for indirect or consequential damages

## Legal Inquiries

If you have any specific questions about the legal aspects of using GlueX APIs, UI Components or any of our legal documentation, please contact us directly:

**Email:** [legal@gluex.xyz](mailto:legal@gluex.xyz)

<Warning>
  The information provided on this page is a summary for guidance only. It is
  not exhaustive and does not constitute legal advice. Always refer to the
  complete legal documents linked above for the definitive and most current
  information about your rights and obligations
</Warning>


# null
Source: https://docs.gluex.xyz/documentation/references/liquidity-modules



export const ProtocolsTable = () => {
  const [protocols, setProtocols] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState(null);
  React.useEffect(() => {
    fetch("https://raw.githubusercontent.com/gluexprotocol/ecosystem/refs/heads/main/data/protocols.json").then(res => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }).then(data => {
      setProtocols(data);
      setLoading(false);
    }).catch(err => {
      setError(err);
      setLoading(false);
    });
  }, []);
  if (error) {
    return <div className="p-4">
        <p className="text-red-600 dark:text-red-400">
          Error loading protocols: {error.message}
        </p>
      </div>;
  }
  return <div className="w-full overflow-x-auto">
      <table className="w-full border-collapse">
        <thead>
          <tr className="border-b border-gray-200 dark:border-gray-700">
            <th className="text-left py-3 px-4 font-medium text-gray-900 dark:text-gray-100">
              Protocol
            </th>
            <th className="text-left py-3 px-4 font-medium text-gray-900 dark:text-gray-100">
              Description
            </th>
            <th className="text-left py-3 px-4 font-medium text-gray-900 dark:text-gray-100">
              Category
            </th>
            <th className="text-left py-3 px-4 font-medium text-gray-900 dark:text-gray-100">
              Chains
            </th>
          </tr>
        </thead>
        <tbody>
          {loading ? Array.from({
    length: 8
  }).map((_, idx) => <tr key={idx} className="border-b border-gray-100 dark:border-gray-800 animate-pulse">
                  <td className="py-4 px-4">
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 rounded bg-gray-200 dark:bg-gray-700"></div>
                      <div className="w-24 h-4 rounded bg-gray-200 dark:bg-gray-700"></div>
                    </div>
                  </td>
                  <td className="py-4 px-4">
                    <div className="w-full h-4 rounded bg-gray-200 dark:bg-gray-700"></div>
                  </td>
                  <td className="py-4 px-4">
                    <div className="w-16 h-4 rounded bg-gray-200 dark:bg-gray-700"></div>
                  </td>
                  <td className="py-4 px-4">
                    <div className="w-20 h-4 rounded bg-gray-200 dark:bg-gray-700"></div>
                  </td>
                  <td className="py-4 px-4">
                    <div className="w-12 h-4 rounded bg-gray-200 dark:bg-gray-700"></div>
                  </td>
                </tr>) : protocols.map(protocol => <tr key={protocol.identifier} className="border-b border-gray-100 dark:border-gray-800 h-min">
                  <td className="py-4 px-4">
                    <div className="flex items-center gap-3">
                      <img src={`https://raw.githubusercontent.com/gluexprotocol/ecosystem/main/public${protocol.icon}`} alt={`${protocol.name} logo`} className="w-8 h-8 rounded object-contain flex-shrink-0" onError={e => {
    e.currentTarget.onerror = null;
    e.currentTarget.src = "https://via.placeholder.com/32";
  }} />
                      <span className="font-medium text-gray-900 dark:text-gray-100">
                        {protocol.name}
                      </span>
                    </div>
                  </td>
                  <td className="px-4 max-w-md">
                    <p className="text-sm text-gray-600 dark:text-gray-400 line-clamp-3">
                      {protocol.description}
                    </p>
                  </td>
                  <td className="px-4">
                    <div className="flex flex-wrap gap-1">
                      {protocol.category.map(cat => <span key={cat} className="px-2 py-1 text-xs rounded border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300">
                          {cat}
                        </span>)}
                    </div>
                  </td>
                  <td className="px-4">
                    <div className="text-sm text-gray-600 dark:text-gray-400">
                      {protocol.chains.slice(0, 3).join(", ")}
                      {protocol.chains.length > 3 && <span className="text-gray-500 dark:text-gray-500">
                          {" "}
                          +{protocol.chains.length - 3} more
                        </span>}
                    </div>
                  </td>
                </tr>)}
        </tbody>
      </table>
    </div>;
};

<ProtocolsTable />


# Router v1
Source: https://docs.gluex.xyz/documentation/references/router-v1



The `GluexRouter` smart contract (version 1) facilitates secure and efficient execution of complex DeFi operations. It provides versatile functionality for routing tokens, collecting protocol fees and executing diverse onchain interactions via a structured interface. The contract prioritizes high security and usability, ensuring strict adherence to predefined routing and slippage rules

### Deployment

The `GluexRouter-v1` contract is deployed at the following address on the [supported chains](/documentation/references/supported-networks) by GlueX:

**Contract Address**: `0x6Ec7612828B776cC746fe0Ee5381CC93878844f7`

### Functions

#### Swap

Executes a token routing operation using a specified `IExecutor` contract and predefined interaction data. This function is the primary entry point for orchestrating multi-step DeFi flows

**Function Signature**

```solidity
function swap(
    IExecutor executor,
    RouteDescription calldata desc,
    Interaction[] calldata interactions,
    uint256 deadline
) external payable returns (uint256 finalOutputAmount);
```

**Parameters**

* `executor` (IExecutor): The executor contract performing the interactions
* `desc` (RouteDescription calldata): The route description containing input, output and fee details
* `interactions` (Interaction\[] calldata): The interactions encoded for execution by the executor
* `deadline` (uint256): The timestamp after which the transaction will revert

**Returns**

* `finalOutputAmount` (uint256): The final amount of output token received

**Reverts**

* `Deadline passed`: If the block timestamp exceeds the deadline
* `Routing fee too high`: If `desc.routingFee` exceeds \_MAX\_FEE
* `Routing fee too low`: If `desc.routingFee` is below \_MIN\_FEE
* `Negative slippage limit`: If `desc.minOutputAmount` is less than or equal to zero
* `Slippage limit too large`: If `desc.minOutputAmount` exceeds `desc.outputAmount`

### Events

#### Routed

Emitted upon the successful completion of a token routing operation

**Event Signature**

```solidity
event Routed(
    bytes indexed uniquePID,
    address indexed userAddress,
    address outputReceiver,
    IERC20 inputToken,
    uint256 inputAmount,
    IERC20 outputToken,
    uint256 outputAmount,
    uint256 partnerFee,
    uint256 routingFee,
    uint256 finalOutputAmount
);
```

**Parameters**

* `uniquePID` (bytes): The unique identifier (integrator id) for the partner
* `userAddress` (address): The address of the user who initiated the route
* `outputReceiver` (address): The address of the receiver of the output token
* `inputToken` (IERC20): The ERC20 token used as input
* `inputAmount` (uint256): The amount of input token used for routing
* `outputToken` (IERC20): The ERC20 token received as output
* `outputAmount` (uint256): The expected output amount from the route
* `partnerFee` (uint256): The fee charged for the partner
* `routingFee` (uint256): The fee charged for the routing operation
* `finalOutputAmount` (uint256): The actual output amount received after routing


# Router v1.1
Source: https://docs.gluex.xyz/documentation/references/router-v1.1



The `GluexRouter` smart contract (version 1.1) represents an optimized iteration of our routing infrastructure. It provides enhanced functionality for highly efficient token routing, dynamic fee collection and the precise execution of onchain interactions through a refined, structured interface. This version introduces advanced mechanisms for surplus and slippage sharing

### Deployment

The `GluexRouter-v1.1` contract is deployed at the following address on the [supported chains](/documentation/references/supported-networks) by GlueX:

**Contract Address**: `0xe95F6EAeaE1E4d650576Af600b33D9F7e5f9f7fd`

### Functions

#### Swap

Executes a token routing operation through an external `IExecutor` contract using a predefined set of interactions

**Function Signature**

```solidity
function swap(
    IExecutor executor,
    RouteDescription calldata desc,
    Interaction[] calldata interactions
) external payable returns (uint256 finalOutputAmount);
```

**Parameters**

* `executor` (`IExecutor`): The executor contract responsible for processing interactions
* `desc` (`RouteDescription calldata`): A structured object containing input/output token information, fees, limits and recipient addresses
* `interactions` (`Interaction[] calldata`): An array of interaction steps to be executed by the executor

**Returns**

* `finalOutputAmount` (`uint256`): The final amount of output token received by the `outputReceiver` after fees and surplus/slippage sharing

**Reverts**

* `InvalidNativeTokenInputAmount`: If the ETH value sent does not match the expected input amount
* `RoutingFeeTooHigh`: If `desc.routingFee` exceeds the maximum allowed fee (`_MAX_FEE`)
* `RoutingFeeTooLow`: If `desc.routingFee` is below the minimum required fee (`_MIN_FEE`)
* `PartnerSurplusShareTooHigh`: If `desc.partnerSurplusShare` exceeds `_MAX_PARTNER_SURPLUS_SHARE_LIMIT`
* `ProtocolSurplusShareTooLow`: If `desc.protocolSurplusShare` is below `_MIN_PROTOCOL_SURPLUS_SHARE_LIMIT`
* `PartnerSlippageShareTooHigh`: If `desc.partnerSlippageShare` exceeds `_MAX_PARTNER_SLIPPAGE_SHARE_LIMIT`
* `ProtocolSlippageShareTooLow`: If `desc.protocolSlippageShare` is below `_MIN_PROTOCOL_SLIPPAGE_SHARE_LIMIT`
* `ZeroAddress`: If any required address (eg: `inputReceiver`, `outputReceiver`) is a zero address
* `InvalidSlippage`: If `desc.minOutputAmount` is zero
* `SlippageLimitTooLarge`: If `desc.minOutputAmount` exceeds `desc.outputAmount`
* `InsufficientBalance`: If the router does not hold sufficient balance for the intended transfer
* `NativeTransferFailed`: If the native token transfer fails

### Events

#### Routed

Emitted upon successful completion of a routing operation

**Event Signature**

```solidity
event Routed(
    bytes32 indexed uniquePID,
    address indexed userAddress,
    address outputReceiver,
    IERC20 inputToken,
    uint256 inputAmount,
    IERC20 outputToken,
    uint256 finalOutputAmount,
    uint256 partnerFee,
    uint256 routingFee,
    uint256 partnerShare,
    uint256 protocolShare
);
```

**Parameters**

* `uniquePID` (bytes): The unique identifier for the partner
* `userAddress` (address): The address of the user who initiated the route
* `outputReceiver` (address): The address of the receiver of the output token
* `inputToken` (IERC20): The ERC20 token used as input
* `inputAmount` (uint256): The amount of input token used for routing
* `outputToken` (IERC20): The ERC20 token received as output
* `finalOutputAmount` (uint256): The actual output amount received after routing
* `partnerFee` (uint256): The fee charged for the partner
* `routingFee` (uint256): The fee charged for the routing operation
* `partnerShare` (uint256): The share of surplus/slippage allocated to the partner
* `protocolShare` (uint256): The share of surplus/slippage allocated to the protocol


# Supported Networks
Source: https://docs.gluex.xyz/documentation/references/supported-networks

A comprehensive list of chains supported by GlueX

At GlueX, our mission is to provide the most efficient and comprehensive decentralized trading experience possible.
A core part of this mission is supporting a wide array of blockchain networks, allowing you to access fragmented liquidity
and execute trades across diverse ecosystems from a single interface

We continuously evaluate and integrate new networks based on their liquidity, user activity, technological advancements and community demand.
Our focus is primarily on EVM compatible chains due to their broad adoption in DeFi, but we will soon explore and integrate key non EVM chains where significant liquidity
and innovative protocols reside

## Our Supported Networks

Below is a detailed list of the chains currently supported by GlueX, along with their key identifiers and official websites:

| Chain Name                                             | Chain ID | Key identifier | Chain Type |
| ------------------------------------------------------ | -------- | -------------- | ---------- |
| [Arbitrum](https://gluex.xyz/chain/arbitrum)           | 42161    | arbitrum       | EVM        |
| [Avalanche C-Chain](https://gluex.xyz/chain/avalanche) | 43114    | avalanche      | EVM        |
| [Base](https://gluex.xyz/chain/base)                   | 8453     | base           | EVM        |
| [Berachain](https://gluex.xyz/chain/berachain)         | 80094    | berachain      | EVM        |
| [Blast](https://gluex.xyz/chain/blast)                 | 81457    | blast          | EVM        |
| [BNB Smart Chain](https://gluex.xyz/chain/bnb)         | 56       | bnb            | EVM        |
| [Ethereum](https://gluex.xyz/chain/ethereum)           | 1        | ethereum       | EVM        |
| [Gnosis Chain](https://gluex.xyz/chain/gnosis)         | 100      | gnosis         | EVM        |
| [HyperEVM](https://gluex.xyz/chain/hyperevm)           | 999      | hyperevm       | EVM        |
| [Linea](https://gluex.xyz/chain/linea)                 | 59144    | linea          | EVM        |
| [Mantle](https://gluex.xyz/chain/mantle)               | 5000     | mantle         | EVM        |
| [Optimism](https://gluex.xyz/chain/optimism)           | 10       | optimism       | EVM        |
| [Polygon](https://gluex.xyz/chain/polygon)             | 137      | polygon        | EVM        |
| [Scroll](https://gluex.xyz/chain/scroll)               | 534352   | scroll         | EVM        |
| [Sonic](https://gluex.xyz/chain/sonic)                 | 146      | sonic          | EVM        |
| [Taiko](https://gluex.xyz/chain/taiko)                 | 167000   | taiko          | EVM        |
| [Unichain](https://gluex.xyz/chain/unichain)           | 130      | unichain       | EVM        |

<Note>
  You can use the [https://router.gluex.xyz/liquidity](https://router.gluex.xyz/liquidity) endpoint to get the list of
  supported networks and liquidity modules programmatically
</Note>

<Note>
  You can use GlueX Protocol's officially supported [dApp](https://dapp.gluex.xyz) to interact with DeFi
  on any of the supported networks. Beware of imitations. Always verify you are interacting via our official URL.
</Note>


# Requesting a New Chain
Source: https://docs.gluex.xyz/documentation/requests/chain-integration-request



The GlueX Protocol thrives on expanding its reach across the multi chain decentralized finance landscape.
We are continuously working to integrate new networks, layer 2 solutions and testnets to provide users with
the broadest possible liquidity access and the most efficient trading experience

If you have a specific blockchain network or layer 2 you believe GlueX should support, we welcome your requests!
This guide outlines the process for suggesting and potentially accelerating the integration of a new chain into the GlueX ecosystem

**How new Chains are Prioritized**

GlueX employs a data driven and community focused approach to prioritize new chain integrations. Chains are assessed based on factors such as:

* **Trade Volume**: The overall daily or weekly trading activity on the network
* **Total Value Locked (TVL)**: The amount of assets locked in DeFi protocols on the chain
* **Number of Protocols**: The richness of the ecosystem and variety of liquidity sources available
* **User Base**: The size and growth of the active user community
* **Technological Alignment**: Compatibility with our existing infrastructure (currently prioritizing EVM compatible chains than non EVM)
* **Community Demand**: Explicit requests and interest from our users and partners
* **Strategic Importance**: Emerging chains or those with unique features that offer significant value to the GlueX ecosystem

## Requesting a new Chain


# Submitting Feature Requests
Source: https://docs.gluex.xyz/documentation/requests/feature-request



Welcome to our guide on submitting feature requests for GlueX. We value your input and are committed to improving our platform based on community feedback

## How to Submit Feature Requests

You can submit your feature requests through one of the following channels:

* **Telegram Community**: The primary channel for submitting feature requests is through our official Telegram channel
* **Dedicated Feature Form**: Fill out our structured feedback form available at ...

After submitting your feature request, we encourage you to:

* Engage with other community members who might have similar interests
* Our team monitors these discussions and may reach out for further clarification

## Request Guidelines

When submitting a feature request, please consider:

* Be specific about the functionality you'd like to see
* Explain the use case and potential benefits for other users or the ecosystem
* Share any relevant examples, mockups or references that illustrate your idea

<Note>
  Feature implementations are prioritized based on engineering capacity,
  strategic alignment with the GlueX roadmap and community demand (often gauged
  by reactions or continued discussions). While we review all requests, we
  cannot guarantee implementation timelines
</Note>

## Other Types of Feedback

If your feedback relates to:

* **Bug Reports or Technical Issues**: Please follow this guide to report a technical issue or
* **Security Concerns**: Please refer to our ... or contact us directly at ... for security related matters

We appreciate your contribution to making GlueX better!


# Liquidity Module Integration
Source: https://docs.gluex.xyz/documentation/requests/liquidity-module-integration-request

A comprehensive guide on how to get your liquidity source integrated with GlueX

Welcome to our guide on requesting an integration of your liquidity source with GlueX.
We're excited to explore potential partnerships and expand our liquidity offerings to provide the best execution for our users

GlueX offers two primary paths for integrating liquidity modules, ensuring flexibility and maximizing coverage:

* **Self Integration** for protocols that prefer a direct, permissionless approach
* **Gluing Queue** for those who prefer community or GlueX team driven integration

**What is a GlueX Liquidity Module?**

A GlueX Liquidity module is a standardized Python based integration that allows GlueX to:

* Retrieve liquidity from your protocol and expose it to DeFi dApps and execution optimizers
* Embed your protocol into multi step transactions spanning chains and liquidity sources
* Standardize interaction formats for efficient routing and settlement

Each liquidity module follows a strict interface, ensuring GlueX can efficiently interact with all integrated protocols

## Self Integration

This path allows DeFi protocols to permissionlessly implement and submit their own liquidity modules in Python.
By self integrating, your protocol will be natively accessible to GlueX connected chains, applications and solvers,
enabling seamless execution abstraction without requiring custom infrastructure or manual onboarding from the GlueX team beyond the review process

### How it Works

The [GlueX Liquidity Module Self Integration Repository](https://github.com/gluexprotocol/liquidity-module-self-integration) provides the official framework for this process

**Directory Descriptions**:

* `modules/`: Contains individual liquidity module implementations for each protocol
* `templates/`: Holds the base `LiquidityModule` class, which should not be modified
* `tests/`: Contains test cases to validate the implementation of liquidity modules
* `docs/`: Includes specifications, guidelines and PR submission templates
* `README.md`: The main guide for self integration within the repository
* `requirements.txt`: Lists dependencies required for running the module
* `pytest.ini`: Configuration file for running test cases

<Note>
  Make sure to place your implementation inside the `modules/` directory following
  the naming convention: `<protocol_name>_liquidity_module.py`
</Note>

<Warning>
  Before you start working on your liquidity module integration, please ensure
  your liquidity module has not already been glued to GlueX
</Warning>

### Integrate Now

To submit a Liquidity module via self integration follow the following steps:

* **Fork the Repository**:
  Click the "Fork" button at the top of the [GlueX Liquidity Module Self Integration Repository](https://github.com/gluexprotocol/liquidity-module-self-integration) to create your own copy
* **Implement the Required Python Interfaces**
  * Navigate to your forked repository's `modules/` directory
  * Create a new file named `<protocol_name>_liquidity_module.py` (eg: `aave_liquidity_module.py`)
  * Implement your protocol’s integration by inheriting from `LiquidityModule`
  * Your implementation must implement all the required methods

```python LiquidityModule.py expandable
from templates.liquidity_module import LiquidityModule, Token
from typing import Dict, Optional
from decimal import Decimal

class MyProtocolLiquidityModule(LiquidityModule):
    def get_amount_out(
        self,
        pool_state: Dict,
        input_token: Token,
        input_amount: int,
        output_token: Token,
        output_amount: Optional[int] = None
    ) -> int:
        # Implement logic to calculate output amount
        pass

    def get_amount_in(
        self,
        pool_state: Dict,
        input_token: Token,
        input_amount: Optional[int] = None,
        output_token: Token,
        output_amount: int
    ) -> int:
        # Implement logic to calculate required input amount
        pass

    def get_apy(self, pool_state: Dict) -> Decimal:
        # Implement APY calculation logic
        pass

    def get_tvl(self, pool_state: Dict, token: Optional[Token] = None) -> Decimal:
        # Implement TVL calculation logic
        pass
```

<Warning>
  Do not delete or modify `templates/liquidity_module.py`. This file contains
  the abstract base class that your implementation should inherit from
</Warning>

* **Test Your Integration**
  Run the provided test suite (`tests/test_liquidity_module.py`) to ensure compatibility and correctness

```bash
pytest tests
```

* **Submit a Pull Request (PR)**
  Once your module is complete and tested, submit a PR to the main branch following the required format
  * Push your implementation to your forked repository
  * Open a Pull Request (PR) from your fork to the main repository
  * Follow the PR template in [`/docs/PR-template.md`](https://github.com/gluexprotocol/liquidity-module-self-integration/blob/main/docs/pr-template.md)
  * Your PR must include:
    * Protocol name and details
    * Deployed chains
    * Relevant smart contract addresses for indexing (eg, factories)
    * Relevant pool states and pool state retrieval instructions
    * A summary of your liquidity module implementation
    * Test results and relevant logs
    * Any special considerations for execution or integration

<Info>
  Right after the PR is submitted, a Gluer will assess your submission. If any
  modifications are required, you will receive feedback for adjustments. If
  approved, your protocol will be integrated into GlueX’s execution network
</Info>

### Checklist

Before submitting, ensure you have completed the following:

* [ ] Forked this repository
* [ ] Implemented a new liquidity module in `modules/<protocol_name>_liquidity_module.py`
* [ ] Passed all test cases (`pytest tests/`)
* [ ] Provided clear documentation in this PR
* [ ] Included test logs and results in this PR
* [ ] Listed all dependencies and external data sources (if any)
* [ ] Listed all chains in which your liquidity module is available
* [ ] Listed all smart contracts that are relevant to index your liquidity pools (e.g. factories)

### Example

The following are some examples of existing integrations to guide your development:

... replace with actual example links ...

* [Uniswap V2](https://github.com/gluexprotocol/liquidity-module-self-integration)
* [Aave V3](https://github.com/gluexprotocol/liquidity-module-self-integration)
* [Balancer V3 Stable Pools](https://github.com/gluexprotocol/liquidity-module-self-integration)
* [MM Fork Sample](https://github.com/gluexprotocol/liquidity-module-self-integration)

## Gluing Queue

For protocols that prefer not to undertake the self integration process, GlueX offers a community driven alternative.
Your liquidity module can be picked up for integration by dedicated community developers or by the GlueX core team ("Gluers") through the Gluing Queue.
This path utilizes the power of the community to prioritize and accelerate the integration of impactful liquidity source

🔗 View the Live Queue: [https://gluex.xyz/gluing-queue](https://gluex.xyz/gluing-queue)

**Prioritizing Integrations**

The Gluing Queue is GlueX's transparent and dynamically ranked system for prioritizing liquidity module integrations for community Gluers.
Its primary goal is to ensure that the most impactful and valuable liquidity sources are integrated into GlueX efficiently and effectively, benefiting the entire ecosystem

**How is Priority Determined?**

Each liquidity module's position in the Gluing Queue is determined by its **Gluing Score**, calculated using the following formula

```math
\text{Gluing Score} = (\text{7d Trade Volume}) * (\text{Nr of Chains Deployed}) * (\text{TVL})
```

* **7d Trade Volume** *(in millions of USD)*: The total trading volume of the protocol over the last 7 days (reflects active user engagement)
* **Number of Chains Deployed**: The number of blockchain networks where the protocol is actively deployed and offering liquidity (indicates broad accessibility)
* **TVL (Total Value Locked)** *(in millions of USD)*: The total value of assets locked within the protocol's contracts (signifies the depth and stability)

If any required data (Trade Volume, Number of Chains or TVL) for a protocol is missing in its `gluing_queue.json` entry,
that protocol is automatically placed at the very bottom of the queue, hindering its integration priority

<Note>
  Anyone in the community (including protocol teams and community members) can
  challenge current rankings by submitting updated data, provided with
  verifiable sources
</Note>

### How it Works

This section details how protocol teams and community members can interact with the Gluing Queue, primarily through submitting Pull Requests to the GlueX self integration repository

If you are a **protocol team representative or an engaged community member** eager to see a particular liquidity module integrated, you can directly influence its priority in the Gluing Queue by submitting a Pull Request (PR).
You can submit a PR to:

* **Add your protocol to the queue**: If your protocol is not yet listed, create a new entry for it
* **Provide missing data**: If your protocol is in the queue but lacks crucial information (eg: trade volume, TVL or deployed chains), provide this data to improve its Gluing Score
* **Request a re evaluation**: If you believe your protocol's current Gluing Score is outdated or inaccurate due to recent growth, you can request a re evaluation by updating its data
* **Assign a bounty**: You can **incentivize Gluers to fast-track your protocol's integration by assigning a monetary bounty** (details in the "Bounty System" section below)

<Warning>
  Before you start working on your liquidity module integration, please ensure
  your liquidity module has not already been glued to GlueX
</Warning>

### Integrate Now

To submit (or update) a Liquidity module via the Gluing Queue follow the following steps:

* **Fork the Repository**:
  Click the "Fork" button at the top of the [Gluing Queue Repository](https://github.com/gluexprotocol/gluing-queue) to create your own copy
* **Navigate to `docs/data/gluing_queue.json`**:
  This JSON file contains the data for all protocols in the Gluing Queue
* **Update your protocol's data or add a new entry**:

  * If adding a new protocol, append a new JSON object conforming to the structure below
  * If updating an existing protocol, locate its entry and modify the relevant fields

<Note>
  Ensure that `trade_volume_7d_million` and `tvl_million` are accurately
  reported in millions of USD
</Note>

```json expandable
{
  "protocol": "Protocol Name",
  "docs": "<module_docs_url_or_website>",
  "chains": ["ethereum", "polygon", "base"],
  "trade_volume_7d_million": 100.5, // example: $100.5 million
  "tvl_million": 2000.75, // example: $2,000.75 million
  "bounty_add_on": {
    "amount": null, // set to actual amount if assigning a bounty
    "token_address": null, // set to token address if assigning a bounty
    "token_symbol": null, // set to token symbol if assigning a bounty
    "network": null // set to network if assigning a bounty
  },
  "status": "not_glued", // initial status should be "not_glued"
  "active_gluers": [],
  "prs": []
}
```

* **Submit a Pull Request (PR)**
  * Push your changes to your forked repository
  * Open a Pull Request (PR) from your fork to the `main` branch of the [Gluing Queue Repository](https://github.com/gluexprotocol/gluing-queue)
  * Utilize the PR Submission Template to ensure all necessary information for the queue update is provided clearly
  * Follow the PR template in [`PR-template.md`](https://github.com/gluexprotocol/gluing-queue/blob/main/PR-template.md)
  * Your PR must include:
    * Protocol name and details
    * Deployed chains
    * Trade Volume (7D) in million USD
    * Total Value Locked (TVL) in million USD
    * Is fork and detailed of protocol forked from

<Info>
  Right after the PR is submitted, a Gluer will review your submission. If any
  modifications are required, you will receive feedback for adjustments. If
  approved, your protocol's data in the `gluing_queue.json` will be updated,
  potentially affecting its position in the live queue
</Info>

**Active Gluers**

If you are an active gluer (a community contributor who is actively working on integrating liquidity modules), you will submit PRs to update a protocol's integration status within the `gluing_queue.json` file. This helps track progress and manage the bounty system

You can submit a PR to:

* Change the status of a protocol in the queue from `not_glued` to `being_glued` (indicating you've started work)
* Change the status of a protocol in the queue from `being_glued` to `glue_pending` (indicating your PR for integration is ready for final review)
* Add Pull Request (prs) details to a protocol's entry in the queue
* Add yourself to the `active_gluers` list for a protocol you're working on

<Accordion title="Understanding Integration Status">
  The status field in the queue represents a protocol's current integration stage:

  * `not_glued`: No Gluer has officially started working on this liquidity module integration yet

  * `being_glued`: One or more Gluers are actively developing and working on the integration of this module

  * `glue_pending`: A Pull Request for this liquidity module integration has been submitted, approved, and the module is ready to be onboarded into the GlueX execution layer

  * `glued`: The liquidity module has been successfully integrated into the GlueX execution layer and is live
</Accordion>

### Bounty System

The GlueX bounty system is designed to recognize and reward the invaluable contributions of "Gluers" who successfully integrate liquidity modules into GlueX.
This system not only compensates for effort and technical skill but also incentivizes originality and strategic ecosystem value, with provisions for additional incentives directly from the protocols themselves

**How the System Works**

The total bounty achievable by a Gluer upon successful integration is computed as follows:

```math
\text{Total Protocol Gluing Bounty} = \text{Base Payout } × \text{ Complexity } × \text{ Uniqueness } + \text{Bounty Add-On}
```

**Base Payout**

The base payout for gluing a protocol is determined according the the protocol's rank in the [Glueing Queue](https://gluex.xyz/gluing-queue).
The current tier to payout system implemented for base payouts is as follows

| Rank Range | Tier   | Base Payout |
| ---------- | ------ | ----------- |
| 1 – 10     | Tier 1 | \$400       |
| 11 – 30    | Tier 2 | \$300       |
| 31 – 60    | Tier 3 | \$200       |
| 61 – 90    | Tier 4 | \$100       |
| 91 - 100   | Tier 5 | \$50        |
| +100       | Tier 6 | \$0         |

<Note>
  Base payouts are the primary driver of GlueX funded rewards. They may be
  adjusted at the discretion of GlueX Protocol and must be announced to the
  Gluer community in advance
</Note>

**Complexity Multiplier**

The complexity multiplier reflects the estimated level of effort required to implement a liquidity module.
It is based solely on the approximate number of functional lines of code (LoC) written by the Gluer.
This provides an objective, scalable measure of technical complexity—regardless of the protocol type or use case.
The more logic required to mirror the protocol's liquidity, the higher the reward.

| Complexity Tier | Approx. Lines of Code | Multiplier |
| --------------- | --------------------- | ---------- |
| Tier 1          | ≤ 100                 | ×1.0       |
| Tier 2          | 101 – 200             | ×1.1       |
| Tier 3          | 201 – 300             | ×1.2       |
| Tier 4          | 301 – 400             | ×1.3       |
| Tier 5          | 401 – 500             | ×1.4       |
| Tier 6          | 501 – 600             | ×1.5       |
| Tier 7          | 601 – 700             | ×1.6       |
| Tier 8          | 701 – 800             | ×1.7       |
| Tier 9          | 801 – 900             | ×1.8       |
| Tier 10         | 900 – 1000            | ×1.9       |
| Tier X          | +1000                 | ×2.2       |

<Note>
  Reviewers should count only functional logic: comments, imports, and
  boilerplate should be excluded. If an integration spans multiple files, total
  LoC may be summed
</Note>

**Uniqueness Multiplier**

The Uniqueness Factor is a multiplier applied to a bounty after a Gluer submits a liquidity module.
It helps differentiate between:

* Protocols that are original and technically novel
* Protocols that are minor forks or clones of already glued architectures

The idea is simple. The more original and technically distinct the protocol is, the more valuable the integration and the higher the bounty

| Protocol Type       | Multiplier |
| ------------------- | ---------- |
| Fork / Direct Clone | ×0         |
| Modified Fork       | ×0.5       |
| Original Protocol   | ×1.0       |

<Note>
  Gluers are encouraged to provide documentation or context in the PR to help
  reviewers assess originality. GlueX Labs may validate claims through internal
  review or community feedback
</Note>

**Bounty Addons**

The bounty addon is an optional reward assigned by the protocol itself (or its community) to accelerate its integration.
This extra incentive is separate from GlueX's core bounty structure and can be denominated in any token.

Protocols can assign a bounty addon by modifying their entry in the Glueing Queue json.
Gluers are responsible for verifying the existence, terms and conditions of these external rewards with the protocol team

### Acknowledgment

Participation in the bounty program does not constitute employment or formal engagement, and GlueX reserves the right to approve, deny or adjust any reward based on the quality, accuracy or legitimacy of the contribution


# Requesting Support
Source: https://docs.gluex.xyz/documentation/requests/support-ticket



Welcome to our guide on submitting support ticket for GlueX. Here you'll find resources and guidance for getting help with our products and services, what information to include in a ticket, how we prioritize issues, and what you can expect after you press “Send”

***

## Support Channels

You can get help through the following channels:

* **Documentation**: Explore our detailed documentation portal for self-service solutions, API references and step by step guides
* **Community**: Connect with other users in our community for realtime assistance, practical tips and informal discussions
* **FAQs**: Review our frequently asked questions for quick answers to common issues
* **Telegram**: Join our Telegram group for instant support and updates
* **Security**: Visit the [Audit and Security](/documentation/references/audit-and-security) section for more information

<Info>
  Please check the documentation and FAQs first — over 70% of support requests
  are resolved there within five minutes.
</Info>

## Response Times and Expectations

| Priority          | Definition                                         | First Response        |
| ----------------- | -------------------------------------------------- | --------------------- |
| **P1 - Critical** | Production down, data loss, security risk          | ≤ 6 h (24 × 7)        |
| **P2 - High**     | Major feature broken, no workaround                | ≤ 6 h (business days) |
| **P3 - Normal**   | Minor bug, performance issue, workaround exists    | ≤ 24 h                |
| **P4 - Low**      | General questions, feature requests, docs feedback | ≤ 2 business days     |

<Note>
  Our team typically responds within 24 hours during business days. For urgent
  production related issues, please indicate the urgency in your support request
</Note>

## Submitting a Request - Checklist

Providing complete details help us assist you more effectively

| Area                             | What to Include                               |
| -------------------------------- | --------------------------------------------- |
| **Summary**                      | Single sentence problem statement             |
| **Environment**                  | Chain, OS/browser                             |
| **Steps to Reproduce**           | Minimal steps to reproduce the issue          |
| **Artifacts**                    | Logs, Screenshots, cmd output                 |
| **IDs**                          | Transaction hash                              |
| **Impact & Urgency** (optional)  | Users affected, financial impact, workaround? |
| **Preferred Contact** (optional) | Email or chat handle for follow ups           |

<Note>Review our documentation and FAQs for existing solutions</Note>


# Token Information Updates
Source: https://docs.gluex.xyz/documentation/requests/token-list-or-asset-update-request

A guide for projects to update token information, add missing assets or address data corrections for tokens

Welcome to our guide for updating token information and managing assets on GlueX.
While GlueX generally indexes a vast array of tokens via public token lists, there are instances where specific token data might be missing, incorrect or require updates
(eg: logo updates, name changes or deprecation)

This guide is for projects and users who need to:

* Add a missing asset (like a token logo or detailed name)
* Correct existing token information
* Request the deprecation or update of an old token address (eg: due to a token migration)

## How to Request a Token Information Update

To ensure accuracy and timely processing, please submit your request through our dedicated channels:

### Add a new Token

If your token is not already listed, please:

... Dedicated form with necessary details like CA, Name, Symbol, Chains, Documentation ...

### For Missing Assets (Logos, Names, Symbols) or Corrections

If your token is already listed, but has incorrect information or is missing assets like its logo, please:

... Dedicated form with correction details ...

### For Token Deprecations or Address Changes:

For sensitive updates like deprecating an old token address (eg: due to a token migration or smart contract upgrade), please:

* Reach out to our team via ...
* Provide clear details on the old and new token addresses (if applicable)
* Explain the reason for deprecation (eg: token migration, contract abandonment)
* Share official announcements or documentation from the project confirming the change

## Important Notes

* **Public Token Lists**: GlueX primarily sources token data from reputable public token lists. If your token's information is incorrect or missing on these widely used lists, addressing it there first (eg: via Uniswap's token lists, CoinGecko, CoinMarketCap) can expedite the update process on GlueX
* **Verification**: All requests are subject to verification by the team to ensure accuracy and prevent malicious updates. We may reach out for further clarification
* **Prioritization**: Updates are processed based on the impact, volume and clarity of the request. Critical corrections or widely used tokens may be prioritized

We appreciate your diligence in helping us maintain the most accurate and comprehensive token data on GlueX!


# Common Issues
Source: https://docs.gluex.xyz/troubleshooting/general/common-issues

Troubleshooting guide for frequent integration challenges, authentication problems, rate limiting issues, and error resolution strategies

This comprehensive troubleshooting guide addresses the most frequently encountered issues when integrating with GlueX APIs. Each section provides detailed problem identification, root cause analysis, and step by step resolution strategies to help you quickly resolve integration challenges

## Authentication Issues

### Missing or Invalid API Key

Authentication failures are among the most common integration issues, often manifesting as `401` or `403` errors that prevent access to API endpoints. These errors typically occur during initial setup or when credentials are incorrectly configured in the application

**Symptoms:**

* Receiving `401 Forbidden` or `401 Unauthorized` responses
* Error messages indicating missing authentication
* Requests failing consistently across all endpoints
* Development environment working but production failing

**Causes:**

* API key not included in request headers
* Incorrect header name or casing (eg: `X-API-KEY` instead of `x-api-key`)
* API key value contains extra spaces or newline characters
* Using expired or revoked credentials
* Missing required authentication parameters in request body

**Solutions:**

1. Verify the API key is included in the correct header format
2. Check for whitespace or formatting issues in the credential string
3. Confirm the API key is active and not expired in your dashboard
4. Ensure all required authentication parameters are included in requests
5. Test with a freshly generated API key to rule out corruption

**Best Practices:**

* Store API keys in environment variables, never in source code
* Implement credential validation during application startup
* Use secure credential management systems in production
* Regularly rotate API keys according to security policies
* Monitor authentication failure rates to detect credential issues early
* Set up a proxy server or configure domain whitelisting if using API keys on the client side

### Incorrect Request Format

Authentication credentials may be present but formatted incorrectly, leading to persistent authorization failures

**Symptoms:**

* Intermittent authentication failures
* Authentication working for some requests but not others
* Error messages about malformed requests

**Causes:**

* Integrator ID missing from request body
* Authentication headers using wrong case sensitivity
* Request body missing required authentication fields
* Content-Type header not matching request format
* Special characters in credentials not properly encoded

**Solutions:**

1. Ensure all required fields are present in both headers and request body
2. Validate request format against API documentation
3. Check Content-Type headers match the request payload format
4. Verify special characters in credentials are properly URL-encoded
5. Test requests using API testing tools to isolate formatting issues

**Best Practices:**

* Create request templates with all required authentication fields
* Implement request validation before sending to APIs
* Use established HTTP client libraries rather than custom implementations
* Log request formats (excluding sensitive data) for debugging
* Maintain consistent request formatting across all API calls

### Domain Whitelist Restrictions

Domain based access controls can block legitimate requests when the requesting domain is not properly configured in the API whitelist settings

**Symptoms:**

* `403 Request origin not in whitelist` errors
* Requests working from some domains but not others
* Local development working but production deployments failing
* CORS related error messages in browser console

**Causes:**

* Requesting domain not added to API whitelist
* Subdomain differences (www vs non-www)
* Different domains between staging and production
* Local development domains not whitelisted
* Case sensitivity in domain names

**Solutions:**

1. Add all necessary domains to the whitelist in your API dashboard
2. Include both www and non-www versions of domains
3. Add development and staging environment domains
4. Verify domain names match exactly (including subdomains)
5. Test from each domain after whitelist updates

**Best Practices:**

* Maintain a comprehensive list of all domains requiring API access
* Add domains to whitelist before deployment to avoid downtime
* Include common development domains (localhost, staging URLs)
* Document domain requirements for team members
* Regularly audit and update whitelisted domains

## Rate Limiting Issues

### Exceeding Request Limits

Rate limiting protects API infrastructure by controlling request frequency, but can disrupt service when applications exceed allocated limits during peak usage periods

**Symptoms:**

* `429 Rate limit exceeded` HTTP responses
* Requests succeeding initially then failing during high usage
* Service degradation during peak hours
* Intermittent failures with successful retries

**Causes:**

* Application request rate exceeding tier limits
* Burst traffic overwhelming burst capacity
* Multiple application instances sharing same API key
* Inefficient API usage patterns (excessive polling)
* No rate limiting implementation in client code

**Solutions:**

1. Implement exponential backoff retry logic for 429 responses
2. Add request queuing to control outbound request rate
3. Cache responses to reduce redundant API calls
4. Optimize API usage patterns to minimize requests
5. Consider upgrading to higher tier for increased limits

**Best Practices:**

* Monitor request rates and implement alerting for approaching limits
* Use client-side request queuing to smooth traffic bursts
* Implement caching strategies to reduce API dependency
* Design applications to handle rate limiting gracefully
* Plan capacity requirements and upgrade tiers proactively

### Inefficient API Usage

Poor API usage patterns can quickly exhaust rate limits even at moderate traffic levels, leading to unnecessary service disruptions

**Symptoms:**

* High API usage relative to application functionality
* Frequent rate limiting despite low user activity
* Multiple identical requests in short time periods
* Performance degradation during normal operation

**Causes:**

* Excessive polling of endpoints
* Making redundant requests for unchanged data
* Using computationally expensive endpoints for simple queries
* No caching of API responses
* Inefficient batch processing patterns

**Solutions:**

1. Implement response caching to avoid redundant requests
2. Use appropriate polling intervals based on data change frequency
3. Choose optimal endpoints for specific use cases
4. Batch related requests when supported
5. Implement client side data management to reduce API dependency

**Best Practices:**

* Cache API responses appropriately based on data volatility
* Use webhooks or real-time connections instead of polling when available
* Batch requests efficiently to minimize API calls
* Monitor API usage patterns and optimize high-frequency operations
* Design applications with offline capabilities to reduce API dependency

## API Response Issues

### Validation Errors

Input validation failures occur when request parameters don't meet API requirements, resulting in 400 or 422 status codes that prevent request processing

**Symptoms:**

* `400 Bad Request` or `422 Unprocessable Entity` responses
* Error messages indicating invalid parameters
* Requests failing consistently for specific input values
* Different validation behavior across API environments

**Causes:**

* Invalid address formats (incorrect length, missing prefix)
* Negative values where only positive numbers accepted
* Unsupported network or protocol identifiers
* Missing required parameters
* Parameter values outside acceptable ranges

**Solutions:**

1. Validate input parameters client side before sending requests
2. Ensure address formats match blockchain standards (42 characters with 0x prefix)
3. Check parameter values against documented acceptable ranges
4. Include all required parameters in requests
5. Use supported network and protocol identifiers

**Best Practices:**

* Implement comprehensive client side validation
* Use established validation libraries for common formats (addresses, amounts)
* Provide clear error messages to users for validation failures
* Test edge cases and boundary conditions during development
* Maintain validation logic consistent with API requirements

### Service Unavailable Errors

Service availability issues can cause widespread request failures, typically manifesting as 5xx status codes during system maintenance or high load periods

**Symptoms:**

* `500 Internal Server Error` or `503 Service Unavailable` responses
* Requests failing across all endpoints
* Timeout errors during request processing
* Intermittent service availability

**Causes:**

* API service experiencing high load or maintenance
* Database connectivity issues
* Network timeouts during blockchain calls
* System resource exhaustion
* Service deployment or updates in progress

**Solutions:**

1. Implement retry logic with exponential backoff for 5xx errors
2. Use circuit breaker patterns to avoid cascading failures
3. Implement graceful degradation when APIs are unavailable
4. Cache recent successful responses for fallback data
5. Monitor service status and adjust request patterns accordingly

**Best Practices:**

* Design applications to handle temporary service unavailability
* Implement comprehensive error handling for all API calls
* Use health check endpoints to monitor service availability
* Plan for maintenance windows and API updates
* Implement circuit breakers to prevent overwhelming unavailable services

## Network and Connectivity Issues

### Timeout Problems

Network timeouts occur when requests take longer than configured limits to complete, often due to complex calculations or network congestion

**Symptoms:**

* Requests failing with timeout errors
* Inconsistent response times for similar requests
* Higher failure rates during peak network usage
* Successful requests when retried after delays

**Causes:**

* Network congestion affecting request routing
* Complex calculations requiring extended processing time
* Blockchain network delays during state calls
* Insufficient timeout values for request complexity
* Client network connectivity issues

**Solutions:**

1. Implement appropriate timeout values based on request complexity
2. Add retry logic for timeout failures
3. Use connection pooling to improve network efficiency
4. Monitor network conditions and adjust timeout settings
5. Implement request queuing to manage network load

**Best Practices:**

* Set timeout values appropriate for each endpoint's expected response time
* Implement retry strategies with progressive delays
* Monitor network performance and adjust configurations accordingly
* Use connection pooling and keep-alive connections for efficiency
* Provide user feedback during long-running operations

### Connection Failures

Network connectivity issues can prevent requests from reaching API servers, resulting in connection errors rather than HTTP status codes

**Symptoms:**

* Network connection errors or DNS resolution failures
* Requests failing before receiving HTTP responses
* Inconsistent connectivity across different network environments
* Successful connections from some locations but not others

**Causes:**

* DNS resolution issues
* Firewall or proxy blocking API endpoints
* Network routing problems
* TLS/SSL certificate issues
* Client network configuration problems

**Solutions:**

1. Verify DNS resolution for API endpoints
2. Check firewall and proxy settings allow API access
3. Test connectivity from different network environments
4. Validate TLS/SSL certificate configuration
5. Implement connection health checks and monitoring

**Best Practices:**

* Test API connectivity from all deployment environments
* Document network requirements for API access
* Implement connection health monitoring
* Use multiple DNS servers for redundancy
* Plan for network environment differences between development and production

## Data Quality Issues

### Missing or Invalid Data

Data availability issues occur when requested information is not found or cannot be calculated due to missing dependencies or invalid states

**Symptoms:**

* `404 Not Found` responses for valid looking requests
* Inconsistent data availability across similar requests
* Calculations failing due to incomplete information
* Error messages indicating missing required data

**Causes:**

* Requested data not available in API databases
* Blockchain state calls failing or timing out
* Invalid or non-existent addresses in requests
* Data synchronization delays
* Protocol or network not supported

**Solutions:**

1. Verify addresses and parameters using blockchain explorers
2. Check if requested protocols and networks are supported
3. Implement fallback strategies for missing data
4. Use alternative lookup methods when available
5. Retry requests after brief delays for transient data issues

**Best Practices:**

* Validate addresses and parameters before making requests
* Implement fallback data sources when possible
* Provide meaningful error messages when data is unavailable
* Monitor data availability patterns and report persistent issues
* Cache successful responses to reduce dependency on real-time data

### Calculation Failures

Complex calculations may fail due to various factors including insufficient data, computational limits, or external dependencies

**Symptoms:**

* Calculation endpoints returning error responses
* Inconsistent results for similar input parameters
* Failures during specific market conditions
* Error messages indicating calculation problems

**Causes:**

* Insufficient liquidity for requested calculations
* Missing blockchain state information
* Network congestion affecting data retrieval
* Computational timeouts during complex operations
* Invalid or incompatible parameter combinations

**Solutions:**

1. Reduce calculation complexity by adjusting parameters
2. Retry calculations after brief delays
3. Use alternative calculation methods when available
4. Verify input parameters are compatible and realistic
5. Implement graceful handling of calculation failures

**Best Practices:**

* Design applications to handle calculation failures gracefully
* Provide alternative data or functionality when calculations fail
* Monitor calculation success rates and identify patterns
* Implement appropriate error messaging for users
* Cache successful calculation results to reduce recalculation needs


# Initial Steps
Source: https://docs.gluex.xyz/troubleshooting/general/initial-steps

Basic checks to quickly identify and resolve common issues with the GlueX integration or APIs

If you’re experiencing any issues with the integration or APIs, please follow these initial troubleshooting steps:

<Steps>
  <Step title="Verify the keys">
    Verify your keys by ensuring the headers are correctly set for all the
    **authenticated requests** and check in the GlueX portal that your **key is
    active** and has not been revoked or rotated
  </Step>

  <Step title="Confirm Endpoints">
    Ensure you are targeting the correct environment by verifying the base URL.
    Production endpoints are `https://router.gluex.xyz` for quotes and
    `https://exchange-rates.gluex.xyz` for exchange rates
  </Step>

  <Step title="Validate Request Payload">
    Confirm the payload matches the schema ensuring all required fields are set
    and all the data matches the expected types
  </Step>

  <Step title="Inspect HTTP Status Codes">
    Examine the HTTP status code returned by the API. A `400` indicates a
    malformed request, `401`/`403` indicate authentication or authorization
    failure, `429` signals rate limiting and any `5xx` indicates a server side
    error
  </Step>

  <Step title="Review Rate Limits">
    Verify that you are within your allowed request rate to avoid throttling. If
    you receive `429` responses, implement exponential backoff and reduce request
    frequency
  </Step>

  <Step title="Confirm Token Addresses and Chains">
    Make sure the token contract addresses exist on the specified chain and are
    correctly checksummed
  </Step>

  <Step title="Enable Debug Logging">
    Turn on verbose logging in your client or SDK to capture full request and
    response details, including headers and bodies. Look for hidden error messages
    or stack traces in the logs
  </Step>

  <Step title="Gather Logs and Contact Support">
    If the issue persists, collect timestamps, full request/response pairs, and
    error details. Reach us out via [telegram](https://t.me/+6NrwSlEPAsA3MzE0) or Open a
    support ticket via [discord](https://discord.com/invite/gluex) with your findings
    and a summary of the steps you’ve tried
  </Step>
</Steps>

If the problem persists after following the steps above, please let us know immediately via our Telegram channel or Discord server (you can find the links to these channels [here](https://bento.me/gluex-protocol)). When opening a new support thread, include the demo URL, the exact HTTP request and response (headers, body, status code), timestamps and a brief description of what you’ve tried so far. It’s also helpful to search existing Telegram and Discord conversations, chances are someone else may have already found a solution that can help you more quickly


# Deposit to a Lending Vault
Source: https://docs.gluex.xyz/tutorials/deposit-to-a-lending-vault

Atomically deposit any token into any lending vaults (Aave, Morpho, Compound, Euler, Yearn, Beefy, Lido, Fluid and more) in a single atomic transaction

## Case

Suppose you hold \$GALA and want to put it to work earning yield in a lending protocol, specifically by converting it into interest bearing \$aETHWETH in a single atomic transaction. With GlueX’s unified Router API and smart contract integrations, you can swap one token and deposit the proceeds into a lending vault atomically, without juggling approvals or multiple onchain calls.

In this guide, we’ll walk through exactly how to:

1. Build a swap quote to convert \$GALA into \$WETH
2. Bundle that quote into a Zap that deposits directly into the Aave vault to receive \$aETHWETH
3. Submit the transaction and verify the resulting vault deposit

We’ll use a real Ethereum mainnet transaction as our reference example <br />
Transaction hash: [0xd0c48d25ac3e0ab111b3ab401903d4a357baa22ee9c9efb832e0b80278ba5ba3](https://etherscan.io/tx/0xd0c48d25ac3e0ab111b3ab401903d4a357baa22ee9c9efb832e0b80278ba5ba3)

<img className="hidden dark:block" src="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8c503f221aa69881da711bcd1be7f97b" alt="0xd0c48d25ac3e0ab111b3ab401903d4a357baa22ee9c9efb832e0b80278ba5ba3 Example Txn" width="2044" height="786" data-path="images/tutorials/lending-example-transfer.png" srcset="https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=280&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=8bacbb4ef7b08dc413968f54b86feded 280w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=560&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9e60e7a91b44dbede696d682ab0af055 560w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=840&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2b7047203cc198770d74c57b8edfe264 840w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=1100&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=9af0296676447ced5c03b39646f13831 1100w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=1650&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=407830c1d77ff14e46315c0f0bb1ac44 1650w, https://mintcdn.com/gluex/y7_k9kQruudG0sU3/images/tutorials/lending-example-transfer.png?w=2500&fit=max&auto=format&n=y7_k9kQruudG0sU3&q=85&s=2b192521c6b7197c9a737e04465a2e22 2500w" data-optimize="true" data-opv="2" />

### How It Works

1. Transfer \$GALA from the user's wallet
2. Swap \$GALA for \$WETH via Uniswap V3
3. Receive \$aETHWETH via Aave V3
4. Start earning yield automatically

### Why This Matters?

Moving from a regular token to a yield bearing asset usually requires multiple platforms, manual steps and higher fees. GlueX removes these barriers, bringing:

✅ Time efficiency - One transaction instead of many

✅ Cost savings - Lesser gas fees

✅ Simplicity - No manual interactions with multiple protocols

This tutorial uses \$GALA → \$aETHWETH as an example, but GlueX allows you to swap any token to any yield generating token in a single transaction

## Implementation

### Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

### Setup and Configuration

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Addresses
  GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae"
  AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8"

  # Input amount (in decimals)
  INPUT_AMOUNT = 2000000000000  # 2,000,000 GALA (including decimals)

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae";
  const AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8";

  // Input amount (in decimals)
  const INPUT_AMOUNT = BigInt("2000000000000"); // 2,000,000 GALA (including decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae";
  const AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8";

  // Input amount (in decimals)
  const INPUT_AMOUNT = BigInt("2000000000000"); // 2,000,000 GALA (including decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### Fetching a Swap Quote

Before executing the transaction, fetch a quote from the GlueX Router

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote():
      """Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap"""
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": GALA_ADDRESS,
          "outputToken": AETHWETH_ADDRESS,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }

      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)

      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

### Approving the Router Contract

Before executing the swap, the router contract needs permission to spend the user's GALA tokens

<CodeGroup>
  ```python approve_spender.py
  def approve_spender(spender, amount, token_address):
      """Approve the router contract to spend $GALA"""
      signature = "0x095ea7b3"
      padded_spender = Web3.to_checksum_address(spender)[2:].zfill(64)
      calldata = f"{signature}{padded_spender}{int(amount):064x}"

      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(token_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Approval Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash
  ```

  ```typescript approve_spender.ts
  const approveSpender = async (
      spender: string,
      amount: bigint,
      tokenAddress: string
  ): Promise<string> => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript approve_spender.js
  const approveSpender = async (spender, amount, tokenAddress) => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

### Executing the Transaction

After approval, we execute the transaction using the calldata from the quote

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address):
      """Execute the swap transaction on GlueX Router"""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)

      try:
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      except Web3RPCError as err:
          time.sleep(5)
          txn["nonce"] = web3.eth.get_transaction_count(account.address)
          signed_txn = web3.eth.account.sign_transaction(txn, account.key)
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)

      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (calldata, routerAddress) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };
  ```
</CodeGroup>

### Putting Everything Together

<CodeGroup>
  ```python main.py
  def main():
      # Fetch the quote
      quote_data = fetch_quote()
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return

      print("Quote received successfully:", quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]

      # Approve the router contract
      print("Approving router contract to spend GALA...")
      txn_hash = approve_spender(router_address, INPUT_AMOUNT, GALA_ADDRESS)
      print("Waiting for approval transaction confirmation...")
      approval_receipt = web3.eth.wait_for_transaction_receipt(txn_hash)
      if approval_receipt.status != 1:
          print("Approval failed. Aborting.")
          return

      # Execute the transaction
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address)

      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)


  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: GALA_ADDRESS,
          outputToken: AETHWETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend GALA...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, GALA_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: GALA_ADDRESS,
          outputToken: AETHWETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend GALA...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, GALA_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### Complete Code Implementation

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  from web3.exceptions import Web3RPCError
  import requests
  import json
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Addresses
  GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae"
  AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8"

  # Input amount (in decimals)
  INPUT_AMOUNT = 2000000000000  # 2,000,000 GALA (including decimals)

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote():
      """Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap"""
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": GALA_ADDRESS,
          "outputToken": AETHWETH_ADDRESS,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }

      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)

      return response.json()

  def approve_spender(spender, amount, token_address):
      """Approve the router contract to spend $GALA"""
      signature = "0x095ea7b3"
      padded_spender = Web3.to_checksum_address(spender)[2:].zfill(64)
      calldata = f"{signature}{padded_spender}{int(amount):064x}"

      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(token_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Approval Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash

  def execute_transaction(calldata, router_address):
      """Execute the swap transaction on GlueX Router"""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)

      try:
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      except Web3RPCError as err:
          time.sleep(5)
          txn["nonce"] = web3.eth.get_transaction_count(account.address)
          signed_txn = web3.eth.account.sign_transaction(txn, account.key)
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)

      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash

  def main():
      # Fetch the quote
      quote_data = fetch_quote()
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return

      print("Quote received successfully:", quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]

      # Approve the router contract
      print("Approving router contract to spend GALA...")
      txn_hash = approve_spender(router_address, INPUT_AMOUNT, GALA_ADDRESS)
      print("Waiting for approval transaction confirmation...")
      approval_receipt = web3.eth.wait_for_transaction_receipt(txn_hash)
      if approval_receipt.status != 1:
          print("Approval failed. Aborting.")
          return

      # Execute the transaction
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address)

      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)


  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae";
  const AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8";

  // Input amount (in decimals)
  const INPUT_AMOUNT = BigInt("2000000000000"); // 2,000,000 GALA (including decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }

  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const approveSpender = async (
      spender: string,
      amount: bigint,
      tokenAddress: string
  ): Promise<string> => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };

  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: GALA_ADDRESS,
          outputToken: AETHWETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend GALA...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, GALA_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const GALA_ADDRESS = "0xd1d2Eb1B1e90B638588728b4130137D262C87cae";
  const AETHWETH_ADDRESS = "0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8";

  // Input amount (in decimals)
  const INPUT_AMOUNT = BigInt("2000000000000"); // 2,000,000 GALA (including decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router for $GALA to $aETHWETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const approveSpender = async (spender, amount, tokenAddress) => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };

  const executeTransaction = async (calldata, routerAddress) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: GALA_ADDRESS,
          outputToken: AETHWETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend GALA...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, GALA_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

### Running the Script

To execute the deposit, run the script as follows:

<CodeGroup>
  ```bash python
  python deposit_to_lending_vault.py
  ```

  ```bash typescript
  npx tsx deposit_to_lending_vault.ts
  ```

  ```bash javascript
  node deposit_to_lending_vault.js
  ```
</CodeGroup>

## Conclusion

With GlueX, moving from \$GALA to a yield generating asset like \$aETHWETH takes just one transaction. This tutorial demonstrates:

* Fetching a swap quote
* Approving the router contract to spend \$GALA
* Executing the transaction to swap and deposit smoothly

## Opportunities

🔹 Instant access to yield without manual interventions

🔹 Seamless diversification into yield generating assets

🔹 Cost savings by reducing gas fees across multiple steps

With GlueX, DeFi becomes as easy as sending an email 🚀


# DEX Transaction
Source: https://docs.gluex.xyz/tutorials/dex-transaction

This tutorial provides a step-by-step guide on how to swap USDC to ETH using the GlueX Router.

### Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

### Setup and Configuration

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Addresses
  USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"  # USDC on Ethereum
  ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"    # ETH on Ethereum
  INPUT_AMOUNT = 1000000  # 1 USDC (6 decimals)

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"; // USDC on Ethereum
  const ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";   // ETH on Ethereum
  const INPUT_AMOUNT = BigInt("1000000"); // 1 USDC (6 decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"; // USDC on Ethereum
  const ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";   // ETH on Ethereum
  const INPUT_AMOUNT = BigInt("1000000"); // 1 USDC (6 decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### Fetching a Swap Quote

Before executing the transaction, fetch a quote from the GlueX Router

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote():
      """Fetch a quote from the GlueX Router for $USDC to $ETH swap"""
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "1",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": USDC_ADDRESS,
          "outputToken": ETH_ADDRESS,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }

      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)

      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router for $USDC to $ETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router for $USDC to $ETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

### Approving the Router Contract

Before executing the swap, the router contract needs permission to spend the user's USDC tokens

<CodeGroup>
  ```python approve_spender.py
  def approve_spender(spender, amount, token_address):
      """Approve the router contract to spend $USDC"""
      signature = "0x095ea7b3"
      padded_spender = Web3.to_checksum_address(spender)[2:].zfill(64)
      calldata = f"{signature}{padded_spender}{int(amount):064x}"

      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(token_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Approval Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash
  ```

  ```typescript approve_spender.ts
  const approveSpender = async (
      spender: string,
      amount: bigint,
      tokenAddress: string
  ): Promise<string> => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript approve_spender.js
  const approveSpender = async (spender, amount, tokenAddress) => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

### Executing the Transaction

After approval, we execute the transaction using the calldata from the quote

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address):
      """Execute the swap transaction on GlueX Router"""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)

      try:
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      except Web3RPCError as err:
          time.sleep(5)
          txn["nonce"] = web3.eth.get_transaction_count(account.address)
          signed_txn = web3.eth.account.sign_transaction(txn, account.key)
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)

      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (calldata, routerAddress) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };
  ```
</CodeGroup>

### Putting Everything Together

<CodeGroup>
  ```python main.py
  def main():
      # Fetch the quote
      quote_data = fetch_quote()
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return

      print("Quote received successfully:", quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]

      # Approve the router contract
      print("Approving router contract to spend USDC...")
      txn_hash = approve_spender(router_address, INPUT_AMOUNT, USDC_ADDRESS)
      print("Waiting for approval transaction confirmation...")
      approval_receipt = web3.eth.wait_for_transaction_receipt(txn_hash)
      if approval_receipt.status != 1:
          print("Approval failed. Aborting.")
          return

      # Execute the transaction
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address)

      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)


  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "1", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: USDC_ADDRESS,
          outputToken: ETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend USDC...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, USDC_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "1", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: USDC_ADDRESS,
          outputToken: ETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend USDC...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, USDC_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### Complete Code Implementation

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  from web3.exceptions import Web3RPCError
  import requests
  import json
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Addresses
  USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"  # USDC on Ethereum
  ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"    # ETH on Ethereum
  INPUT_AMOUNT = 1000000  # 1 USDC (6 decimals)

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote():
      """Fetch a quote from the GlueX Router for $USDC to $ETH swap"""
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "1",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": USDC_ADDRESS,
          "outputToken": ETH_ADDRESS,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }

      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)

      return response.json()

  def approve_spender(spender, amount, token_address):
      """Approve the router contract to spend $USDC"""
      signature = "0x095ea7b3"
      padded_spender = Web3.to_checksum_address(spender)[2:].zfill(64)
      calldata = f"{signature}{padded_spender}{int(amount):064x}"

      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(token_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Approval Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash

  def execute_transaction(calldata, router_address):
      """Execute the swap transaction on GlueX Router"""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "chainId": 1,  # Ethereum mainnet
      }

      signed_txn = web3.eth.account.sign_transaction(txn, account.key)

      try:
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      except Web3RPCError as err:
          time.sleep(5)
          txn["nonce"] = web3.eth.get_transaction_count(account.address)
          signed_txn = web3.eth.account.sign_transaction(txn, account.key)
          txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)

      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")

      return txn_hash

  def main():
      # Fetch the quote
      quote_data = fetch_quote()
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return

      print("Quote received successfully:", quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]

      # Approve the router contract
      print("Approving router contract to spend USDC...")
      txn_hash = approve_spender(router_address, INPUT_AMOUNT, USDC_ADDRESS)
      print("Waiting for approval transaction confirmation...")
      approval_receipt = web3.eth.wait_for_transaction_receipt(txn_hash)
      if approval_receipt.status != 1:
          print("Approval failed. Aborting.")
          return

      # Execute the transaction
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address)

      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)


  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"; // USDC on Ethereum
  const ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";   // ETH on Ethereum
  const INPUT_AMOUNT = BigInt("1000000"); // 1 USDC (6 decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }

  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router for $USDC to $ETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const approveSpender = async (
      spender: string,
      amount: bigint,
      tokenAddress: string
  ): Promise<string> => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };

  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "1", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: USDC_ADDRESS,
          outputToken: ETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend USDC...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, USDC_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.tenderly.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Addresses
  const USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"; // USDC on Ethereum
  const ETH_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";   // ETH on Ethereum
  const INPUT_AMOUNT = BigInt("1000000"); // 1 USDC (6 decimals)

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router for $USDC to $ETH swap");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const approveSpender = async (spender, amount, tokenAddress) => {
      const signature = "0x095ea7b3";
      const paddedSpender = web3.utils.toChecksumAddress(spender).slice(2).padStart(64, '0');
      const calldata = `${signature}${paddedSpender}${amount.toString(16).padStart(64, '0')}`;

      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(tokenAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Approval Transaction Hash: ${txHash}`);
      return txHash;
  };

  const executeTransaction = async (calldata, routerAddress) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          chainId: 1, // Ethereum mainnet
      };

      try {
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      } catch (err) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          txn.nonce = await web3.eth.getTransactionCount(account.address);
          const signedTxn = await account.signTransaction(txn);
          const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
          const txHash = web3.utils.toHex(receipt.transactionHash);
          console.log(`Transaction Hash: ${txHash}`);
          return txHash;
      }
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "1", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: USDC_ADDRESS,
          outputToken: ETH_ADDRESS,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("Fetching swap quote...");
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:", quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      // Approve the router contract
      console.log("Approving router contract to spend USDC...");
      const txnHash = await approveSpender(routerAddress, INPUT_AMOUNT, USDC_ADDRESS);
      console.log("Waiting for approval transaction confirmation...");
      const approvalReceipt = await web3.eth.getTransactionReceipt(txnHash);
      if (!approvalReceipt || !approvalReceipt.status) {
          console.log("Approval failed. Aborting.");
          return;
      }

      // Execute the transaction
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

### Running the Script

To execute the swap, run the script as follows:

<CodeGroup>
  ```bash python
  python dex-transaction.py
  ```

  ```bash typescript
  npx tsx dex-transaction.ts
  ```

  ```bash javascript
  node dex-transaction.js
  ```
</CodeGroup>

## Conclusion

By following this tutorial, users can seamlessly swap USDC for ETH using the GlueX Router. The script automates fetching quotes, handling approvals, and executing swaps securely. Users can modify this script to suit their specific needs, such as swapping different tokens, changing input amounts, or integrating it into larger applications.

## Opportunities

🔹 Instant access to best swap rates across DEXs

🔹 Seamless token swaps with proper approval handling

🔹 Cost savings by reducing gas fees across multiple steps

With GlueX, DeFi becomes as easy as sending an email 🚀


# Staking a Token
Source: https://docs.gluex.xyz/tutorials/staking-a-token

This tutorial provides a step-by-step guide on how to stake native tokens (ETH to stETH) using the GlueX Router.

## Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum-compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

## How GlueX Router Works

The GlueX Router simplifies the token staking process by:

1. Fetching a price quote for staking native tokens.
2. Generating the appropriate calldata for the stake.
3. Executing the transaction on-chain to stake the native token and receive staked tokens (e.g., ETH to stETH).

## Script Overview

### 1. **Setup and Configuration**

The following script initializes the necessary configurations:

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # Represents native ETH
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84"  # stETH Contract Address
  INPUT_AMOUNT = 1000000000000000000  # Example: 1 ETH in Wei

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84"; // stETH Contract Address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84"; // stETH Contract Address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### 2. **Fetching a Stake Quote**

Before executing the stake, obtain a quote from the GlueX Router. This ensures that you get the best rate available:

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote(body, headers):
      """Fetch a quote from the GlueX Router."""
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

This function sends a request to the GlueX Router to retrieve a quote for staking native tokens.

### 3. **Executing the Stake Transaction**

Once the quote is retrieved, execute the stake transaction by sending the appropriate calldata:

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address, account, value=0):
      """Execute transaction on the GlueX Router."""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

This function constructs and signs the transaction, ensuring it is sent to the Ethereum blockchain for processing.

### 4. **End-to-End Stake Execution**

The `main()` function ties everything together by fetching a quote and executing the transaction:

<CodeGroup>
  ```python main.py
  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      
      print("============================================================================")
      print("Fetching stake quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      
      print("Quote received successfully:")
      print(quote_data)
      
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching stake quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching stake quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### 5. **Complete Code Implementation**

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84"
  INPUT_AMOUNT = 1000000000000000000

  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote(body, headers):
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()

  def execute_transaction(calldata, router_address, account, value=0):
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash

  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      print("============================================================================")
      print("Fetching stake quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      print("Quote received successfully:")
      print(quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body: any, headers: { [key: string]: string }) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching stake quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching stake quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

### 6. **Running the Script**

To execute the stake, run the script as follows:

<CodeGroup>
  ```bash python
  python stake_token.py
  ```

  ```bash typescript
  npx tsx stake_token.ts
  ```

  ```bash javascript
  node stake_token.js
  ```
</CodeGroup>


# Swapping Native Tokens
Source: https://docs.gluex.xyz/tutorials/swap-native-tokens

This tutorial provides a step-by-step guide on how to swap native tokens using the GlueX Router.

## Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum-compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

## How GlueX Router Works

The GlueX Router simplifies the token swap process by:

1. Fetching a price quote for swapping native tokens.
2. Generating the appropriate calldata for the swap.
3. Executing the transaction on-chain to swap the native token for the desired output token.

## Script Overview

### 1. **Setup and Configuration**

The following script initializes the necessary configurations:

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # Represents native ETH
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xTokenOutAddress"  # Replace with the desired output token address
  INPUT_AMOUNT = 1000000000000000000  # Example: 1 ETH in Wei

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xTokenOutAddress"; // Replace with the desired output token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xTokenOutAddress"; // Replace with the desired output token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### 2. **Fetching a Swap Quote**

Before executing the swap, obtain a quote from the GlueX Router. This ensures that you get the best rate available:

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote(body, headers):
      """Fetch a quote from the GlueX Router."""
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router.");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router.");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

This function sends a request to the GlueX Router to retrieve a quote for swapping native tokens.

### 3. **Executing the Swap Transaction**

Once the quote is retrieved, execute the swap transaction by sending the appropriate calldata:

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address, account, value=0):
      """Execute transaction on the GlueX Router."""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

This function constructs and signs the transaction, ensuring it is sent to the Ethereum blockchain for processing.

### 4. **End-to-End Swap Execution**

The `main()` function ties everything together by fetching a quote and executing the transaction:

<CodeGroup>
  ```python main.py
  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      
      print("============================================================================")
      print("Fetching swap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      
      print("Quote received successfully:")
      print(quote_data)
      
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching swap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching swap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### 5. **Complete Code Implementation**

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # Represents native ETH
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xTokenOutAddress"  # Replace with the desired output token address
  INPUT_AMOUNT = 1000000000000000000  # Example: 1 ETH in Wei

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote(body, headers):
      """Fetch a quote from the GlueX Router."""
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()

  def execute_transaction(calldata, router_address, account, value=0):
      """Execute transaction on the GlueX Router."""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash

  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      
      print("============================================================================")
      print("Fetching swap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      
      print("Quote received successfully:")
      print(quote_data)
      
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xTokenOutAddress"; // Replace with the desired output token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }

  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      console.log("Fetch a quote from the GlueX Router.");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching swap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xTokenOutAddress"; // Replace with the desired output token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      console.log("Fetch a quote from the GlueX Router.");
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching swap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```
</Accordion>

### 6. **Running the Script**

To execute the swap, run the script as follows:

<CodeGroup>
  ```bash python
  python swap_native_tokens.py
  ```

  ```bash typescript
  npx tsx swap_native_tokens.ts
  ```

  ```bash javascript
  node swap_native_tokens.js
  ```
</CodeGroup>

### 6. **Understanding the Workflow**

1. **User provides their private key and RPC URL.**
2. **The script fetches a quote** for the native token swap from the GlueX Router.
3. **The appropriate calldata is generated** for the transaction.
4. **The transaction is executed on-chain**, sending native tokens and receiving the desired token in return.
5. **The transaction hash is displayed**, which users can verify on Etherscan or their preferred blockchain explorer.

## Conclusion

By following this tutorial, users can seamlessly swap native tokens for any available token on the blockchain using the GlueX Router. The script automates fetching quotes, signing transactions, and executing swaps securely. Users can modify this script to suit their specific needs, such as swapping different tokens, changing input amounts, or integrating it into larger applications.

For further enhancements, users can implement error handling, dynamic user input, or even integrate this functionality into a larger trading bot or DeFi application.


# Wrapping a Token
Source: https://docs.gluex.xyz/tutorials/wrap-token

This tutorial provides a step-by-step guide on how to wrap native tokens (ETH to WETH) using the GlueX Router.

## Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum-compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

## How GlueX Router Works

The GlueX Router simplifies the token wrapping process by:

1. Fetching a price quote for wrapping native tokens.
2. Generating the appropriate calldata for the wrap.
3. Executing the transaction on-chain to wrap the native token into its wrapped form (e.g., ETH to WETH).

## Script Overview

### 1. **Setup and Configuration**

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # Represents native ETH
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"  # WETH Contract Address
  INPUT_AMOUNT = 1000000000000000000  # Example: 1 ETH in Wei

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // WETH Contract Address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Represents native ETH
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // WETH Contract Address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 ETH in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### 2. **Fetching a Wrap Quote**

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote(body, headers):
      """Fetch a quote from the GlueX Router."""
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: any, headers: { [key: string]: string }) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

### 3. **Executing the Wrap Transaction**

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address, account, value=0):
      """Execute transaction on the GlueX Router."""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

### 4. **End-to-End Wrap Execution**

<CodeGroup>
  ```python main.py
  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      
      print("============================================================================")
      print("Fetching wrap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      
      print("Quote received successfully:")
      print(quote_data)
      
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching wrap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching wrap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### 5. **Complete Code Implementation**

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
  TOKEN_IN = NATIVE_TOKEN_ADDRESS
  TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
  INPUT_AMOUNT = 1000000000000000000

  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote(body, headers):
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()

  def execute_transaction(calldata, router_address, account, value=0):
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash

  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      print("============================================================================")
      print("Fetching wrap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      if quote_data.get('statusCode') !== 200:
          print("Error fetching quote:", quote_data)
          return
      print("Quote received successfully:")
      print(quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=INPUT_AMOUNT)
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body: any, headers: { [key: string]: string }) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching wrap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const TOKEN_IN = NATIVE_TOKEN_ADDRESS;
  const TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching wrap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, INPUT_AMOUNT);
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

### 6. **Running the Script**

To execute the wrap, run the script as follows:

<CodeGroup>
  ```bash python
  python wrap_token.py
  ```

  ```bash typescript
  npx tsx wrap_token.ts
  ```

  ```bash javascript
  node wrap_token.js
  ```
</CodeGroup>


# Zapping a Token
Source: https://docs.gluex.xyz/tutorials/zap-token

This tutorial provides a step-by-step guide on how to zap tokens (single token to LP position) using the GlueX Router.

## Prerequisites

Before running the script, ensure you have the following installed:

**Python:**

* Python 3.10
* Web3 (`pip install web3`)
* Requests (`pip install requests`)

**TypeScript:**

* Node.js 18+
* TypeScript (`npm install -g typescript`)
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

**JavaScript:**

* Node.js 18+
* Web3 (`npm install web3`)
* Axios (`npm install axios`)

Additionally, you need access to an Ethereum-compatible blockchain node, such as an Infura or Tenderly RPC endpoint.

## How GlueX Router Works

The GlueX Router simplifies the token zapping process by:

1. Fetching a price quote for zapping tokens into liquidity positions.
2. Generating the appropriate calldata for the zap.
3. Executing the transaction on-chain to zap tokens and receive LP tokens.

## Script Overview

### 1. **Setup and Configuration**

The following script initializes the necessary configurations:

<CodeGroup>
  ```python setup.py
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  TOKEN_IN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # Input token address
  LP_TOKEN_OUT = "0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852"  # LP token address
  INPUT_AMOUNT = 1000000000000000000  # Example: 1 token in Wei

  # Initialize Web3
  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price
  ```

  ```typescript setup.ts
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const TOKEN_IN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Input token address
  const LP_TOKEN_OUT = "0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852"; // LP token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 token in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  // Types
  interface QuoteBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: bigint;
      isPermit2: boolean;
  }

  interface QuoteRequestBody {
      chainID: string;
      userAddress: string;
      outputReceiver: string;
      uniquePID: string;
      inputToken: string;
      outputToken: string;
      inputAmount: string;
      isPermit2: boolean;
  }

  interface QuoteResponse {
      statusCode: number;
      result?: {
          router: string;
          calldata: string;
      };
  }
  ```

  ```javascript setup.js
  import { Web3 } from 'web3';
  import axios from 'axios';

  // Configuration
  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  // Token Information
  const TOKEN_IN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; // Input token address
  const LP_TOKEN_OUT = "0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852"; // LP token address
  const INPUT_AMOUNT = BigInt("1000000000000000000"); // Example: 1 token in Wei

  // Initialize Web3
  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;
  ```
</CodeGroup>

### 2. **Fetching a Zap Quote**

Before executing the zap, obtain a quote from the GlueX Router. This ensures that you get the best rate available:

<CodeGroup>
  ```python fetch_quote.py
  def fetch_quote(body, headers):
      """Fetch a quote from the GlueX Router."""
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()
  ```

  ```typescript fetch_quote.ts
  const fetchQuote = async (body: QuoteRequestBody, headers: { [key: string]: string }): Promise<QuoteResponse> => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```

  ```javascript fetch_quote.js
  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };
  ```
</CodeGroup>

This function sends a request to the GlueX Router to retrieve a quote for zapping tokens.

### 3. **Executing the Zap Transaction**

Once the quote is retrieved, execute the zap transaction by sending the appropriate calldata:

<CodeGroup>
  ```python execute_transaction.py
  def execute_transaction(calldata, router_address, account, value=0):
      """Execute transaction on the GlueX Router."""
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash
  ```

  ```typescript execute_transaction.ts
  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ): Promise<string> => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```

  ```javascript execute_transaction.js
  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };

      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };
  ```
</CodeGroup>

This function constructs and signs the transaction, ensuring it is sent to the Ethereum blockchain for processing.

### 4. **End-to-End Zap Execution**

The `main()` function ties everything together by fetching a quote and executing the transaction:

<CodeGroup>
  ```python main.py
  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",  # Ethereum Mainnet
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": LP_TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      
      print("============================================================================")
      print("Fetching zap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      
      print("Quote received successfully:")
      print(quote_data)
      
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=0)
      
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```

  ```typescript main.ts
  const main = async (): Promise<void> => {
      const headers = { "x-api-key": API_KEY };
      const body: QuoteBody = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: LP_TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching zap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result!.router;
      const calldata = quoteData.result!.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, BigInt(0));

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```

  ```javascript main.js
  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum", // Ethereum Mainnet
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: LP_TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };

      // Convert BigInt to string for axios serialization
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };

      console.log("============================================================================");
      console.log("Fetching zap quote...");
      console.log(requestBody);
      
      const quoteData = await fetchQuote(requestBody, headers);

      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }

      console.log("Quote received successfully:");
      console.log(quoteData);

      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;

      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, BigInt(0));

      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };

  // Run the main function
  main().catch(console.error);
  ```
</CodeGroup>

### 5. **Complete Code Implementation**

<Accordion title="Complete Python Implementation">
  ```python
  from web3 import Web3
  import requests
  import json
  import os
  import time

  # Configuration
  API_KEY = "your_api_key"
  UNIQUE_PID = "your_unique_pid"
  QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote"
  RPC_URL = "https://mainnet.gateway.co/your_rpc_url"
  PRIVATE_KEY = "your_private_key"

  # Token Information
  TOKEN_IN = "0xA0b86a33E6441b8c4C8C1C1B9B9B9B9B9B9B9B9B"
  LP_TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
  INPUT_AMOUNT = 1000000000000000000

  web3 = Web3(Web3.HTTPProvider(RPC_URL))
  account = web3.eth.account.from_key(PRIVATE_KEY)
  COMPUTATION_UNITS = 1000000
  COMPUTATION_COST = web3.eth.gas_price

  def fetch_quote(body, headers):
      response = requests.post(QUOTE_ENDPOINT, json=body, headers=headers)
      return response.json()

  def execute_transaction(calldata, router_address, account, value=0):
      txn = {
          "from": account.address,
          "to": Web3.to_checksum_address(router_address),
          "data": calldata,
          "gas": COMPUTATION_UNITS,
          "gasPrice": web3.eth.gas_price,
          "nonce": web3.eth.get_transaction_count(account.address),
          "value": value,
          "chainId": 1
      }
      signed_txn = web3.eth.account.sign_transaction(txn, account.key)
      txn_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)
      print(f"Transaction Hash: {web3.to_hex(txn_hash)}")
      return txn_hash

  def main():
      headers = {"x-api-key": API_KEY}
      body = {
          "chainID": "ethereum",
          "userAddress": account.address,
          "outputReceiver": account.address,
          "uniquePID": UNIQUE_PID,
          "inputToken": TOKEN_IN,
          "outputToken": LP_TOKEN_OUT,
          "inputAmount": INPUT_AMOUNT,
          "isPermit2": False
      }
      print("============================================================================")
      print("Fetching zap quote...")
      print(body)
      quote_data = fetch_quote(body, headers)
      if quote_data.get('statusCode') != 200:
          print("Error fetching quote:", quote_data)
          return
      print("Quote received successfully:")
      print(quote_data)
      router_address = quote_data["result"]["router"]
      calldata = quote_data["result"]["calldata"]
      print("Executing transaction...")
      execute_txn = execute_transaction(calldata, router_address, account, value=0)
      receipt = web3.eth.wait_for_transaction_receipt(execute_txn)
      print("Transaction confirmed. Receipt:")
      print(receipt)
      print("")

  if __name__ == "__main__":
      main()
  ```
</Accordion>

<Accordion title="Complete TypeScript Implementation">
  ```typescript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const TOKEN_IN = "0xA0b86a33E6441b8c4C8C1C1B9B9B9B9B9B9B9B9B";
  const LP_TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body: any, headers: { [key: string]: string }) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata: string,
      routerAddress: string,
      account: any,
      value: bigint = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: LP_TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching zap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, BigInt(0));
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

<Accordion title="Complete JavaScript Implementation">
  ```javascript
  import { Web3 } from 'web3';
  import axios from 'axios';

  const API_KEY = "your_api_key";
  const UNIQUE_PID = "your_unique_pid";
  const QUOTE_ENDPOINT = "https://router.gluex.xyz/v1/quote";
  const RPC_URL = "https://mainnet.gateway.co/your_rpc_url";
  const PRIVATE_KEY = "your_private_key";

  const TOKEN_IN = "0xA0b86a33E6441b8c4C8C1C1B9B9B9B9B9B9B9B9B";
  const LP_TOKEN_OUT = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
  const INPUT_AMOUNT = BigInt("1000000000000000000");

  const web3 = new Web3(RPC_URL);
  const account = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);
  const COMPUTATION_UNITS = 1000000;

  const fetchQuote = async (body, headers) => {
      const response = await axios.post(QUOTE_ENDPOINT, body, { headers });
      return response.data;
  };

  const executeTransaction = async (
      calldata,
      routerAddress,
      account,
      value = BigInt(0)
  ) => {
      const txn = {
          from: account.address,
          to: web3.utils.toChecksumAddress(routerAddress),
          data: calldata,
          gas: COMPUTATION_UNITS,
          gasPrice: await web3.eth.getGasPrice(),
          nonce: await web3.eth.getTransactionCount(account.address),
          value: value,
          chainId: 1
      };
      const signedTxn = await account.signTransaction(txn);
      const receipt = await web3.eth.sendSignedTransaction(signedTxn.rawTransaction);
      const txHash = web3.utils.toHex(receipt.transactionHash);
      console.log(`Transaction Hash: ${txHash}`);
      return txHash;
  };

  const main = async () => {
      const headers = { "x-api-key": API_KEY };
      const body = {
          chainID: "ethereum",
          userAddress: account.address,
          outputReceiver: account.address,
          uniquePID: UNIQUE_PID,
          inputToken: TOKEN_IN,
          outputToken: LP_TOKEN_OUT,
          inputAmount: INPUT_AMOUNT,
          isPermit2: false
      };
      const requestBody = {
          ...body,
          inputAmount: body.inputAmount.toString()
      };
      console.log("============================================================================");
      console.log("Fetching zap quote...");
      console.log(requestBody);
      const quoteData = await fetchQuote(requestBody, headers);
      if (quoteData.statusCode !== 200) {
          console.log("Error fetching quote:", quoteData);
          return;
      }
      console.log("Quote received successfully:");
      console.log(quoteData);
      const routerAddress = quoteData.result.router;
      const calldata = quoteData.result.calldata;
      console.log("Executing transaction...");
      const executeTxn = await executeTransaction(calldata, routerAddress, account, BigInt(0));
      const receipt = await web3.eth.getTransactionReceipt(executeTxn);
      console.log("Transaction confirmed. Receipt:");
      console.log(receipt);
      console.log("");
  };
  main().catch(console.error);
  ```
</Accordion>

### 6. **Running the Script**

To execute the zap, run the script as follows:

<CodeGroup>
  ```bash python
  python zap_token.py
  ```

  ```bash typescript
  npx tsx zap_token.ts
  ```

  ```bash javascript
  node zap_token.js
  ```
</CodeGroup>

